import {
  require_http
} from "./chunk-MHJDNTSG.js";
import {
  require_https
} from "./chunk-N6I6HNZ2.js";
import {
  require_url
} from "./chunk-W3TQBGP4.js";
import {
  require_fs
} from "./chunk-4RL6IR4I.js";
import {
  require_client
} from "./chunk-DBEJOCIW.js";
import {
  require_react_dom
} from "./chunk-5I22YAI3.js";
import {
  require_prop_types
} from "./chunk-TZ6YLGSN.js";
import {
  require_react
} from "./chunk-CMM6OKGN.js";
import {
  __commonJS,
  __esm,
  __export,
  __require,
  __toCommonJS,
  __toESM
} from "./chunk-OL46QLBJ.js";

// node_modules/dommatrix/dist/dommatrix.js
var require_dommatrix = __commonJS({
  "node_modules/dommatrix/dist/dommatrix.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.CSSMatrix = factory());
    })(exports2, function() {
      "use strict";
      function fromArray(array) {
        var m = new CSSMatrix();
        var a = Array.from(array);
        if (!a.every(function(n) {
          return !Number.isNaN(n);
        })) {
          throw TypeError('CSSMatrix: "' + array + '" must only have numbers.');
        }
        if (a.length === 16) {
          var m11 = a[0];
          var m12 = a[1];
          var m13 = a[2];
          var m14 = a[3];
          var m21 = a[4];
          var m22 = a[5];
          var m23 = a[6];
          var m24 = a[7];
          var m31 = a[8];
          var m32 = a[9];
          var m33 = a[10];
          var m34 = a[11];
          var m41 = a[12];
          var m42 = a[13];
          var m43 = a[14];
          var m44 = a[15];
          m.m11 = m11;
          m.a = m11;
          m.m21 = m21;
          m.c = m21;
          m.m31 = m31;
          m.m41 = m41;
          m.e = m41;
          m.m12 = m12;
          m.b = m12;
          m.m22 = m22;
          m.d = m22;
          m.m32 = m32;
          m.m42 = m42;
          m.f = m42;
          m.m13 = m13;
          m.m23 = m23;
          m.m33 = m33;
          m.m43 = m43;
          m.m14 = m14;
          m.m24 = m24;
          m.m34 = m34;
          m.m44 = m44;
        } else if (a.length === 6) {
          var M11 = a[0];
          var M12 = a[1];
          var M21 = a[2];
          var M22 = a[3];
          var M41 = a[4];
          var M42 = a[5];
          m.m11 = M11;
          m.a = M11;
          m.m12 = M12;
          m.b = M12;
          m.m21 = M21;
          m.c = M21;
          m.m22 = M22;
          m.d = M22;
          m.m41 = M41;
          m.e = M41;
          m.m42 = M42;
          m.f = M42;
        } else {
          throw new TypeError("CSSMatrix: expecting an Array of 6/16 values.");
        }
        return m;
      }
      function fromMatrix(m) {
        var keys = Object.keys(new CSSMatrix());
        if (typeof m === "object" && keys.every(function(k) {
          return k in m;
        })) {
          return fromArray(
            [
              m.m11,
              m.m12,
              m.m13,
              m.m14,
              m.m21,
              m.m22,
              m.m23,
              m.m24,
              m.m31,
              m.m32,
              m.m33,
              m.m34,
              m.m41,
              m.m42,
              m.m43,
              m.m44
            ]
          );
        }
        throw TypeError('CSSMatrix: "' + JSON.stringify(m) + '" is not a DOMMatrix / CSSMatrix / JSON compatible object.');
      }
      function fromString(source) {
        if (typeof source !== "string") {
          throw TypeError('CSSMatrix: "' + source + '" is not a string.');
        }
        var str = String(source).replace(/\s/g, "");
        var m = new CSSMatrix();
        var invalidStringError = 'CSSMatrix: invalid transform string "' + source + '"';
        str.split(")").filter(function(f) {
          return f;
        }).forEach(function(tf) {
          var ref = tf.split("(");
          var prop = ref[0];
          var value = ref[1];
          if (!value) {
            throw TypeError(invalidStringError);
          }
          var components = value.split(",").map(function(n) {
            return n.includes("rad") ? parseFloat(n) * (180 / Math.PI) : parseFloat(n);
          });
          var x = components[0];
          var y = components[1];
          var z = components[2];
          var a = components[3];
          var xyz = [x, y, z];
          var xyza = [x, y, z, a];
          if (prop === "perspective" && x && [y, z].every(function(n) {
            return n === void 0;
          })) {
            m.m34 = -1 / x;
          } else if (prop.includes("matrix") && [6, 16].includes(components.length) && components.every(function(n) {
            return !Number.isNaN(+n);
          })) {
            var values = components.map(function(n) {
              return Math.abs(n) < 1e-6 ? 0 : n;
            });
            m = m.multiply(fromArray(values));
          } else if (prop === "translate3d" && xyz.every(function(n) {
            return !Number.isNaN(+n);
          })) {
            m = m.translate(x, y, z);
          } else if (prop === "translate" && x && z === void 0) {
            m = m.translate(x, y || 0, 0);
          } else if (prop === "rotate3d" && xyza.every(function(n) {
            return !Number.isNaN(+n);
          }) && a) {
            m = m.rotateAxisAngle(x, y, z, a);
          } else if (prop === "rotate" && x && [y, z].every(function(n) {
            return n === void 0;
          })) {
            m = m.rotate(0, 0, x);
          } else if (prop === "scale3d" && xyz.every(function(n) {
            return !Number.isNaN(+n);
          }) && xyz.some(function(n) {
            return n !== 1;
          })) {
            m = m.scale(x, y, z);
          } else if (prop === "scale" && !Number.isNaN(x) && x !== 1 && z === void 0) {
            var nosy = Number.isNaN(+y);
            var sy = nosy ? x : y;
            m = m.scale(x, sy, 1);
          } else if (prop === "skew" && (x || !Number.isNaN(x) && y) && z === void 0) {
            m = m.skew(x, y || 0);
          } else if (/[XYZ]/.test(prop) && x && [y, z].every(function(n) {
            return n === void 0;
          }) && ["translate", "rotate", "scale", "skew"].some(function(p) {
            return prop.includes(p);
          })) {
            if (["skewX", "skewY"].includes(prop)) {
              m = m[prop](x);
            } else {
              var fn = prop.replace(/[XYZ]/, "");
              var axis = prop.replace(fn, "");
              var idx = ["X", "Y", "Z"].indexOf(axis);
              var def = fn === "scale" ? 1 : 0;
              var axeValues = [
                idx === 0 ? x : def,
                idx === 1 ? x : def,
                idx === 2 ? x : def
              ];
              m = m[fn].apply(m, axeValues);
            }
          } else {
            throw TypeError(invalidStringError);
          }
        });
        return m;
      }
      function toArray(m, is2D) {
        if (is2D) {
          return [m.a, m.b, m.c, m.d, m.e, m.f];
        }
        return [
          m.m11,
          m.m12,
          m.m13,
          m.m14,
          m.m21,
          m.m22,
          m.m23,
          m.m24,
          m.m31,
          m.m32,
          m.m33,
          m.m34,
          m.m41,
          m.m42,
          m.m43,
          m.m44
        ];
      }
      function Translate(x, y, z) {
        var m = new CSSMatrix();
        m.m41 = x;
        m.e = x;
        m.m42 = y;
        m.f = y;
        m.m43 = z;
        return m;
      }
      function Rotate(rx, ry, rz) {
        var m = new CSSMatrix();
        var degToRad = Math.PI / 180;
        var radX = rx * degToRad;
        var radY = ry * degToRad;
        var radZ = rz * degToRad;
        var cosx = Math.cos(radX);
        var sinx = -Math.sin(radX);
        var cosy = Math.cos(radY);
        var siny = -Math.sin(radY);
        var cosz = Math.cos(radZ);
        var sinz = -Math.sin(radZ);
        var m11 = cosy * cosz;
        var m12 = -cosy * sinz;
        m.m11 = m11;
        m.a = m11;
        m.m12 = m12;
        m.b = m12;
        m.m13 = siny;
        var m21 = sinx * siny * cosz + cosx * sinz;
        m.m21 = m21;
        m.c = m21;
        var m22 = cosx * cosz - sinx * siny * sinz;
        m.m22 = m22;
        m.d = m22;
        m.m23 = -sinx * cosy;
        m.m31 = sinx * sinz - cosx * siny * cosz;
        m.m32 = sinx * cosz + cosx * siny * sinz;
        m.m33 = cosx * cosy;
        return m;
      }
      function RotateAxisAngle(x, y, z, alpha) {
        var m = new CSSMatrix();
        var length = Math.sqrt(x * x + y * y + z * z);
        if (length === 0) {
          return m;
        }
        var X = x / length;
        var Y = y / length;
        var Z = z / length;
        var angle = alpha * (Math.PI / 360);
        var sinA = Math.sin(angle);
        var cosA = Math.cos(angle);
        var sinA2 = sinA * sinA;
        var x2 = X * X;
        var y2 = Y * Y;
        var z2 = Z * Z;
        var m11 = 1 - 2 * (y2 + z2) * sinA2;
        m.m11 = m11;
        m.a = m11;
        var m12 = 2 * (X * Y * sinA2 + Z * sinA * cosA);
        m.m12 = m12;
        m.b = m12;
        m.m13 = 2 * (X * Z * sinA2 - Y * sinA * cosA);
        var m21 = 2 * (Y * X * sinA2 - Z * sinA * cosA);
        m.m21 = m21;
        m.c = m21;
        var m22 = 1 - 2 * (z2 + x2) * sinA2;
        m.m22 = m22;
        m.d = m22;
        m.m23 = 2 * (Y * Z * sinA2 + X * sinA * cosA);
        m.m31 = 2 * (Z * X * sinA2 + Y * sinA * cosA);
        m.m32 = 2 * (Z * Y * sinA2 - X * sinA * cosA);
        m.m33 = 1 - 2 * (x2 + y2) * sinA2;
        return m;
      }
      function Scale(x, y, z) {
        var m = new CSSMatrix();
        m.m11 = x;
        m.a = x;
        m.m22 = y;
        m.d = y;
        m.m33 = z;
        return m;
      }
      function Skew(angleX, angleY) {
        var m = new CSSMatrix();
        if (angleX) {
          var radX = angleX * Math.PI / 180;
          var tX = Math.tan(radX);
          m.m21 = tX;
          m.c = tX;
        }
        if (angleY) {
          var radY = angleY * Math.PI / 180;
          var tY = Math.tan(radY);
          m.m12 = tY;
          m.b = tY;
        }
        return m;
      }
      function SkewX(angle) {
        return Skew(angle, 0);
      }
      function SkewY(angle) {
        return Skew(0, angle);
      }
      function Multiply(m1, m2) {
        var m11 = m2.m11 * m1.m11 + m2.m12 * m1.m21 + m2.m13 * m1.m31 + m2.m14 * m1.m41;
        var m12 = m2.m11 * m1.m12 + m2.m12 * m1.m22 + m2.m13 * m1.m32 + m2.m14 * m1.m42;
        var m13 = m2.m11 * m1.m13 + m2.m12 * m1.m23 + m2.m13 * m1.m33 + m2.m14 * m1.m43;
        var m14 = m2.m11 * m1.m14 + m2.m12 * m1.m24 + m2.m13 * m1.m34 + m2.m14 * m1.m44;
        var m21 = m2.m21 * m1.m11 + m2.m22 * m1.m21 + m2.m23 * m1.m31 + m2.m24 * m1.m41;
        var m22 = m2.m21 * m1.m12 + m2.m22 * m1.m22 + m2.m23 * m1.m32 + m2.m24 * m1.m42;
        var m23 = m2.m21 * m1.m13 + m2.m22 * m1.m23 + m2.m23 * m1.m33 + m2.m24 * m1.m43;
        var m24 = m2.m21 * m1.m14 + m2.m22 * m1.m24 + m2.m23 * m1.m34 + m2.m24 * m1.m44;
        var m31 = m2.m31 * m1.m11 + m2.m32 * m1.m21 + m2.m33 * m1.m31 + m2.m34 * m1.m41;
        var m32 = m2.m31 * m1.m12 + m2.m32 * m1.m22 + m2.m33 * m1.m32 + m2.m34 * m1.m42;
        var m33 = m2.m31 * m1.m13 + m2.m32 * m1.m23 + m2.m33 * m1.m33 + m2.m34 * m1.m43;
        var m34 = m2.m31 * m1.m14 + m2.m32 * m1.m24 + m2.m33 * m1.m34 + m2.m34 * m1.m44;
        var m41 = m2.m41 * m1.m11 + m2.m42 * m1.m21 + m2.m43 * m1.m31 + m2.m44 * m1.m41;
        var m42 = m2.m41 * m1.m12 + m2.m42 * m1.m22 + m2.m43 * m1.m32 + m2.m44 * m1.m42;
        var m43 = m2.m41 * m1.m13 + m2.m42 * m1.m23 + m2.m43 * m1.m33 + m2.m44 * m1.m43;
        var m44 = m2.m41 * m1.m14 + m2.m42 * m1.m24 + m2.m43 * m1.m34 + m2.m44 * m1.m44;
        return fromArray(
          [
            m11,
            m12,
            m13,
            m14,
            m21,
            m22,
            m23,
            m24,
            m31,
            m32,
            m33,
            m34,
            m41,
            m42,
            m43,
            m44
          ]
        );
      }
      var CSSMatrix = function CSSMatrix2() {
        var args = [], len = arguments.length;
        while (len--) args[len] = arguments[len];
        var m = this;
        m.a = 1;
        m.b = 0;
        m.c = 0;
        m.d = 1;
        m.e = 0;
        m.f = 0;
        m.m11 = 1;
        m.m12 = 0;
        m.m13 = 0;
        m.m14 = 0;
        m.m21 = 0;
        m.m22 = 1;
        m.m23 = 0;
        m.m24 = 0;
        m.m31 = 0;
        m.m32 = 0;
        m.m33 = 1;
        m.m34 = 0;
        m.m41 = 0;
        m.m42 = 0;
        m.m43 = 0;
        m.m44 = 1;
        if (args.length) {
          var ARGS = [16, 6].some(function(l) {
            return l === args.length;
          }) ? args : args[0];
          return m.setMatrixValue(ARGS);
        }
        return m;
      };
      var prototypeAccessors = { isIdentity: { configurable: true }, is2D: { configurable: true } };
      prototypeAccessors.isIdentity.get = function() {
        var m = this;
        return m.m11 === 1 && m.m12 === 0 && m.m13 === 0 && m.m14 === 0 && m.m21 === 0 && m.m22 === 1 && m.m23 === 0 && m.m24 === 0 && m.m31 === 0 && m.m32 === 0 && m.m33 === 1 && m.m34 === 0 && m.m41 === 0 && m.m42 === 0 && m.m43 === 0 && m.m44 === 1;
      };
      prototypeAccessors.is2D.get = function() {
        var m = this;
        return m.m31 === 0 && m.m32 === 0 && m.m33 === 1 && m.m34 === 0 && m.m43 === 0 && m.m44 === 1;
      };
      CSSMatrix.prototype.setMatrixValue = function setMatrixValue(source) {
        var m = this;
        if (typeof source === "string" && source.length && source !== "none") {
          return fromString(source);
        }
        if ([Array, Float64Array, Float32Array].some(function(a) {
          return source instanceof a;
        })) {
          return fromArray(source);
        }
        if ([CSSMatrix, DOMMatrix, Object].some(function(a) {
          return source instanceof a;
        })) {
          return fromMatrix(source);
        }
        return m;
      };
      CSSMatrix.prototype.toFloat32Array = function toFloat32Array(is2D) {
        return Float32Array.from(toArray(this, is2D));
      };
      CSSMatrix.prototype.toFloat64Array = function toFloat64Array(is2D) {
        return Float64Array.from(toArray(this, is2D));
      };
      CSSMatrix.prototype.toString = function toString() {
        var m = this;
        var is2D = m.is2D;
        var values = m.toFloat64Array(is2D).join(", ");
        var type = is2D ? "matrix" : "matrix3d";
        return type + "(" + values + ")";
      };
      CSSMatrix.prototype.toJSON = function toJSON() {
        var m = this;
        var is2D = m.is2D;
        var isIdentity = m.isIdentity;
        return Object.assign({}, m, { is2D, isIdentity });
      };
      CSSMatrix.prototype.multiply = function multiply(m2) {
        return Multiply(this, m2);
      };
      CSSMatrix.prototype.translate = function translate(x, y, z) {
        var X = x;
        var Y = y;
        var Z = z;
        if (Y === void 0) {
          Y = 0;
        }
        if (Z === void 0) {
          Z = 0;
        }
        return Multiply(this, Translate(X, Y, Z));
      };
      CSSMatrix.prototype.scale = function scale(x, y, z) {
        var X = x;
        var Y = y;
        var Z = z;
        if (Y === void 0) {
          Y = x;
        }
        if (Z === void 0) {
          Z = 1;
        }
        return Multiply(this, Scale(X, Y, Z));
      };
      CSSMatrix.prototype.rotate = function rotate(rx, ry, rz) {
        var RX = rx;
        var RY = ry || 0;
        var RZ = rz || 0;
        if (typeof rx === "number" && ry === void 0 && rz === void 0) {
          RZ = RX;
          RX = 0;
          RY = 0;
        }
        return Multiply(this, Rotate(RX, RY, RZ));
      };
      CSSMatrix.prototype.rotateAxisAngle = function rotateAxisAngle(x, y, z, angle) {
        if ([x, y, z, angle].some(function(n) {
          return Number.isNaN(+n);
        })) {
          throw new TypeError("CSSMatrix: expecting 4 values");
        }
        return Multiply(this, RotateAxisAngle(x, y, z, angle));
      };
      CSSMatrix.prototype.skewX = function skewX(angle) {
        return Multiply(this, SkewX(angle));
      };
      CSSMatrix.prototype.skewY = function skewY(angle) {
        return Multiply(this, SkewY(angle));
      };
      CSSMatrix.prototype.skew = function skew(angleX, angleY) {
        return Multiply(this, Skew(angleX, angleY));
      };
      CSSMatrix.prototype.transformPoint = function transformPoint(t) {
        var m = this;
        var x = m.m11 * t.x + m.m21 * t.y + m.m31 * t.z + m.m41 * t.w;
        var y = m.m12 * t.x + m.m22 * t.y + m.m32 * t.z + m.m42 * t.w;
        var z = m.m13 * t.x + m.m23 * t.y + m.m33 * t.z + m.m43 * t.w;
        var w = m.m14 * t.x + m.m24 * t.y + m.m34 * t.z + m.m44 * t.w;
        return t instanceof DOMPoint ? new DOMPoint(x, y, z, w) : {
          x,
          y,
          z,
          w
        };
      };
      Object.defineProperties(CSSMatrix.prototype, prototypeAccessors);
      Object.assign(CSSMatrix, {
        Translate,
        Rotate,
        RotateAxisAngle,
        Scale,
        SkewX,
        SkewY,
        Skew,
        Multiply,
        fromArray,
        fromMatrix,
        fromString,
        toArray
      });
      var version2 = "1.0.3";
      var Version = version2;
      Object.assign(CSSMatrix, { Version });
      return CSSMatrix;
    });
  }
});

// node_modules/web-streams-polyfill/dist/ponyfill.js
var require_ponyfill = __commonJS({
  "node_modules/web-streams-polyfill/dist/ponyfill.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.WebStreamsPolyfill = {}));
    })(exports2, function(exports3) {
      "use strict";
      var SymbolPolyfill = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol : function(description) {
        return "Symbol(".concat(description, ")");
      };
      function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t[0] & 1) throw t[1];
          return t[1];
        }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
          return this;
        }), g;
        function verb(n) {
          return function(v) {
            return step([n, v]);
          };
        }
        function step(op) {
          if (f) throw new TypeError("Generator is already executing.");
          while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2]) _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
          if (op[0] & 5) throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      }
      function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
          next: function() {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
      }
      function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
      }
      function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
          return this;
        }, i;
        function verb(n) {
          if (g[n]) i[n] = function(v) {
            return new Promise(function(a, b) {
              q.push([n, v, a, b]) > 1 || resume(n, v);
            });
          };
        }
        function resume(n, v) {
          try {
            step(g[n](v));
          } catch (e) {
            settle(q[0][3], e);
          }
        }
        function step(r2) {
          r2.value instanceof __await ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q[0][2], r2);
        }
        function fulfill(value) {
          resume("next", value);
        }
        function reject(value) {
          resume("throw", value);
        }
        function settle(f, v) {
          if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
        }
      }
      function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function(e) {
          throw e;
        }), verb("return"), i[Symbol.iterator] = function() {
          return this;
        }, i;
        function verb(n, f) {
          i[n] = o[n] ? function(v) {
            return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v;
          } : f;
        }
      }
      function __asyncValues(o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
          return this;
        }, i);
        function verb(n) {
          i[n] = o[n] && function(v) {
            return new Promise(function(resolve, reject) {
              v = o[n](v), settle(resolve, reject, v.done, v.value);
            });
          };
        }
        function settle(resolve, reject, d, v) {
          Promise.resolve(v).then(function(v2) {
            resolve({ value: v2, done: d });
          }, reject);
        }
      }
      typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
        var e = new Error(message);
        return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
      };
      function noop() {
        return void 0;
      }
      function typeIsObject(x) {
        return typeof x === "object" && x !== null || typeof x === "function";
      }
      var rethrowAssertionErrorRejection = noop;
      function setFunctionName(fn, name) {
        try {
          Object.defineProperty(fn, "name", {
            value: name,
            configurable: true
          });
        } catch (_a2) {
        }
      }
      var originalPromise = Promise;
      var originalPromiseThen = Promise.prototype.then;
      var originalPromiseReject = Promise.reject.bind(originalPromise);
      function newPromise(executor) {
        return new originalPromise(executor);
      }
      function promiseResolvedWith(value) {
        return newPromise(function(resolve) {
          return resolve(value);
        });
      }
      function promiseRejectedWith(reason) {
        return originalPromiseReject(reason);
      }
      function PerformPromiseThen(promise, onFulfilled, onRejected) {
        return originalPromiseThen.call(promise, onFulfilled, onRejected);
      }
      function uponPromise(promise, onFulfilled, onRejected) {
        PerformPromiseThen(PerformPromiseThen(promise, onFulfilled, onRejected), void 0, rethrowAssertionErrorRejection);
      }
      function uponFulfillment(promise, onFulfilled) {
        uponPromise(promise, onFulfilled);
      }
      function uponRejection(promise, onRejected) {
        uponPromise(promise, void 0, onRejected);
      }
      function transformPromiseWith(promise, fulfillmentHandler, rejectionHandler) {
        return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);
      }
      function setPromiseIsHandledToTrue(promise) {
        PerformPromiseThen(promise, void 0, rethrowAssertionErrorRejection);
      }
      var _queueMicrotask = function(callback) {
        if (typeof queueMicrotask === "function") {
          _queueMicrotask = queueMicrotask;
        } else {
          var resolvedPromise_1 = promiseResolvedWith(void 0);
          _queueMicrotask = function(cb) {
            return PerformPromiseThen(resolvedPromise_1, cb);
          };
        }
        return _queueMicrotask(callback);
      };
      function reflectCall(F, V, args) {
        if (typeof F !== "function") {
          throw new TypeError("Argument is not a function");
        }
        return Function.prototype.apply.call(F, V, args);
      }
      function promiseCall(F, V, args) {
        try {
          return promiseResolvedWith(reflectCall(F, V, args));
        } catch (value) {
          return promiseRejectedWith(value);
        }
      }
      var QUEUE_MAX_ARRAY_SIZE = 16384;
      var SimpleQueue = (
        /** @class */
        function() {
          function SimpleQueue2() {
            this._cursor = 0;
            this._size = 0;
            this._front = {
              _elements: [],
              _next: void 0
            };
            this._back = this._front;
            this._cursor = 0;
            this._size = 0;
          }
          Object.defineProperty(SimpleQueue2.prototype, "length", {
            get: function() {
              return this._size;
            },
            enumerable: false,
            configurable: true
          });
          SimpleQueue2.prototype.push = function(element) {
            var oldBack = this._back;
            var newBack = oldBack;
            if (oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1) {
              newBack = {
                _elements: [],
                _next: void 0
              };
            }
            oldBack._elements.push(element);
            if (newBack !== oldBack) {
              this._back = newBack;
              oldBack._next = newBack;
            }
            ++this._size;
          };
          SimpleQueue2.prototype.shift = function() {
            var oldFront = this._front;
            var newFront = oldFront;
            var oldCursor = this._cursor;
            var newCursor = oldCursor + 1;
            var elements = oldFront._elements;
            var element = elements[oldCursor];
            if (newCursor === QUEUE_MAX_ARRAY_SIZE) {
              newFront = oldFront._next;
              newCursor = 0;
            }
            --this._size;
            this._cursor = newCursor;
            if (oldFront !== newFront) {
              this._front = newFront;
            }
            elements[oldCursor] = void 0;
            return element;
          };
          SimpleQueue2.prototype.forEach = function(callback) {
            var i = this._cursor;
            var node = this._front;
            var elements = node._elements;
            while (i !== elements.length || node._next !== void 0) {
              if (i === elements.length) {
                node = node._next;
                elements = node._elements;
                i = 0;
                if (elements.length === 0) {
                  break;
                }
              }
              callback(elements[i]);
              ++i;
            }
          };
          SimpleQueue2.prototype.peek = function() {
            var front = this._front;
            var cursor = this._cursor;
            return front._elements[cursor];
          };
          return SimpleQueue2;
        }()
      );
      var AbortSteps = SymbolPolyfill("[[AbortSteps]]");
      var ErrorSteps = SymbolPolyfill("[[ErrorSteps]]");
      var CancelSteps = SymbolPolyfill("[[CancelSteps]]");
      var PullSteps = SymbolPolyfill("[[PullSteps]]");
      var ReleaseSteps = SymbolPolyfill("[[ReleaseSteps]]");
      function ReadableStreamReaderGenericInitialize(reader, stream) {
        reader._ownerReadableStream = stream;
        stream._reader = reader;
        if (stream._state === "readable") {
          defaultReaderClosedPromiseInitialize(reader);
        } else if (stream._state === "closed") {
          defaultReaderClosedPromiseInitializeAsResolved(reader);
        } else {
          defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);
        }
      }
      function ReadableStreamReaderGenericCancel(reader, reason) {
        var stream = reader._ownerReadableStream;
        return ReadableStreamCancel(stream, reason);
      }
      function ReadableStreamReaderGenericRelease(reader) {
        var stream = reader._ownerReadableStream;
        if (stream._state === "readable") {
          defaultReaderClosedPromiseReject(reader, new TypeError("Reader was released and can no longer be used to monitor the stream's closedness"));
        } else {
          defaultReaderClosedPromiseResetToRejected(reader, new TypeError("Reader was released and can no longer be used to monitor the stream's closedness"));
        }
        stream._readableStreamController[ReleaseSteps]();
        stream._reader = void 0;
        reader._ownerReadableStream = void 0;
      }
      function readerLockException(name) {
        return new TypeError("Cannot " + name + " a stream using a released reader");
      }
      function defaultReaderClosedPromiseInitialize(reader) {
        reader._closedPromise = newPromise(function(resolve, reject) {
          reader._closedPromise_resolve = resolve;
          reader._closedPromise_reject = reject;
        });
      }
      function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {
        defaultReaderClosedPromiseInitialize(reader);
        defaultReaderClosedPromiseReject(reader, reason);
      }
      function defaultReaderClosedPromiseInitializeAsResolved(reader) {
        defaultReaderClosedPromiseInitialize(reader);
        defaultReaderClosedPromiseResolve(reader);
      }
      function defaultReaderClosedPromiseReject(reader, reason) {
        if (reader._closedPromise_reject === void 0) {
          return;
        }
        setPromiseIsHandledToTrue(reader._closedPromise);
        reader._closedPromise_reject(reason);
        reader._closedPromise_resolve = void 0;
        reader._closedPromise_reject = void 0;
      }
      function defaultReaderClosedPromiseResetToRejected(reader, reason) {
        defaultReaderClosedPromiseInitializeAsRejected(reader, reason);
      }
      function defaultReaderClosedPromiseResolve(reader) {
        if (reader._closedPromise_resolve === void 0) {
          return;
        }
        reader._closedPromise_resolve(void 0);
        reader._closedPromise_resolve = void 0;
        reader._closedPromise_reject = void 0;
      }
      var NumberIsFinite = Number.isFinite || function(x) {
        return typeof x === "number" && isFinite(x);
      };
      var MathTrunc = Math.trunc || function(v) {
        return v < 0 ? Math.ceil(v) : Math.floor(v);
      };
      function isDictionary(x) {
        return typeof x === "object" || typeof x === "function";
      }
      function assertDictionary(obj, context) {
        if (obj !== void 0 && !isDictionary(obj)) {
          throw new TypeError("".concat(context, " is not an object."));
        }
      }
      function assertFunction(x, context) {
        if (typeof x !== "function") {
          throw new TypeError("".concat(context, " is not a function."));
        }
      }
      function isObject(x) {
        return typeof x === "object" && x !== null || typeof x === "function";
      }
      function assertObject(x, context) {
        if (!isObject(x)) {
          throw new TypeError("".concat(context, " is not an object."));
        }
      }
      function assertRequiredArgument(x, position, context) {
        if (x === void 0) {
          throw new TypeError("Parameter ".concat(position, " is required in '").concat(context, "'."));
        }
      }
      function assertRequiredField(x, field, context) {
        if (x === void 0) {
          throw new TypeError("".concat(field, " is required in '").concat(context, "'."));
        }
      }
      function convertUnrestrictedDouble(value) {
        return Number(value);
      }
      function censorNegativeZero(x) {
        return x === 0 ? 0 : x;
      }
      function integerPart(x) {
        return censorNegativeZero(MathTrunc(x));
      }
      function convertUnsignedLongLongWithEnforceRange(value, context) {
        var lowerBound = 0;
        var upperBound = Number.MAX_SAFE_INTEGER;
        var x = Number(value);
        x = censorNegativeZero(x);
        if (!NumberIsFinite(x)) {
          throw new TypeError("".concat(context, " is not a finite number"));
        }
        x = integerPart(x);
        if (x < lowerBound || x > upperBound) {
          throw new TypeError("".concat(context, " is outside the accepted range of ").concat(lowerBound, " to ").concat(upperBound, ", inclusive"));
        }
        if (!NumberIsFinite(x) || x === 0) {
          return 0;
        }
        return x;
      }
      function assertReadableStream(x, context) {
        if (!IsReadableStream(x)) {
          throw new TypeError("".concat(context, " is not a ReadableStream."));
        }
      }
      function AcquireReadableStreamDefaultReader(stream) {
        return new ReadableStreamDefaultReader(stream);
      }
      function ReadableStreamAddReadRequest(stream, readRequest) {
        stream._reader._readRequests.push(readRequest);
      }
      function ReadableStreamFulfillReadRequest(stream, chunk, done) {
        var reader = stream._reader;
        var readRequest = reader._readRequests.shift();
        if (done) {
          readRequest._closeSteps();
        } else {
          readRequest._chunkSteps(chunk);
        }
      }
      function ReadableStreamGetNumReadRequests(stream) {
        return stream._reader._readRequests.length;
      }
      function ReadableStreamHasDefaultReader(stream) {
        var reader = stream._reader;
        if (reader === void 0) {
          return false;
        }
        if (!IsReadableStreamDefaultReader(reader)) {
          return false;
        }
        return true;
      }
      var ReadableStreamDefaultReader = (
        /** @class */
        function() {
          function ReadableStreamDefaultReader2(stream) {
            assertRequiredArgument(stream, 1, "ReadableStreamDefaultReader");
            assertReadableStream(stream, "First parameter");
            if (IsReadableStreamLocked(stream)) {
              throw new TypeError("This stream has already been locked for exclusive reading by another reader");
            }
            ReadableStreamReaderGenericInitialize(this, stream);
            this._readRequests = new SimpleQueue();
          }
          Object.defineProperty(ReadableStreamDefaultReader2.prototype, "closed", {
            /**
             * Returns a promise that will be fulfilled when the stream becomes closed,
             * or rejected if the stream ever errors or the reader's lock is released before the stream finishes closing.
             */
            get: function() {
              if (!IsReadableStreamDefaultReader(this)) {
                return promiseRejectedWith(defaultReaderBrandCheckException("closed"));
              }
              return this._closedPromise;
            },
            enumerable: false,
            configurable: true
          });
          ReadableStreamDefaultReader2.prototype.cancel = function(reason) {
            if (reason === void 0) {
              reason = void 0;
            }
            if (!IsReadableStreamDefaultReader(this)) {
              return promiseRejectedWith(defaultReaderBrandCheckException("cancel"));
            }
            if (this._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("cancel"));
            }
            return ReadableStreamReaderGenericCancel(this, reason);
          };
          ReadableStreamDefaultReader2.prototype.read = function() {
            if (!IsReadableStreamDefaultReader(this)) {
              return promiseRejectedWith(defaultReaderBrandCheckException("read"));
            }
            if (this._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("read from"));
            }
            var resolvePromise;
            var rejectPromise;
            var promise = newPromise(function(resolve, reject) {
              resolvePromise = resolve;
              rejectPromise = reject;
            });
            var readRequest = {
              _chunkSteps: function(chunk) {
                return resolvePromise({ value: chunk, done: false });
              },
              _closeSteps: function() {
                return resolvePromise({ value: void 0, done: true });
              },
              _errorSteps: function(e) {
                return rejectPromise(e);
              }
            };
            ReadableStreamDefaultReaderRead(this, readRequest);
            return promise;
          };
          ReadableStreamDefaultReader2.prototype.releaseLock = function() {
            if (!IsReadableStreamDefaultReader(this)) {
              throw defaultReaderBrandCheckException("releaseLock");
            }
            if (this._ownerReadableStream === void 0) {
              return;
            }
            ReadableStreamDefaultReaderRelease(this);
          };
          return ReadableStreamDefaultReader2;
        }()
      );
      Object.defineProperties(ReadableStreamDefaultReader.prototype, {
        cancel: { enumerable: true },
        read: { enumerable: true },
        releaseLock: { enumerable: true },
        closed: { enumerable: true }
      });
      setFunctionName(ReadableStreamDefaultReader.prototype.cancel, "cancel");
      setFunctionName(ReadableStreamDefaultReader.prototype.read, "read");
      setFunctionName(ReadableStreamDefaultReader.prototype.releaseLock, "releaseLock");
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(ReadableStreamDefaultReader.prototype, SymbolPolyfill.toStringTag, {
          value: "ReadableStreamDefaultReader",
          configurable: true
        });
      }
      function IsReadableStreamDefaultReader(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_readRequests")) {
          return false;
        }
        return x instanceof ReadableStreamDefaultReader;
      }
      function ReadableStreamDefaultReaderRead(reader, readRequest) {
        var stream = reader._ownerReadableStream;
        stream._disturbed = true;
        if (stream._state === "closed") {
          readRequest._closeSteps();
        } else if (stream._state === "errored") {
          readRequest._errorSteps(stream._storedError);
        } else {
          stream._readableStreamController[PullSteps](readRequest);
        }
      }
      function ReadableStreamDefaultReaderRelease(reader) {
        ReadableStreamReaderGenericRelease(reader);
        var e = new TypeError("Reader was released");
        ReadableStreamDefaultReaderErrorReadRequests(reader, e);
      }
      function ReadableStreamDefaultReaderErrorReadRequests(reader, e) {
        var readRequests = reader._readRequests;
        reader._readRequests = new SimpleQueue();
        readRequests.forEach(function(readRequest) {
          readRequest._errorSteps(e);
        });
      }
      function defaultReaderBrandCheckException(name) {
        return new TypeError("ReadableStreamDefaultReader.prototype.".concat(name, " can only be used on a ReadableStreamDefaultReader"));
      }
      var _a$1, _b, _c;
      function CreateArrayFromList(elements) {
        return elements.slice();
      }
      function CopyDataBlockBytes(dest, destOffset, src, srcOffset, n) {
        new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);
      }
      var TransferArrayBuffer = function(O) {
        if (typeof O.transfer === "function") {
          TransferArrayBuffer = function(buffer) {
            return buffer.transfer();
          };
        } else if (typeof structuredClone === "function") {
          TransferArrayBuffer = function(buffer) {
            return structuredClone(buffer, { transfer: [buffer] });
          };
        } else {
          TransferArrayBuffer = function(buffer) {
            return buffer;
          };
        }
        return TransferArrayBuffer(O);
      };
      var IsDetachedBuffer = function(O) {
        if (typeof O.detached === "boolean") {
          IsDetachedBuffer = function(buffer) {
            return buffer.detached;
          };
        } else {
          IsDetachedBuffer = function(buffer) {
            return buffer.byteLength === 0;
          };
        }
        return IsDetachedBuffer(O);
      };
      function ArrayBufferSlice(buffer, begin, end) {
        if (buffer.slice) {
          return buffer.slice(begin, end);
        }
        var length = end - begin;
        var slice = new ArrayBuffer(length);
        CopyDataBlockBytes(slice, 0, buffer, begin, length);
        return slice;
      }
      function GetMethod(receiver, prop) {
        var func = receiver[prop];
        if (func === void 0 || func === null) {
          return void 0;
        }
        if (typeof func !== "function") {
          throw new TypeError("".concat(String(prop), " is not a function"));
        }
        return func;
      }
      function CreateAsyncFromSyncIterator(syncIteratorRecord) {
        var _a2;
        var syncIterable = (_a2 = {}, _a2[SymbolPolyfill.iterator] = function() {
          return syncIteratorRecord.iterator;
        }, _a2);
        var asyncIterator = function() {
          return __asyncGenerator(this, arguments, function() {
            return __generator(this, function(_a3) {
              switch (_a3.label) {
                case 0:
                  return [5, __values(__asyncDelegator(__asyncValues(syncIterable)))];
                case 1:
                  return [4, __await.apply(void 0, [_a3.sent()])];
                case 2:
                  return [4, __await.apply(void 0, [_a3.sent()])];
                case 3:
                  return [2, _a3.sent()];
              }
            });
          });
        }();
        var nextMethod = asyncIterator.next;
        return { iterator: asyncIterator, nextMethod, done: false };
      }
      var SymbolAsyncIterator = (_c = (_a$1 = SymbolPolyfill.asyncIterator) !== null && _a$1 !== void 0 ? _a$1 : (_b = SymbolPolyfill.for) === null || _b === void 0 ? void 0 : _b.call(SymbolPolyfill, "Symbol.asyncIterator")) !== null && _c !== void 0 ? _c : "@@asyncIterator";
      function GetIterator(obj, hint, method) {
        if (hint === void 0) {
          hint = "sync";
        }
        if (method === void 0) {
          if (hint === "async") {
            method = GetMethod(obj, SymbolAsyncIterator);
            if (method === void 0) {
              var syncMethod = GetMethod(obj, SymbolPolyfill.iterator);
              var syncIteratorRecord = GetIterator(obj, "sync", syncMethod);
              return CreateAsyncFromSyncIterator(syncIteratorRecord);
            }
          } else {
            method = GetMethod(obj, SymbolPolyfill.iterator);
          }
        }
        if (method === void 0) {
          throw new TypeError("The object is not iterable");
        }
        var iterator = reflectCall(method, obj, []);
        if (!typeIsObject(iterator)) {
          throw new TypeError("The iterator method must return an object");
        }
        var nextMethod = iterator.next;
        return { iterator, nextMethod, done: false };
      }
      function IteratorNext(iteratorRecord) {
        var result = reflectCall(iteratorRecord.nextMethod, iteratorRecord.iterator, []);
        if (!typeIsObject(result)) {
          throw new TypeError("The iterator.next() method must return an object");
        }
        return result;
      }
      function IteratorComplete(iterResult) {
        return Boolean(iterResult.done);
      }
      function IteratorValue(iterResult) {
        return iterResult.value;
      }
      var _a;
      var AsyncIteratorPrototype = (_a = {}, // 25.1.3.1 %AsyncIteratorPrototype% [ @@asyncIterator ] ( )
      // https://tc39.github.io/ecma262/#sec-asynciteratorprototype-asynciterator
      _a[SymbolAsyncIterator] = function() {
        return this;
      }, _a);
      Object.defineProperty(AsyncIteratorPrototype, SymbolAsyncIterator, { enumerable: false });
      var ReadableStreamAsyncIteratorImpl = (
        /** @class */
        function() {
          function ReadableStreamAsyncIteratorImpl2(reader, preventCancel) {
            this._ongoingPromise = void 0;
            this._isFinished = false;
            this._reader = reader;
            this._preventCancel = preventCancel;
          }
          ReadableStreamAsyncIteratorImpl2.prototype.next = function() {
            var _this = this;
            var nextSteps = function() {
              return _this._nextSteps();
            };
            this._ongoingPromise = this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, nextSteps, nextSteps) : nextSteps();
            return this._ongoingPromise;
          };
          ReadableStreamAsyncIteratorImpl2.prototype.return = function(value) {
            var _this = this;
            var returnSteps = function() {
              return _this._returnSteps(value);
            };
            return this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, returnSteps, returnSteps) : returnSteps();
          };
          ReadableStreamAsyncIteratorImpl2.prototype._nextSteps = function() {
            var _this = this;
            if (this._isFinished) {
              return Promise.resolve({ value: void 0, done: true });
            }
            var reader = this._reader;
            var resolvePromise;
            var rejectPromise;
            var promise = newPromise(function(resolve, reject) {
              resolvePromise = resolve;
              rejectPromise = reject;
            });
            var readRequest = {
              _chunkSteps: function(chunk) {
                _this._ongoingPromise = void 0;
                _queueMicrotask(function() {
                  return resolvePromise({ value: chunk, done: false });
                });
              },
              _closeSteps: function() {
                _this._ongoingPromise = void 0;
                _this._isFinished = true;
                ReadableStreamReaderGenericRelease(reader);
                resolvePromise({ value: void 0, done: true });
              },
              _errorSteps: function(reason) {
                _this._ongoingPromise = void 0;
                _this._isFinished = true;
                ReadableStreamReaderGenericRelease(reader);
                rejectPromise(reason);
              }
            };
            ReadableStreamDefaultReaderRead(reader, readRequest);
            return promise;
          };
          ReadableStreamAsyncIteratorImpl2.prototype._returnSteps = function(value) {
            if (this._isFinished) {
              return Promise.resolve({ value, done: true });
            }
            this._isFinished = true;
            var reader = this._reader;
            if (!this._preventCancel) {
              var result = ReadableStreamReaderGenericCancel(reader, value);
              ReadableStreamReaderGenericRelease(reader);
              return transformPromiseWith(result, function() {
                return { value, done: true };
              });
            }
            ReadableStreamReaderGenericRelease(reader);
            return promiseResolvedWith({ value, done: true });
          };
          return ReadableStreamAsyncIteratorImpl2;
        }()
      );
      var ReadableStreamAsyncIteratorPrototype = {
        next: function() {
          if (!IsReadableStreamAsyncIterator(this)) {
            return promiseRejectedWith(streamAsyncIteratorBrandCheckException("next"));
          }
          return this._asyncIteratorImpl.next();
        },
        return: function(value) {
          if (!IsReadableStreamAsyncIterator(this)) {
            return promiseRejectedWith(streamAsyncIteratorBrandCheckException("return"));
          }
          return this._asyncIteratorImpl.return(value);
        }
      };
      Object.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);
      function AcquireReadableStreamAsyncIterator(stream, preventCancel) {
        var reader = AcquireReadableStreamDefaultReader(stream);
        var impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel);
        var iterator = Object.create(ReadableStreamAsyncIteratorPrototype);
        iterator._asyncIteratorImpl = impl;
        return iterator;
      }
      function IsReadableStreamAsyncIterator(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_asyncIteratorImpl")) {
          return false;
        }
        try {
          return x._asyncIteratorImpl instanceof ReadableStreamAsyncIteratorImpl;
        } catch (_a2) {
          return false;
        }
      }
      function streamAsyncIteratorBrandCheckException(name) {
        return new TypeError("ReadableStreamAsyncIterator.".concat(name, " can only be used on a ReadableSteamAsyncIterator"));
      }
      var NumberIsNaN = Number.isNaN || function(x) {
        return x !== x;
      };
      function IsNonNegativeNumber(v) {
        if (typeof v !== "number") {
          return false;
        }
        if (NumberIsNaN(v)) {
          return false;
        }
        if (v < 0) {
          return false;
        }
        return true;
      }
      function CloneAsUint8Array(O) {
        var buffer = ArrayBufferSlice(O.buffer, O.byteOffset, O.byteOffset + O.byteLength);
        return new Uint8Array(buffer);
      }
      function DequeueValue(container) {
        var pair = container._queue.shift();
        container._queueTotalSize -= pair.size;
        if (container._queueTotalSize < 0) {
          container._queueTotalSize = 0;
        }
        return pair.value;
      }
      function EnqueueValueWithSize(container, value, size) {
        if (!IsNonNegativeNumber(size) || size === Infinity) {
          throw new RangeError("Size must be a finite, non-NaN, non-negative number.");
        }
        container._queue.push({ value, size });
        container._queueTotalSize += size;
      }
      function PeekQueueValue(container) {
        var pair = container._queue.peek();
        return pair.value;
      }
      function ResetQueue(container) {
        container._queue = new SimpleQueue();
        container._queueTotalSize = 0;
      }
      function isDataViewConstructor(ctor) {
        return ctor === DataView;
      }
      function isDataView(view) {
        return isDataViewConstructor(view.constructor);
      }
      function arrayBufferViewElementSize(ctor) {
        if (isDataViewConstructor(ctor)) {
          return 1;
        }
        return ctor.BYTES_PER_ELEMENT;
      }
      var ReadableStreamBYOBRequest = (
        /** @class */
        function() {
          function ReadableStreamBYOBRequest2() {
            throw new TypeError("Illegal constructor");
          }
          Object.defineProperty(ReadableStreamBYOBRequest2.prototype, "view", {
            /**
             * Returns the view for writing in to, or `null` if the BYOB request has already been responded to.
             */
            get: function() {
              if (!IsReadableStreamBYOBRequest(this)) {
                throw byobRequestBrandCheckException("view");
              }
              return this._view;
            },
            enumerable: false,
            configurable: true
          });
          ReadableStreamBYOBRequest2.prototype.respond = function(bytesWritten) {
            if (!IsReadableStreamBYOBRequest(this)) {
              throw byobRequestBrandCheckException("respond");
            }
            assertRequiredArgument(bytesWritten, 1, "respond");
            bytesWritten = convertUnsignedLongLongWithEnforceRange(bytesWritten, "First parameter");
            if (this._associatedReadableByteStreamController === void 0) {
              throw new TypeError("This BYOB request has been invalidated");
            }
            if (IsDetachedBuffer(this._view.buffer)) {
              throw new TypeError("The BYOB request's buffer has been detached and so cannot be used as a response");
            }
            ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);
          };
          ReadableStreamBYOBRequest2.prototype.respondWithNewView = function(view) {
            if (!IsReadableStreamBYOBRequest(this)) {
              throw byobRequestBrandCheckException("respondWithNewView");
            }
            assertRequiredArgument(view, 1, "respondWithNewView");
            if (!ArrayBuffer.isView(view)) {
              throw new TypeError("You can only respond with array buffer views");
            }
            if (this._associatedReadableByteStreamController === void 0) {
              throw new TypeError("This BYOB request has been invalidated");
            }
            if (IsDetachedBuffer(view.buffer)) {
              throw new TypeError("The given view's buffer has been detached and so cannot be used as a response");
            }
            ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);
          };
          return ReadableStreamBYOBRequest2;
        }()
      );
      Object.defineProperties(ReadableStreamBYOBRequest.prototype, {
        respond: { enumerable: true },
        respondWithNewView: { enumerable: true },
        view: { enumerable: true }
      });
      setFunctionName(ReadableStreamBYOBRequest.prototype.respond, "respond");
      setFunctionName(ReadableStreamBYOBRequest.prototype.respondWithNewView, "respondWithNewView");
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(ReadableStreamBYOBRequest.prototype, SymbolPolyfill.toStringTag, {
          value: "ReadableStreamBYOBRequest",
          configurable: true
        });
      }
      var ReadableByteStreamController = (
        /** @class */
        function() {
          function ReadableByteStreamController2() {
            throw new TypeError("Illegal constructor");
          }
          Object.defineProperty(ReadableByteStreamController2.prototype, "byobRequest", {
            /**
             * Returns the current BYOB pull request, or `null` if there isn't one.
             */
            get: function() {
              if (!IsReadableByteStreamController(this)) {
                throw byteStreamControllerBrandCheckException("byobRequest");
              }
              return ReadableByteStreamControllerGetBYOBRequest(this);
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(ReadableByteStreamController2.prototype, "desiredSize", {
            /**
             * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is
             * over-full. An underlying byte source ought to use this information to determine when and how to apply backpressure.
             */
            get: function() {
              if (!IsReadableByteStreamController(this)) {
                throw byteStreamControllerBrandCheckException("desiredSize");
              }
              return ReadableByteStreamControllerGetDesiredSize(this);
            },
            enumerable: false,
            configurable: true
          });
          ReadableByteStreamController2.prototype.close = function() {
            if (!IsReadableByteStreamController(this)) {
              throw byteStreamControllerBrandCheckException("close");
            }
            if (this._closeRequested) {
              throw new TypeError("The stream has already been closed; do not close it again!");
            }
            var state = this._controlledReadableByteStream._state;
            if (state !== "readable") {
              throw new TypeError("The stream (in ".concat(state, " state) is not in the readable state and cannot be closed"));
            }
            ReadableByteStreamControllerClose(this);
          };
          ReadableByteStreamController2.prototype.enqueue = function(chunk) {
            if (!IsReadableByteStreamController(this)) {
              throw byteStreamControllerBrandCheckException("enqueue");
            }
            assertRequiredArgument(chunk, 1, "enqueue");
            if (!ArrayBuffer.isView(chunk)) {
              throw new TypeError("chunk must be an array buffer view");
            }
            if (chunk.byteLength === 0) {
              throw new TypeError("chunk must have non-zero byteLength");
            }
            if (chunk.buffer.byteLength === 0) {
              throw new TypeError("chunk's buffer must have non-zero byteLength");
            }
            if (this._closeRequested) {
              throw new TypeError("stream is closed or draining");
            }
            var state = this._controlledReadableByteStream._state;
            if (state !== "readable") {
              throw new TypeError("The stream (in ".concat(state, " state) is not in the readable state and cannot be enqueued to"));
            }
            ReadableByteStreamControllerEnqueue(this, chunk);
          };
          ReadableByteStreamController2.prototype.error = function(e) {
            if (e === void 0) {
              e = void 0;
            }
            if (!IsReadableByteStreamController(this)) {
              throw byteStreamControllerBrandCheckException("error");
            }
            ReadableByteStreamControllerError(this, e);
          };
          ReadableByteStreamController2.prototype[CancelSteps] = function(reason) {
            ReadableByteStreamControllerClearPendingPullIntos(this);
            ResetQueue(this);
            var result = this._cancelAlgorithm(reason);
            ReadableByteStreamControllerClearAlgorithms(this);
            return result;
          };
          ReadableByteStreamController2.prototype[PullSteps] = function(readRequest) {
            var stream = this._controlledReadableByteStream;
            if (this._queueTotalSize > 0) {
              ReadableByteStreamControllerFillReadRequestFromQueue(this, readRequest);
              return;
            }
            var autoAllocateChunkSize = this._autoAllocateChunkSize;
            if (autoAllocateChunkSize !== void 0) {
              var buffer = void 0;
              try {
                buffer = new ArrayBuffer(autoAllocateChunkSize);
              } catch (bufferE) {
                readRequest._errorSteps(bufferE);
                return;
              }
              var pullIntoDescriptor = {
                buffer,
                bufferByteLength: autoAllocateChunkSize,
                byteOffset: 0,
                byteLength: autoAllocateChunkSize,
                bytesFilled: 0,
                minimumFill: 1,
                elementSize: 1,
                viewConstructor: Uint8Array,
                readerType: "default"
              };
              this._pendingPullIntos.push(pullIntoDescriptor);
            }
            ReadableStreamAddReadRequest(stream, readRequest);
            ReadableByteStreamControllerCallPullIfNeeded(this);
          };
          ReadableByteStreamController2.prototype[ReleaseSteps] = function() {
            if (this._pendingPullIntos.length > 0) {
              var firstPullInto = this._pendingPullIntos.peek();
              firstPullInto.readerType = "none";
              this._pendingPullIntos = new SimpleQueue();
              this._pendingPullIntos.push(firstPullInto);
            }
          };
          return ReadableByteStreamController2;
        }()
      );
      Object.defineProperties(ReadableByteStreamController.prototype, {
        close: { enumerable: true },
        enqueue: { enumerable: true },
        error: { enumerable: true },
        byobRequest: { enumerable: true },
        desiredSize: { enumerable: true }
      });
      setFunctionName(ReadableByteStreamController.prototype.close, "close");
      setFunctionName(ReadableByteStreamController.prototype.enqueue, "enqueue");
      setFunctionName(ReadableByteStreamController.prototype.error, "error");
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(ReadableByteStreamController.prototype, SymbolPolyfill.toStringTag, {
          value: "ReadableByteStreamController",
          configurable: true
        });
      }
      function IsReadableByteStreamController(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_controlledReadableByteStream")) {
          return false;
        }
        return x instanceof ReadableByteStreamController;
      }
      function IsReadableStreamBYOBRequest(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_associatedReadableByteStreamController")) {
          return false;
        }
        return x instanceof ReadableStreamBYOBRequest;
      }
      function ReadableByteStreamControllerCallPullIfNeeded(controller) {
        var shouldPull = ReadableByteStreamControllerShouldCallPull(controller);
        if (!shouldPull) {
          return;
        }
        if (controller._pulling) {
          controller._pullAgain = true;
          return;
        }
        controller._pulling = true;
        var pullPromise = controller._pullAlgorithm();
        uponPromise(pullPromise, function() {
          controller._pulling = false;
          if (controller._pullAgain) {
            controller._pullAgain = false;
            ReadableByteStreamControllerCallPullIfNeeded(controller);
          }
          return null;
        }, function(e) {
          ReadableByteStreamControllerError(controller, e);
          return null;
        });
      }
      function ReadableByteStreamControllerClearPendingPullIntos(controller) {
        ReadableByteStreamControllerInvalidateBYOBRequest(controller);
        controller._pendingPullIntos = new SimpleQueue();
      }
      function ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {
        var done = false;
        if (stream._state === "closed") {
          done = true;
        }
        var filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
        if (pullIntoDescriptor.readerType === "default") {
          ReadableStreamFulfillReadRequest(stream, filledView, done);
        } else {
          ReadableStreamFulfillReadIntoRequest(stream, filledView, done);
        }
      }
      function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {
        var bytesFilled = pullIntoDescriptor.bytesFilled;
        var elementSize = pullIntoDescriptor.elementSize;
        return new pullIntoDescriptor.viewConstructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);
      }
      function ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {
        controller._queue.push({ buffer, byteOffset, byteLength });
        controller._queueTotalSize += byteLength;
      }
      function ReadableByteStreamControllerEnqueueClonedChunkToQueue(controller, buffer, byteOffset, byteLength) {
        var clonedChunk;
        try {
          clonedChunk = ArrayBufferSlice(buffer, byteOffset, byteOffset + byteLength);
        } catch (cloneE) {
          ReadableByteStreamControllerError(controller, cloneE);
          throw cloneE;
        }
        ReadableByteStreamControllerEnqueueChunkToQueue(controller, clonedChunk, 0, byteLength);
      }
      function ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(controller, firstDescriptor) {
        if (firstDescriptor.bytesFilled > 0) {
          ReadableByteStreamControllerEnqueueClonedChunkToQueue(controller, firstDescriptor.buffer, firstDescriptor.byteOffset, firstDescriptor.bytesFilled);
        }
        ReadableByteStreamControllerShiftPendingPullInto(controller);
      }
      function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {
        var maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);
        var maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;
        var totalBytesToCopyRemaining = maxBytesToCopy;
        var ready = false;
        var remainderBytes = maxBytesFilled % pullIntoDescriptor.elementSize;
        var maxAlignedBytes = maxBytesFilled - remainderBytes;
        if (maxAlignedBytes >= pullIntoDescriptor.minimumFill) {
          totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;
          ready = true;
        }
        var queue = controller._queue;
        while (totalBytesToCopyRemaining > 0) {
          var headOfQueue = queue.peek();
          var bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);
          var destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
          CopyDataBlockBytes(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);
          if (headOfQueue.byteLength === bytesToCopy) {
            queue.shift();
          } else {
            headOfQueue.byteOffset += bytesToCopy;
            headOfQueue.byteLength -= bytesToCopy;
          }
          controller._queueTotalSize -= bytesToCopy;
          ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);
          totalBytesToCopyRemaining -= bytesToCopy;
        }
        return ready;
      }
      function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {
        pullIntoDescriptor.bytesFilled += size;
      }
      function ReadableByteStreamControllerHandleQueueDrain(controller) {
        if (controller._queueTotalSize === 0 && controller._closeRequested) {
          ReadableByteStreamControllerClearAlgorithms(controller);
          ReadableStreamClose(controller._controlledReadableByteStream);
        } else {
          ReadableByteStreamControllerCallPullIfNeeded(controller);
        }
      }
      function ReadableByteStreamControllerInvalidateBYOBRequest(controller) {
        if (controller._byobRequest === null) {
          return;
        }
        controller._byobRequest._associatedReadableByteStreamController = void 0;
        controller._byobRequest._view = null;
        controller._byobRequest = null;
      }
      function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {
        while (controller._pendingPullIntos.length > 0) {
          if (controller._queueTotalSize === 0) {
            return;
          }
          var pullIntoDescriptor = controller._pendingPullIntos.peek();
          if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
            ReadableByteStreamControllerShiftPendingPullInto(controller);
            ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
          }
        }
      }
      function ReadableByteStreamControllerProcessReadRequestsUsingQueue(controller) {
        var reader = controller._controlledReadableByteStream._reader;
        while (reader._readRequests.length > 0) {
          if (controller._queueTotalSize === 0) {
            return;
          }
          var readRequest = reader._readRequests.shift();
          ReadableByteStreamControllerFillReadRequestFromQueue(controller, readRequest);
        }
      }
      function ReadableByteStreamControllerPullInto(controller, view, min, readIntoRequest) {
        var stream = controller._controlledReadableByteStream;
        var ctor = view.constructor;
        var elementSize = arrayBufferViewElementSize(ctor);
        var byteOffset = view.byteOffset, byteLength = view.byteLength;
        var minimumFill = min * elementSize;
        var buffer;
        try {
          buffer = TransferArrayBuffer(view.buffer);
        } catch (e2) {
          readIntoRequest._errorSteps(e2);
          return;
        }
        var pullIntoDescriptor = {
          buffer,
          bufferByteLength: buffer.byteLength,
          byteOffset,
          byteLength,
          bytesFilled: 0,
          minimumFill,
          elementSize,
          viewConstructor: ctor,
          readerType: "byob"
        };
        if (controller._pendingPullIntos.length > 0) {
          controller._pendingPullIntos.push(pullIntoDescriptor);
          ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
          return;
        }
        if (stream._state === "closed") {
          var emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);
          readIntoRequest._closeSteps(emptyView);
          return;
        }
        if (controller._queueTotalSize > 0) {
          if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
            var filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
            ReadableByteStreamControllerHandleQueueDrain(controller);
            readIntoRequest._chunkSteps(filledView);
            return;
          }
          if (controller._closeRequested) {
            var e = new TypeError("Insufficient bytes to fill elements in the given buffer");
            ReadableByteStreamControllerError(controller, e);
            readIntoRequest._errorSteps(e);
            return;
          }
        }
        controller._pendingPullIntos.push(pullIntoDescriptor);
        ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
        ReadableByteStreamControllerCallPullIfNeeded(controller);
      }
      function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {
        if (firstDescriptor.readerType === "none") {
          ReadableByteStreamControllerShiftPendingPullInto(controller);
        }
        var stream = controller._controlledReadableByteStream;
        if (ReadableStreamHasBYOBReader(stream)) {
          while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {
            var pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);
            ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);
          }
        }
      }
      function ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {
        ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);
        if (pullIntoDescriptor.readerType === "none") {
          ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(controller, pullIntoDescriptor);
          ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
          return;
        }
        if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.minimumFill) {
          return;
        }
        ReadableByteStreamControllerShiftPendingPullInto(controller);
        var remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;
        if (remainderSize > 0) {
          var end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
          ReadableByteStreamControllerEnqueueClonedChunkToQueue(controller, pullIntoDescriptor.buffer, end - remainderSize, remainderSize);
        }
        pullIntoDescriptor.bytesFilled -= remainderSize;
        ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
        ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
      }
      function ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {
        var firstDescriptor = controller._pendingPullIntos.peek();
        ReadableByteStreamControllerInvalidateBYOBRequest(controller);
        var state = controller._controlledReadableByteStream._state;
        if (state === "closed") {
          ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor);
        } else {
          ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);
        }
        ReadableByteStreamControllerCallPullIfNeeded(controller);
      }
      function ReadableByteStreamControllerShiftPendingPullInto(controller) {
        var descriptor = controller._pendingPullIntos.shift();
        return descriptor;
      }
      function ReadableByteStreamControllerShouldCallPull(controller) {
        var stream = controller._controlledReadableByteStream;
        if (stream._state !== "readable") {
          return false;
        }
        if (controller._closeRequested) {
          return false;
        }
        if (!controller._started) {
          return false;
        }
        if (ReadableStreamHasDefaultReader(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
          return true;
        }
        if (ReadableStreamHasBYOBReader(stream) && ReadableStreamGetNumReadIntoRequests(stream) > 0) {
          return true;
        }
        var desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);
        if (desiredSize > 0) {
          return true;
        }
        return false;
      }
      function ReadableByteStreamControllerClearAlgorithms(controller) {
        controller._pullAlgorithm = void 0;
        controller._cancelAlgorithm = void 0;
      }
      function ReadableByteStreamControllerClose(controller) {
        var stream = controller._controlledReadableByteStream;
        if (controller._closeRequested || stream._state !== "readable") {
          return;
        }
        if (controller._queueTotalSize > 0) {
          controller._closeRequested = true;
          return;
        }
        if (controller._pendingPullIntos.length > 0) {
          var firstPendingPullInto = controller._pendingPullIntos.peek();
          if (firstPendingPullInto.bytesFilled % firstPendingPullInto.elementSize !== 0) {
            var e = new TypeError("Insufficient bytes to fill elements in the given buffer");
            ReadableByteStreamControllerError(controller, e);
            throw e;
          }
        }
        ReadableByteStreamControllerClearAlgorithms(controller);
        ReadableStreamClose(stream);
      }
      function ReadableByteStreamControllerEnqueue(controller, chunk) {
        var stream = controller._controlledReadableByteStream;
        if (controller._closeRequested || stream._state !== "readable") {
          return;
        }
        var buffer = chunk.buffer, byteOffset = chunk.byteOffset, byteLength = chunk.byteLength;
        if (IsDetachedBuffer(buffer)) {
          throw new TypeError("chunk's buffer is detached and so cannot be enqueued");
        }
        var transferredBuffer = TransferArrayBuffer(buffer);
        if (controller._pendingPullIntos.length > 0) {
          var firstPendingPullInto = controller._pendingPullIntos.peek();
          if (IsDetachedBuffer(firstPendingPullInto.buffer)) {
            throw new TypeError("The BYOB request's buffer has been detached and so cannot be filled with an enqueued chunk");
          }
          ReadableByteStreamControllerInvalidateBYOBRequest(controller);
          firstPendingPullInto.buffer = TransferArrayBuffer(firstPendingPullInto.buffer);
          if (firstPendingPullInto.readerType === "none") {
            ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(controller, firstPendingPullInto);
          }
        }
        if (ReadableStreamHasDefaultReader(stream)) {
          ReadableByteStreamControllerProcessReadRequestsUsingQueue(controller);
          if (ReadableStreamGetNumReadRequests(stream) === 0) {
            ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
          } else {
            if (controller._pendingPullIntos.length > 0) {
              ReadableByteStreamControllerShiftPendingPullInto(controller);
            }
            var transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);
            ReadableStreamFulfillReadRequest(stream, transferredView, false);
          }
        } else if (ReadableStreamHasBYOBReader(stream)) {
          ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
          ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
        } else {
          ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
        }
        ReadableByteStreamControllerCallPullIfNeeded(controller);
      }
      function ReadableByteStreamControllerError(controller, e) {
        var stream = controller._controlledReadableByteStream;
        if (stream._state !== "readable") {
          return;
        }
        ReadableByteStreamControllerClearPendingPullIntos(controller);
        ResetQueue(controller);
        ReadableByteStreamControllerClearAlgorithms(controller);
        ReadableStreamError(stream, e);
      }
      function ReadableByteStreamControllerFillReadRequestFromQueue(controller, readRequest) {
        var entry = controller._queue.shift();
        controller._queueTotalSize -= entry.byteLength;
        ReadableByteStreamControllerHandleQueueDrain(controller);
        var view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);
        readRequest._chunkSteps(view);
      }
      function ReadableByteStreamControllerGetBYOBRequest(controller) {
        if (controller._byobRequest === null && controller._pendingPullIntos.length > 0) {
          var firstDescriptor = controller._pendingPullIntos.peek();
          var view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled);
          var byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);
          SetUpReadableStreamBYOBRequest(byobRequest, controller, view);
          controller._byobRequest = byobRequest;
        }
        return controller._byobRequest;
      }
      function ReadableByteStreamControllerGetDesiredSize(controller) {
        var state = controller._controlledReadableByteStream._state;
        if (state === "errored") {
          return null;
        }
        if (state === "closed") {
          return 0;
        }
        return controller._strategyHWM - controller._queueTotalSize;
      }
      function ReadableByteStreamControllerRespond(controller, bytesWritten) {
        var firstDescriptor = controller._pendingPullIntos.peek();
        var state = controller._controlledReadableByteStream._state;
        if (state === "closed") {
          if (bytesWritten !== 0) {
            throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream");
          }
        } else {
          if (bytesWritten === 0) {
            throw new TypeError("bytesWritten must be greater than 0 when calling respond() on a readable stream");
          }
          if (firstDescriptor.bytesFilled + bytesWritten > firstDescriptor.byteLength) {
            throw new RangeError("bytesWritten out of range");
          }
        }
        firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);
        ReadableByteStreamControllerRespondInternal(controller, bytesWritten);
      }
      function ReadableByteStreamControllerRespondWithNewView(controller, view) {
        var firstDescriptor = controller._pendingPullIntos.peek();
        var state = controller._controlledReadableByteStream._state;
        if (state === "closed") {
          if (view.byteLength !== 0) {
            throw new TypeError("The view's length must be 0 when calling respondWithNewView() on a closed stream");
          }
        } else {
          if (view.byteLength === 0) {
            throw new TypeError("The view's length must be greater than 0 when calling respondWithNewView() on a readable stream");
          }
        }
        if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {
          throw new RangeError("The region specified by view does not match byobRequest");
        }
        if (firstDescriptor.bufferByteLength !== view.buffer.byteLength) {
          throw new RangeError("The buffer of view has different capacity than byobRequest");
        }
        if (firstDescriptor.bytesFilled + view.byteLength > firstDescriptor.byteLength) {
          throw new RangeError("The region specified by view is larger than byobRequest");
        }
        var viewByteLength = view.byteLength;
        firstDescriptor.buffer = TransferArrayBuffer(view.buffer);
        ReadableByteStreamControllerRespondInternal(controller, viewByteLength);
      }
      function SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {
        controller._controlledReadableByteStream = stream;
        controller._pullAgain = false;
        controller._pulling = false;
        controller._byobRequest = null;
        controller._queue = controller._queueTotalSize = void 0;
        ResetQueue(controller);
        controller._closeRequested = false;
        controller._started = false;
        controller._strategyHWM = highWaterMark;
        controller._pullAlgorithm = pullAlgorithm;
        controller._cancelAlgorithm = cancelAlgorithm;
        controller._autoAllocateChunkSize = autoAllocateChunkSize;
        controller._pendingPullIntos = new SimpleQueue();
        stream._readableStreamController = controller;
        var startResult = startAlgorithm();
        uponPromise(promiseResolvedWith(startResult), function() {
          controller._started = true;
          ReadableByteStreamControllerCallPullIfNeeded(controller);
          return null;
        }, function(r2) {
          ReadableByteStreamControllerError(controller, r2);
          return null;
        });
      }
      function SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {
        var controller = Object.create(ReadableByteStreamController.prototype);
        var startAlgorithm;
        var pullAlgorithm;
        var cancelAlgorithm;
        if (underlyingByteSource.start !== void 0) {
          startAlgorithm = function() {
            return underlyingByteSource.start(controller);
          };
        } else {
          startAlgorithm = function() {
            return void 0;
          };
        }
        if (underlyingByteSource.pull !== void 0) {
          pullAlgorithm = function() {
            return underlyingByteSource.pull(controller);
          };
        } else {
          pullAlgorithm = function() {
            return promiseResolvedWith(void 0);
          };
        }
        if (underlyingByteSource.cancel !== void 0) {
          cancelAlgorithm = function(reason) {
            return underlyingByteSource.cancel(reason);
          };
        } else {
          cancelAlgorithm = function() {
            return promiseResolvedWith(void 0);
          };
        }
        var autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;
        if (autoAllocateChunkSize === 0) {
          throw new TypeError("autoAllocateChunkSize must be greater than 0");
        }
        SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);
      }
      function SetUpReadableStreamBYOBRequest(request, controller, view) {
        request._associatedReadableByteStreamController = controller;
        request._view = view;
      }
      function byobRequestBrandCheckException(name) {
        return new TypeError("ReadableStreamBYOBRequest.prototype.".concat(name, " can only be used on a ReadableStreamBYOBRequest"));
      }
      function byteStreamControllerBrandCheckException(name) {
        return new TypeError("ReadableByteStreamController.prototype.".concat(name, " can only be used on a ReadableByteStreamController"));
      }
      function convertReaderOptions(options, context) {
        assertDictionary(options, context);
        var mode = options === null || options === void 0 ? void 0 : options.mode;
        return {
          mode: mode === void 0 ? void 0 : convertReadableStreamReaderMode(mode, "".concat(context, " has member 'mode' that"))
        };
      }
      function convertReadableStreamReaderMode(mode, context) {
        mode = "".concat(mode);
        if (mode !== "byob") {
          throw new TypeError("".concat(context, " '").concat(mode, "' is not a valid enumeration value for ReadableStreamReaderMode"));
        }
        return mode;
      }
      function convertByobReadOptions(options, context) {
        var _a2;
        assertDictionary(options, context);
        var min = (_a2 = options === null || options === void 0 ? void 0 : options.min) !== null && _a2 !== void 0 ? _a2 : 1;
        return {
          min: convertUnsignedLongLongWithEnforceRange(min, "".concat(context, " has member 'min' that"))
        };
      }
      function AcquireReadableStreamBYOBReader(stream) {
        return new ReadableStreamBYOBReader(stream);
      }
      function ReadableStreamAddReadIntoRequest(stream, readIntoRequest) {
        stream._reader._readIntoRequests.push(readIntoRequest);
      }
      function ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {
        var reader = stream._reader;
        var readIntoRequest = reader._readIntoRequests.shift();
        if (done) {
          readIntoRequest._closeSteps(chunk);
        } else {
          readIntoRequest._chunkSteps(chunk);
        }
      }
      function ReadableStreamGetNumReadIntoRequests(stream) {
        return stream._reader._readIntoRequests.length;
      }
      function ReadableStreamHasBYOBReader(stream) {
        var reader = stream._reader;
        if (reader === void 0) {
          return false;
        }
        if (!IsReadableStreamBYOBReader(reader)) {
          return false;
        }
        return true;
      }
      var ReadableStreamBYOBReader = (
        /** @class */
        function() {
          function ReadableStreamBYOBReader2(stream) {
            assertRequiredArgument(stream, 1, "ReadableStreamBYOBReader");
            assertReadableStream(stream, "First parameter");
            if (IsReadableStreamLocked(stream)) {
              throw new TypeError("This stream has already been locked for exclusive reading by another reader");
            }
            if (!IsReadableByteStreamController(stream._readableStreamController)) {
              throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");
            }
            ReadableStreamReaderGenericInitialize(this, stream);
            this._readIntoRequests = new SimpleQueue();
          }
          Object.defineProperty(ReadableStreamBYOBReader2.prototype, "closed", {
            /**
             * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or
             * the reader's lock is released before the stream finishes closing.
             */
            get: function() {
              if (!IsReadableStreamBYOBReader(this)) {
                return promiseRejectedWith(byobReaderBrandCheckException("closed"));
              }
              return this._closedPromise;
            },
            enumerable: false,
            configurable: true
          });
          ReadableStreamBYOBReader2.prototype.cancel = function(reason) {
            if (reason === void 0) {
              reason = void 0;
            }
            if (!IsReadableStreamBYOBReader(this)) {
              return promiseRejectedWith(byobReaderBrandCheckException("cancel"));
            }
            if (this._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("cancel"));
            }
            return ReadableStreamReaderGenericCancel(this, reason);
          };
          ReadableStreamBYOBReader2.prototype.read = function(view, rawOptions) {
            if (rawOptions === void 0) {
              rawOptions = {};
            }
            if (!IsReadableStreamBYOBReader(this)) {
              return promiseRejectedWith(byobReaderBrandCheckException("read"));
            }
            if (!ArrayBuffer.isView(view)) {
              return promiseRejectedWith(new TypeError("view must be an array buffer view"));
            }
            if (view.byteLength === 0) {
              return promiseRejectedWith(new TypeError("view must have non-zero byteLength"));
            }
            if (view.buffer.byteLength === 0) {
              return promiseRejectedWith(new TypeError("view's buffer must have non-zero byteLength"));
            }
            if (IsDetachedBuffer(view.buffer)) {
              return promiseRejectedWith(new TypeError("view's buffer has been detached"));
            }
            var options;
            try {
              options = convertByobReadOptions(rawOptions, "options");
            } catch (e) {
              return promiseRejectedWith(e);
            }
            var min = options.min;
            if (min === 0) {
              return promiseRejectedWith(new TypeError("options.min must be greater than 0"));
            }
            if (!isDataView(view)) {
              if (min > view.length) {
                return promiseRejectedWith(new RangeError("options.min must be less than or equal to view's length"));
              }
            } else if (min > view.byteLength) {
              return promiseRejectedWith(new RangeError("options.min must be less than or equal to view's byteLength"));
            }
            if (this._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("read from"));
            }
            var resolvePromise;
            var rejectPromise;
            var promise = newPromise(function(resolve, reject) {
              resolvePromise = resolve;
              rejectPromise = reject;
            });
            var readIntoRequest = {
              _chunkSteps: function(chunk) {
                return resolvePromise({ value: chunk, done: false });
              },
              _closeSteps: function(chunk) {
                return resolvePromise({ value: chunk, done: true });
              },
              _errorSteps: function(e) {
                return rejectPromise(e);
              }
            };
            ReadableStreamBYOBReaderRead(this, view, min, readIntoRequest);
            return promise;
          };
          ReadableStreamBYOBReader2.prototype.releaseLock = function() {
            if (!IsReadableStreamBYOBReader(this)) {
              throw byobReaderBrandCheckException("releaseLock");
            }
            if (this._ownerReadableStream === void 0) {
              return;
            }
            ReadableStreamBYOBReaderRelease(this);
          };
          return ReadableStreamBYOBReader2;
        }()
      );
      Object.defineProperties(ReadableStreamBYOBReader.prototype, {
        cancel: { enumerable: true },
        read: { enumerable: true },
        releaseLock: { enumerable: true },
        closed: { enumerable: true }
      });
      setFunctionName(ReadableStreamBYOBReader.prototype.cancel, "cancel");
      setFunctionName(ReadableStreamBYOBReader.prototype.read, "read");
      setFunctionName(ReadableStreamBYOBReader.prototype.releaseLock, "releaseLock");
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(ReadableStreamBYOBReader.prototype, SymbolPolyfill.toStringTag, {
          value: "ReadableStreamBYOBReader",
          configurable: true
        });
      }
      function IsReadableStreamBYOBReader(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_readIntoRequests")) {
          return false;
        }
        return x instanceof ReadableStreamBYOBReader;
      }
      function ReadableStreamBYOBReaderRead(reader, view, min, readIntoRequest) {
        var stream = reader._ownerReadableStream;
        stream._disturbed = true;
        if (stream._state === "errored") {
          readIntoRequest._errorSteps(stream._storedError);
        } else {
          ReadableByteStreamControllerPullInto(stream._readableStreamController, view, min, readIntoRequest);
        }
      }
      function ReadableStreamBYOBReaderRelease(reader) {
        ReadableStreamReaderGenericRelease(reader);
        var e = new TypeError("Reader was released");
        ReadableStreamBYOBReaderErrorReadIntoRequests(reader, e);
      }
      function ReadableStreamBYOBReaderErrorReadIntoRequests(reader, e) {
        var readIntoRequests = reader._readIntoRequests;
        reader._readIntoRequests = new SimpleQueue();
        readIntoRequests.forEach(function(readIntoRequest) {
          readIntoRequest._errorSteps(e);
        });
      }
      function byobReaderBrandCheckException(name) {
        return new TypeError("ReadableStreamBYOBReader.prototype.".concat(name, " can only be used on a ReadableStreamBYOBReader"));
      }
      function ExtractHighWaterMark(strategy, defaultHWM) {
        var highWaterMark = strategy.highWaterMark;
        if (highWaterMark === void 0) {
          return defaultHWM;
        }
        if (NumberIsNaN(highWaterMark) || highWaterMark < 0) {
          throw new RangeError("Invalid highWaterMark");
        }
        return highWaterMark;
      }
      function ExtractSizeAlgorithm(strategy) {
        var size = strategy.size;
        if (!size) {
          return function() {
            return 1;
          };
        }
        return size;
      }
      function convertQueuingStrategy(init, context) {
        assertDictionary(init, context);
        var highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;
        var size = init === null || init === void 0 ? void 0 : init.size;
        return {
          highWaterMark: highWaterMark === void 0 ? void 0 : convertUnrestrictedDouble(highWaterMark),
          size: size === void 0 ? void 0 : convertQueuingStrategySize(size, "".concat(context, " has member 'size' that"))
        };
      }
      function convertQueuingStrategySize(fn, context) {
        assertFunction(fn, context);
        return function(chunk) {
          return convertUnrestrictedDouble(fn(chunk));
        };
      }
      function convertUnderlyingSink(original, context) {
        assertDictionary(original, context);
        var abort = original === null || original === void 0 ? void 0 : original.abort;
        var close = original === null || original === void 0 ? void 0 : original.close;
        var start = original === null || original === void 0 ? void 0 : original.start;
        var type = original === null || original === void 0 ? void 0 : original.type;
        var write = original === null || original === void 0 ? void 0 : original.write;
        return {
          abort: abort === void 0 ? void 0 : convertUnderlyingSinkAbortCallback(abort, original, "".concat(context, " has member 'abort' that")),
          close: close === void 0 ? void 0 : convertUnderlyingSinkCloseCallback(close, original, "".concat(context, " has member 'close' that")),
          start: start === void 0 ? void 0 : convertUnderlyingSinkStartCallback(start, original, "".concat(context, " has member 'start' that")),
          write: write === void 0 ? void 0 : convertUnderlyingSinkWriteCallback(write, original, "".concat(context, " has member 'write' that")),
          type
        };
      }
      function convertUnderlyingSinkAbortCallback(fn, original, context) {
        assertFunction(fn, context);
        return function(reason) {
          return promiseCall(fn, original, [reason]);
        };
      }
      function convertUnderlyingSinkCloseCallback(fn, original, context) {
        assertFunction(fn, context);
        return function() {
          return promiseCall(fn, original, []);
        };
      }
      function convertUnderlyingSinkStartCallback(fn, original, context) {
        assertFunction(fn, context);
        return function(controller) {
          return reflectCall(fn, original, [controller]);
        };
      }
      function convertUnderlyingSinkWriteCallback(fn, original, context) {
        assertFunction(fn, context);
        return function(chunk, controller) {
          return promiseCall(fn, original, [chunk, controller]);
        };
      }
      function assertWritableStream(x, context) {
        if (!IsWritableStream(x)) {
          throw new TypeError("".concat(context, " is not a WritableStream."));
        }
      }
      function isAbortSignal(value) {
        if (typeof value !== "object" || value === null) {
          return false;
        }
        try {
          return typeof value.aborted === "boolean";
        } catch (_a2) {
          return false;
        }
      }
      var supportsAbortController = typeof AbortController === "function";
      function createAbortController() {
        if (supportsAbortController) {
          return new AbortController();
        }
        return void 0;
      }
      var WritableStream = (
        /** @class */
        function() {
          function WritableStream2(rawUnderlyingSink, rawStrategy) {
            if (rawUnderlyingSink === void 0) {
              rawUnderlyingSink = {};
            }
            if (rawStrategy === void 0) {
              rawStrategy = {};
            }
            if (rawUnderlyingSink === void 0) {
              rawUnderlyingSink = null;
            } else {
              assertObject(rawUnderlyingSink, "First parameter");
            }
            var strategy = convertQueuingStrategy(rawStrategy, "Second parameter");
            var underlyingSink = convertUnderlyingSink(rawUnderlyingSink, "First parameter");
            InitializeWritableStream(this);
            var type = underlyingSink.type;
            if (type !== void 0) {
              throw new RangeError("Invalid type is specified");
            }
            var sizeAlgorithm = ExtractSizeAlgorithm(strategy);
            var highWaterMark = ExtractHighWaterMark(strategy, 1);
            SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);
          }
          Object.defineProperty(WritableStream2.prototype, "locked", {
            /**
             * Returns whether or not the writable stream is locked to a writer.
             */
            get: function() {
              if (!IsWritableStream(this)) {
                throw streamBrandCheckException$2("locked");
              }
              return IsWritableStreamLocked(this);
            },
            enumerable: false,
            configurable: true
          });
          WritableStream2.prototype.abort = function(reason) {
            if (reason === void 0) {
              reason = void 0;
            }
            if (!IsWritableStream(this)) {
              return promiseRejectedWith(streamBrandCheckException$2("abort"));
            }
            if (IsWritableStreamLocked(this)) {
              return promiseRejectedWith(new TypeError("Cannot abort a stream that already has a writer"));
            }
            return WritableStreamAbort(this, reason);
          };
          WritableStream2.prototype.close = function() {
            if (!IsWritableStream(this)) {
              return promiseRejectedWith(streamBrandCheckException$2("close"));
            }
            if (IsWritableStreamLocked(this)) {
              return promiseRejectedWith(new TypeError("Cannot close a stream that already has a writer"));
            }
            if (WritableStreamCloseQueuedOrInFlight(this)) {
              return promiseRejectedWith(new TypeError("Cannot close an already-closing stream"));
            }
            return WritableStreamClose(this);
          };
          WritableStream2.prototype.getWriter = function() {
            if (!IsWritableStream(this)) {
              throw streamBrandCheckException$2("getWriter");
            }
            return AcquireWritableStreamDefaultWriter(this);
          };
          return WritableStream2;
        }()
      );
      Object.defineProperties(WritableStream.prototype, {
        abort: { enumerable: true },
        close: { enumerable: true },
        getWriter: { enumerable: true },
        locked: { enumerable: true }
      });
      setFunctionName(WritableStream.prototype.abort, "abort");
      setFunctionName(WritableStream.prototype.close, "close");
      setFunctionName(WritableStream.prototype.getWriter, "getWriter");
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(WritableStream.prototype, SymbolPolyfill.toStringTag, {
          value: "WritableStream",
          configurable: true
        });
      }
      function AcquireWritableStreamDefaultWriter(stream) {
        return new WritableStreamDefaultWriter(stream);
      }
      function CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {
        if (highWaterMark === void 0) {
          highWaterMark = 1;
        }
        if (sizeAlgorithm === void 0) {
          sizeAlgorithm = function() {
            return 1;
          };
        }
        var stream = Object.create(WritableStream.prototype);
        InitializeWritableStream(stream);
        var controller = Object.create(WritableStreamDefaultController.prototype);
        SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
        return stream;
      }
      function InitializeWritableStream(stream) {
        stream._state = "writable";
        stream._storedError = void 0;
        stream._writer = void 0;
        stream._writableStreamController = void 0;
        stream._writeRequests = new SimpleQueue();
        stream._inFlightWriteRequest = void 0;
        stream._closeRequest = void 0;
        stream._inFlightCloseRequest = void 0;
        stream._pendingAbortRequest = void 0;
        stream._backpressure = false;
      }
      function IsWritableStream(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_writableStreamController")) {
          return false;
        }
        return x instanceof WritableStream;
      }
      function IsWritableStreamLocked(stream) {
        if (stream._writer === void 0) {
          return false;
        }
        return true;
      }
      function WritableStreamAbort(stream, reason) {
        var _a2;
        if (stream._state === "closed" || stream._state === "errored") {
          return promiseResolvedWith(void 0);
        }
        stream._writableStreamController._abortReason = reason;
        (_a2 = stream._writableStreamController._abortController) === null || _a2 === void 0 ? void 0 : _a2.abort(reason);
        var state = stream._state;
        if (state === "closed" || state === "errored") {
          return promiseResolvedWith(void 0);
        }
        if (stream._pendingAbortRequest !== void 0) {
          return stream._pendingAbortRequest._promise;
        }
        var wasAlreadyErroring = false;
        if (state === "erroring") {
          wasAlreadyErroring = true;
          reason = void 0;
        }
        var promise = newPromise(function(resolve, reject) {
          stream._pendingAbortRequest = {
            _promise: void 0,
            _resolve: resolve,
            _reject: reject,
            _reason: reason,
            _wasAlreadyErroring: wasAlreadyErroring
          };
        });
        stream._pendingAbortRequest._promise = promise;
        if (!wasAlreadyErroring) {
          WritableStreamStartErroring(stream, reason);
        }
        return promise;
      }
      function WritableStreamClose(stream) {
        var state = stream._state;
        if (state === "closed" || state === "errored") {
          return promiseRejectedWith(new TypeError("The stream (in ".concat(state, " state) is not in the writable state and cannot be closed")));
        }
        var promise = newPromise(function(resolve, reject) {
          var closeRequest = {
            _resolve: resolve,
            _reject: reject
          };
          stream._closeRequest = closeRequest;
        });
        var writer = stream._writer;
        if (writer !== void 0 && stream._backpressure && state === "writable") {
          defaultWriterReadyPromiseResolve(writer);
        }
        WritableStreamDefaultControllerClose(stream._writableStreamController);
        return promise;
      }
      function WritableStreamAddWriteRequest(stream) {
        var promise = newPromise(function(resolve, reject) {
          var writeRequest = {
            _resolve: resolve,
            _reject: reject
          };
          stream._writeRequests.push(writeRequest);
        });
        return promise;
      }
      function WritableStreamDealWithRejection(stream, error) {
        var state = stream._state;
        if (state === "writable") {
          WritableStreamStartErroring(stream, error);
          return;
        }
        WritableStreamFinishErroring(stream);
      }
      function WritableStreamStartErroring(stream, reason) {
        var controller = stream._writableStreamController;
        stream._state = "erroring";
        stream._storedError = reason;
        var writer = stream._writer;
        if (writer !== void 0) {
          WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);
        }
        if (!WritableStreamHasOperationMarkedInFlight(stream) && controller._started) {
          WritableStreamFinishErroring(stream);
        }
      }
      function WritableStreamFinishErroring(stream) {
        stream._state = "errored";
        stream._writableStreamController[ErrorSteps]();
        var storedError = stream._storedError;
        stream._writeRequests.forEach(function(writeRequest) {
          writeRequest._reject(storedError);
        });
        stream._writeRequests = new SimpleQueue();
        if (stream._pendingAbortRequest === void 0) {
          WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
          return;
        }
        var abortRequest = stream._pendingAbortRequest;
        stream._pendingAbortRequest = void 0;
        if (abortRequest._wasAlreadyErroring) {
          abortRequest._reject(storedError);
          WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
          return;
        }
        var promise = stream._writableStreamController[AbortSteps](abortRequest._reason);
        uponPromise(promise, function() {
          abortRequest._resolve();
          WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
          return null;
        }, function(reason) {
          abortRequest._reject(reason);
          WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
          return null;
        });
      }
      function WritableStreamFinishInFlightWrite(stream) {
        stream._inFlightWriteRequest._resolve(void 0);
        stream._inFlightWriteRequest = void 0;
      }
      function WritableStreamFinishInFlightWriteWithError(stream, error) {
        stream._inFlightWriteRequest._reject(error);
        stream._inFlightWriteRequest = void 0;
        WritableStreamDealWithRejection(stream, error);
      }
      function WritableStreamFinishInFlightClose(stream) {
        stream._inFlightCloseRequest._resolve(void 0);
        stream._inFlightCloseRequest = void 0;
        var state = stream._state;
        if (state === "erroring") {
          stream._storedError = void 0;
          if (stream._pendingAbortRequest !== void 0) {
            stream._pendingAbortRequest._resolve();
            stream._pendingAbortRequest = void 0;
          }
        }
        stream._state = "closed";
        var writer = stream._writer;
        if (writer !== void 0) {
          defaultWriterClosedPromiseResolve(writer);
        }
      }
      function WritableStreamFinishInFlightCloseWithError(stream, error) {
        stream._inFlightCloseRequest._reject(error);
        stream._inFlightCloseRequest = void 0;
        if (stream._pendingAbortRequest !== void 0) {
          stream._pendingAbortRequest._reject(error);
          stream._pendingAbortRequest = void 0;
        }
        WritableStreamDealWithRejection(stream, error);
      }
      function WritableStreamCloseQueuedOrInFlight(stream) {
        if (stream._closeRequest === void 0 && stream._inFlightCloseRequest === void 0) {
          return false;
        }
        return true;
      }
      function WritableStreamHasOperationMarkedInFlight(stream) {
        if (stream._inFlightWriteRequest === void 0 && stream._inFlightCloseRequest === void 0) {
          return false;
        }
        return true;
      }
      function WritableStreamMarkCloseRequestInFlight(stream) {
        stream._inFlightCloseRequest = stream._closeRequest;
        stream._closeRequest = void 0;
      }
      function WritableStreamMarkFirstWriteRequestInFlight(stream) {
        stream._inFlightWriteRequest = stream._writeRequests.shift();
      }
      function WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {
        if (stream._closeRequest !== void 0) {
          stream._closeRequest._reject(stream._storedError);
          stream._closeRequest = void 0;
        }
        var writer = stream._writer;
        if (writer !== void 0) {
          defaultWriterClosedPromiseReject(writer, stream._storedError);
        }
      }
      function WritableStreamUpdateBackpressure(stream, backpressure) {
        var writer = stream._writer;
        if (writer !== void 0 && backpressure !== stream._backpressure) {
          if (backpressure) {
            defaultWriterReadyPromiseReset(writer);
          } else {
            defaultWriterReadyPromiseResolve(writer);
          }
        }
        stream._backpressure = backpressure;
      }
      var WritableStreamDefaultWriter = (
        /** @class */
        function() {
          function WritableStreamDefaultWriter2(stream) {
            assertRequiredArgument(stream, 1, "WritableStreamDefaultWriter");
            assertWritableStream(stream, "First parameter");
            if (IsWritableStreamLocked(stream)) {
              throw new TypeError("This stream has already been locked for exclusive writing by another writer");
            }
            this._ownerWritableStream = stream;
            stream._writer = this;
            var state = stream._state;
            if (state === "writable") {
              if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._backpressure) {
                defaultWriterReadyPromiseInitialize(this);
              } else {
                defaultWriterReadyPromiseInitializeAsResolved(this);
              }
              defaultWriterClosedPromiseInitialize(this);
            } else if (state === "erroring") {
              defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);
              defaultWriterClosedPromiseInitialize(this);
            } else if (state === "closed") {
              defaultWriterReadyPromiseInitializeAsResolved(this);
              defaultWriterClosedPromiseInitializeAsResolved(this);
            } else {
              var storedError = stream._storedError;
              defaultWriterReadyPromiseInitializeAsRejected(this, storedError);
              defaultWriterClosedPromiseInitializeAsRejected(this, storedError);
            }
          }
          Object.defineProperty(WritableStreamDefaultWriter2.prototype, "closed", {
            /**
             * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or
             * the writer’s lock is released before the stream finishes closing.
             */
            get: function() {
              if (!IsWritableStreamDefaultWriter(this)) {
                return promiseRejectedWith(defaultWriterBrandCheckException("closed"));
              }
              return this._closedPromise;
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(WritableStreamDefaultWriter2.prototype, "desiredSize", {
            /**
             * Returns the desired size to fill the stream’s internal queue. It can be negative, if the queue is over-full.
             * A producer can use this information to determine the right amount of data to write.
             *
             * It will be `null` if the stream cannot be successfully written to (due to either being errored, or having an abort
             * queued up). It will return zero if the stream is closed. And the getter will throw an exception if invoked when
             * the writer’s lock is released.
             */
            get: function() {
              if (!IsWritableStreamDefaultWriter(this)) {
                throw defaultWriterBrandCheckException("desiredSize");
              }
              if (this._ownerWritableStream === void 0) {
                throw defaultWriterLockException("desiredSize");
              }
              return WritableStreamDefaultWriterGetDesiredSize(this);
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(WritableStreamDefaultWriter2.prototype, "ready", {
            /**
             * Returns a promise that will be fulfilled when the desired size to fill the stream’s internal queue transitions
             * from non-positive to positive, signaling that it is no longer applying backpressure. Once the desired size dips
             * back to zero or below, the getter will return a new promise that stays pending until the next transition.
             *
             * If the stream becomes errored or aborted, or the writer’s lock is released, the returned promise will become
             * rejected.
             */
            get: function() {
              if (!IsWritableStreamDefaultWriter(this)) {
                return promiseRejectedWith(defaultWriterBrandCheckException("ready"));
              }
              return this._readyPromise;
            },
            enumerable: false,
            configurable: true
          });
          WritableStreamDefaultWriter2.prototype.abort = function(reason) {
            if (reason === void 0) {
              reason = void 0;
            }
            if (!IsWritableStreamDefaultWriter(this)) {
              return promiseRejectedWith(defaultWriterBrandCheckException("abort"));
            }
            if (this._ownerWritableStream === void 0) {
              return promiseRejectedWith(defaultWriterLockException("abort"));
            }
            return WritableStreamDefaultWriterAbort(this, reason);
          };
          WritableStreamDefaultWriter2.prototype.close = function() {
            if (!IsWritableStreamDefaultWriter(this)) {
              return promiseRejectedWith(defaultWriterBrandCheckException("close"));
            }
            var stream = this._ownerWritableStream;
            if (stream === void 0) {
              return promiseRejectedWith(defaultWriterLockException("close"));
            }
            if (WritableStreamCloseQueuedOrInFlight(stream)) {
              return promiseRejectedWith(new TypeError("Cannot close an already-closing stream"));
            }
            return WritableStreamDefaultWriterClose(this);
          };
          WritableStreamDefaultWriter2.prototype.releaseLock = function() {
            if (!IsWritableStreamDefaultWriter(this)) {
              throw defaultWriterBrandCheckException("releaseLock");
            }
            var stream = this._ownerWritableStream;
            if (stream === void 0) {
              return;
            }
            WritableStreamDefaultWriterRelease(this);
          };
          WritableStreamDefaultWriter2.prototype.write = function(chunk) {
            if (chunk === void 0) {
              chunk = void 0;
            }
            if (!IsWritableStreamDefaultWriter(this)) {
              return promiseRejectedWith(defaultWriterBrandCheckException("write"));
            }
            if (this._ownerWritableStream === void 0) {
              return promiseRejectedWith(defaultWriterLockException("write to"));
            }
            return WritableStreamDefaultWriterWrite(this, chunk);
          };
          return WritableStreamDefaultWriter2;
        }()
      );
      Object.defineProperties(WritableStreamDefaultWriter.prototype, {
        abort: { enumerable: true },
        close: { enumerable: true },
        releaseLock: { enumerable: true },
        write: { enumerable: true },
        closed: { enumerable: true },
        desiredSize: { enumerable: true },
        ready: { enumerable: true }
      });
      setFunctionName(WritableStreamDefaultWriter.prototype.abort, "abort");
      setFunctionName(WritableStreamDefaultWriter.prototype.close, "close");
      setFunctionName(WritableStreamDefaultWriter.prototype.releaseLock, "releaseLock");
      setFunctionName(WritableStreamDefaultWriter.prototype.write, "write");
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(WritableStreamDefaultWriter.prototype, SymbolPolyfill.toStringTag, {
          value: "WritableStreamDefaultWriter",
          configurable: true
        });
      }
      function IsWritableStreamDefaultWriter(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_ownerWritableStream")) {
          return false;
        }
        return x instanceof WritableStreamDefaultWriter;
      }
      function WritableStreamDefaultWriterAbort(writer, reason) {
        var stream = writer._ownerWritableStream;
        return WritableStreamAbort(stream, reason);
      }
      function WritableStreamDefaultWriterClose(writer) {
        var stream = writer._ownerWritableStream;
        return WritableStreamClose(stream);
      }
      function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {
        var stream = writer._ownerWritableStream;
        var state = stream._state;
        if (WritableStreamCloseQueuedOrInFlight(stream) || state === "closed") {
          return promiseResolvedWith(void 0);
        }
        if (state === "errored") {
          return promiseRejectedWith(stream._storedError);
        }
        return WritableStreamDefaultWriterClose(writer);
      }
      function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {
        if (writer._closedPromiseState === "pending") {
          defaultWriterClosedPromiseReject(writer, error);
        } else {
          defaultWriterClosedPromiseResetToRejected(writer, error);
        }
      }
      function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {
        if (writer._readyPromiseState === "pending") {
          defaultWriterReadyPromiseReject(writer, error);
        } else {
          defaultWriterReadyPromiseResetToRejected(writer, error);
        }
      }
      function WritableStreamDefaultWriterGetDesiredSize(writer) {
        var stream = writer._ownerWritableStream;
        var state = stream._state;
        if (state === "errored" || state === "erroring") {
          return null;
        }
        if (state === "closed") {
          return 0;
        }
        return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);
      }
      function WritableStreamDefaultWriterRelease(writer) {
        var stream = writer._ownerWritableStream;
        var releasedError = new TypeError("Writer was released and can no longer be used to monitor the stream's closedness");
        WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);
        WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);
        stream._writer = void 0;
        writer._ownerWritableStream = void 0;
      }
      function WritableStreamDefaultWriterWrite(writer, chunk) {
        var stream = writer._ownerWritableStream;
        var controller = stream._writableStreamController;
        var chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);
        if (stream !== writer._ownerWritableStream) {
          return promiseRejectedWith(defaultWriterLockException("write to"));
        }
        var state = stream._state;
        if (state === "errored") {
          return promiseRejectedWith(stream._storedError);
        }
        if (WritableStreamCloseQueuedOrInFlight(stream) || state === "closed") {
          return promiseRejectedWith(new TypeError("The stream is closing or closed and cannot be written to"));
        }
        if (state === "erroring") {
          return promiseRejectedWith(stream._storedError);
        }
        var promise = WritableStreamAddWriteRequest(stream);
        WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);
        return promise;
      }
      var closeSentinel = {};
      var WritableStreamDefaultController = (
        /** @class */
        function() {
          function WritableStreamDefaultController2() {
            throw new TypeError("Illegal constructor");
          }
          Object.defineProperty(WritableStreamDefaultController2.prototype, "abortReason", {
            /**
             * The reason which was passed to `WritableStream.abort(reason)` when the stream was aborted.
             *
             * @deprecated
             *  This property has been removed from the specification, see https://github.com/whatwg/streams/pull/1177.
             *  Use {@link WritableStreamDefaultController.signal}'s `reason` instead.
             */
            get: function() {
              if (!IsWritableStreamDefaultController(this)) {
                throw defaultControllerBrandCheckException$2("abortReason");
              }
              return this._abortReason;
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(WritableStreamDefaultController2.prototype, "signal", {
            /**
             * An `AbortSignal` that can be used to abort the pending write or close operation when the stream is aborted.
             */
            get: function() {
              if (!IsWritableStreamDefaultController(this)) {
                throw defaultControllerBrandCheckException$2("signal");
              }
              if (this._abortController === void 0) {
                throw new TypeError("WritableStreamDefaultController.prototype.signal is not supported");
              }
              return this._abortController.signal;
            },
            enumerable: false,
            configurable: true
          });
          WritableStreamDefaultController2.prototype.error = function(e) {
            if (e === void 0) {
              e = void 0;
            }
            if (!IsWritableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$2("error");
            }
            var state = this._controlledWritableStream._state;
            if (state !== "writable") {
              return;
            }
            WritableStreamDefaultControllerError(this, e);
          };
          WritableStreamDefaultController2.prototype[AbortSteps] = function(reason) {
            var result = this._abortAlgorithm(reason);
            WritableStreamDefaultControllerClearAlgorithms(this);
            return result;
          };
          WritableStreamDefaultController2.prototype[ErrorSteps] = function() {
            ResetQueue(this);
          };
          return WritableStreamDefaultController2;
        }()
      );
      Object.defineProperties(WritableStreamDefaultController.prototype, {
        abortReason: { enumerable: true },
        signal: { enumerable: true },
        error: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(WritableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
          value: "WritableStreamDefaultController",
          configurable: true
        });
      }
      function IsWritableStreamDefaultController(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_controlledWritableStream")) {
          return false;
        }
        return x instanceof WritableStreamDefaultController;
      }
      function SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {
        controller._controlledWritableStream = stream;
        stream._writableStreamController = controller;
        controller._queue = void 0;
        controller._queueTotalSize = void 0;
        ResetQueue(controller);
        controller._abortReason = void 0;
        controller._abortController = createAbortController();
        controller._started = false;
        controller._strategySizeAlgorithm = sizeAlgorithm;
        controller._strategyHWM = highWaterMark;
        controller._writeAlgorithm = writeAlgorithm;
        controller._closeAlgorithm = closeAlgorithm;
        controller._abortAlgorithm = abortAlgorithm;
        var backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
        WritableStreamUpdateBackpressure(stream, backpressure);
        var startResult = startAlgorithm();
        var startPromise = promiseResolvedWith(startResult);
        uponPromise(startPromise, function() {
          controller._started = true;
          WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
          return null;
        }, function(r2) {
          controller._started = true;
          WritableStreamDealWithRejection(stream, r2);
          return null;
        });
      }
      function SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {
        var controller = Object.create(WritableStreamDefaultController.prototype);
        var startAlgorithm;
        var writeAlgorithm;
        var closeAlgorithm;
        var abortAlgorithm;
        if (underlyingSink.start !== void 0) {
          startAlgorithm = function() {
            return underlyingSink.start(controller);
          };
        } else {
          startAlgorithm = function() {
            return void 0;
          };
        }
        if (underlyingSink.write !== void 0) {
          writeAlgorithm = function(chunk) {
            return underlyingSink.write(chunk, controller);
          };
        } else {
          writeAlgorithm = function() {
            return promiseResolvedWith(void 0);
          };
        }
        if (underlyingSink.close !== void 0) {
          closeAlgorithm = function() {
            return underlyingSink.close();
          };
        } else {
          closeAlgorithm = function() {
            return promiseResolvedWith(void 0);
          };
        }
        if (underlyingSink.abort !== void 0) {
          abortAlgorithm = function(reason) {
            return underlyingSink.abort(reason);
          };
        } else {
          abortAlgorithm = function() {
            return promiseResolvedWith(void 0);
          };
        }
        SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
      }
      function WritableStreamDefaultControllerClearAlgorithms(controller) {
        controller._writeAlgorithm = void 0;
        controller._closeAlgorithm = void 0;
        controller._abortAlgorithm = void 0;
        controller._strategySizeAlgorithm = void 0;
      }
      function WritableStreamDefaultControllerClose(controller) {
        EnqueueValueWithSize(controller, closeSentinel, 0);
        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
      }
      function WritableStreamDefaultControllerGetChunkSize(controller, chunk) {
        try {
          return controller._strategySizeAlgorithm(chunk);
        } catch (chunkSizeE) {
          WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);
          return 1;
        }
      }
      function WritableStreamDefaultControllerGetDesiredSize(controller) {
        return controller._strategyHWM - controller._queueTotalSize;
      }
      function WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {
        try {
          EnqueueValueWithSize(controller, chunk, chunkSize);
        } catch (enqueueE) {
          WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);
          return;
        }
        var stream = controller._controlledWritableStream;
        if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._state === "writable") {
          var backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
          WritableStreamUpdateBackpressure(stream, backpressure);
        }
        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
      }
      function WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {
        var stream = controller._controlledWritableStream;
        if (!controller._started) {
          return;
        }
        if (stream._inFlightWriteRequest !== void 0) {
          return;
        }
        var state = stream._state;
        if (state === "erroring") {
          WritableStreamFinishErroring(stream);
          return;
        }
        if (controller._queue.length === 0) {
          return;
        }
        var value = PeekQueueValue(controller);
        if (value === closeSentinel) {
          WritableStreamDefaultControllerProcessClose(controller);
        } else {
          WritableStreamDefaultControllerProcessWrite(controller, value);
        }
      }
      function WritableStreamDefaultControllerErrorIfNeeded(controller, error) {
        if (controller._controlledWritableStream._state === "writable") {
          WritableStreamDefaultControllerError(controller, error);
        }
      }
      function WritableStreamDefaultControllerProcessClose(controller) {
        var stream = controller._controlledWritableStream;
        WritableStreamMarkCloseRequestInFlight(stream);
        DequeueValue(controller);
        var sinkClosePromise = controller._closeAlgorithm();
        WritableStreamDefaultControllerClearAlgorithms(controller);
        uponPromise(sinkClosePromise, function() {
          WritableStreamFinishInFlightClose(stream);
          return null;
        }, function(reason) {
          WritableStreamFinishInFlightCloseWithError(stream, reason);
          return null;
        });
      }
      function WritableStreamDefaultControllerProcessWrite(controller, chunk) {
        var stream = controller._controlledWritableStream;
        WritableStreamMarkFirstWriteRequestInFlight(stream);
        var sinkWritePromise = controller._writeAlgorithm(chunk);
        uponPromise(sinkWritePromise, function() {
          WritableStreamFinishInFlightWrite(stream);
          var state = stream._state;
          DequeueValue(controller);
          if (!WritableStreamCloseQueuedOrInFlight(stream) && state === "writable") {
            var backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
            WritableStreamUpdateBackpressure(stream, backpressure);
          }
          WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
          return null;
        }, function(reason) {
          if (stream._state === "writable") {
            WritableStreamDefaultControllerClearAlgorithms(controller);
          }
          WritableStreamFinishInFlightWriteWithError(stream, reason);
          return null;
        });
      }
      function WritableStreamDefaultControllerGetBackpressure(controller) {
        var desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);
        return desiredSize <= 0;
      }
      function WritableStreamDefaultControllerError(controller, error) {
        var stream = controller._controlledWritableStream;
        WritableStreamDefaultControllerClearAlgorithms(controller);
        WritableStreamStartErroring(stream, error);
      }
      function streamBrandCheckException$2(name) {
        return new TypeError("WritableStream.prototype.".concat(name, " can only be used on a WritableStream"));
      }
      function defaultControllerBrandCheckException$2(name) {
        return new TypeError("WritableStreamDefaultController.prototype.".concat(name, " can only be used on a WritableStreamDefaultController"));
      }
      function defaultWriterBrandCheckException(name) {
        return new TypeError("WritableStreamDefaultWriter.prototype.".concat(name, " can only be used on a WritableStreamDefaultWriter"));
      }
      function defaultWriterLockException(name) {
        return new TypeError("Cannot " + name + " a stream using a released writer");
      }
      function defaultWriterClosedPromiseInitialize(writer) {
        writer._closedPromise = newPromise(function(resolve, reject) {
          writer._closedPromise_resolve = resolve;
          writer._closedPromise_reject = reject;
          writer._closedPromiseState = "pending";
        });
      }
      function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {
        defaultWriterClosedPromiseInitialize(writer);
        defaultWriterClosedPromiseReject(writer, reason);
      }
      function defaultWriterClosedPromiseInitializeAsResolved(writer) {
        defaultWriterClosedPromiseInitialize(writer);
        defaultWriterClosedPromiseResolve(writer);
      }
      function defaultWriterClosedPromiseReject(writer, reason) {
        if (writer._closedPromise_reject === void 0) {
          return;
        }
        setPromiseIsHandledToTrue(writer._closedPromise);
        writer._closedPromise_reject(reason);
        writer._closedPromise_resolve = void 0;
        writer._closedPromise_reject = void 0;
        writer._closedPromiseState = "rejected";
      }
      function defaultWriterClosedPromiseResetToRejected(writer, reason) {
        defaultWriterClosedPromiseInitializeAsRejected(writer, reason);
      }
      function defaultWriterClosedPromiseResolve(writer) {
        if (writer._closedPromise_resolve === void 0) {
          return;
        }
        writer._closedPromise_resolve(void 0);
        writer._closedPromise_resolve = void 0;
        writer._closedPromise_reject = void 0;
        writer._closedPromiseState = "resolved";
      }
      function defaultWriterReadyPromiseInitialize(writer) {
        writer._readyPromise = newPromise(function(resolve, reject) {
          writer._readyPromise_resolve = resolve;
          writer._readyPromise_reject = reject;
        });
        writer._readyPromiseState = "pending";
      }
      function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {
        defaultWriterReadyPromiseInitialize(writer);
        defaultWriterReadyPromiseReject(writer, reason);
      }
      function defaultWriterReadyPromiseInitializeAsResolved(writer) {
        defaultWriterReadyPromiseInitialize(writer);
        defaultWriterReadyPromiseResolve(writer);
      }
      function defaultWriterReadyPromiseReject(writer, reason) {
        if (writer._readyPromise_reject === void 0) {
          return;
        }
        setPromiseIsHandledToTrue(writer._readyPromise);
        writer._readyPromise_reject(reason);
        writer._readyPromise_resolve = void 0;
        writer._readyPromise_reject = void 0;
        writer._readyPromiseState = "rejected";
      }
      function defaultWriterReadyPromiseReset(writer) {
        defaultWriterReadyPromiseInitialize(writer);
      }
      function defaultWriterReadyPromiseResetToRejected(writer, reason) {
        defaultWriterReadyPromiseInitializeAsRejected(writer, reason);
      }
      function defaultWriterReadyPromiseResolve(writer) {
        if (writer._readyPromise_resolve === void 0) {
          return;
        }
        writer._readyPromise_resolve(void 0);
        writer._readyPromise_resolve = void 0;
        writer._readyPromise_reject = void 0;
        writer._readyPromiseState = "fulfilled";
      }
      function getGlobals() {
        if (typeof globalThis !== "undefined") {
          return globalThis;
        } else if (typeof self !== "undefined") {
          return self;
        } else if (typeof global !== "undefined") {
          return global;
        }
        return void 0;
      }
      var globals = getGlobals();
      function isDOMExceptionConstructor(ctor) {
        if (!(typeof ctor === "function" || typeof ctor === "object")) {
          return false;
        }
        if (ctor.name !== "DOMException") {
          return false;
        }
        try {
          new ctor();
          return true;
        } catch (_a2) {
          return false;
        }
      }
      function getFromGlobal() {
        var ctor = globals === null || globals === void 0 ? void 0 : globals.DOMException;
        return isDOMExceptionConstructor(ctor) ? ctor : void 0;
      }
      function createPolyfill() {
        var ctor = function DOMException2(message, name) {
          this.message = message || "";
          this.name = name || "Error";
          if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
          }
        };
        setFunctionName(ctor, "DOMException");
        ctor.prototype = Object.create(Error.prototype);
        Object.defineProperty(ctor.prototype, "constructor", { value: ctor, writable: true, configurable: true });
        return ctor;
      }
      var DOMException = getFromGlobal() || createPolyfill();
      function ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {
        var reader = AcquireReadableStreamDefaultReader(source);
        var writer = AcquireWritableStreamDefaultWriter(dest);
        source._disturbed = true;
        var shuttingDown = false;
        var currentWrite = promiseResolvedWith(void 0);
        return newPromise(function(resolve, reject) {
          var abortAlgorithm;
          if (signal !== void 0) {
            abortAlgorithm = function() {
              var error = signal.reason !== void 0 ? signal.reason : new DOMException("Aborted", "AbortError");
              var actions = [];
              if (!preventAbort) {
                actions.push(function() {
                  if (dest._state === "writable") {
                    return WritableStreamAbort(dest, error);
                  }
                  return promiseResolvedWith(void 0);
                });
              }
              if (!preventCancel) {
                actions.push(function() {
                  if (source._state === "readable") {
                    return ReadableStreamCancel(source, error);
                  }
                  return promiseResolvedWith(void 0);
                });
              }
              shutdownWithAction(function() {
                return Promise.all(actions.map(function(action) {
                  return action();
                }));
              }, true, error);
            };
            if (signal.aborted) {
              abortAlgorithm();
              return;
            }
            signal.addEventListener("abort", abortAlgorithm);
          }
          function pipeLoop() {
            return newPromise(function(resolveLoop, rejectLoop) {
              function next(done) {
                if (done) {
                  resolveLoop();
                } else {
                  PerformPromiseThen(pipeStep(), next, rejectLoop);
                }
              }
              next(false);
            });
          }
          function pipeStep() {
            if (shuttingDown) {
              return promiseResolvedWith(true);
            }
            return PerformPromiseThen(writer._readyPromise, function() {
              return newPromise(function(resolveRead, rejectRead) {
                ReadableStreamDefaultReaderRead(reader, {
                  _chunkSteps: function(chunk) {
                    currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), void 0, noop);
                    resolveRead(false);
                  },
                  _closeSteps: function() {
                    return resolveRead(true);
                  },
                  _errorSteps: rejectRead
                });
              });
            });
          }
          isOrBecomesErrored(source, reader._closedPromise, function(storedError) {
            if (!preventAbort) {
              shutdownWithAction(function() {
                return WritableStreamAbort(dest, storedError);
              }, true, storedError);
            } else {
              shutdown(true, storedError);
            }
            return null;
          });
          isOrBecomesErrored(dest, writer._closedPromise, function(storedError) {
            if (!preventCancel) {
              shutdownWithAction(function() {
                return ReadableStreamCancel(source, storedError);
              }, true, storedError);
            } else {
              shutdown(true, storedError);
            }
            return null;
          });
          isOrBecomesClosed(source, reader._closedPromise, function() {
            if (!preventClose) {
              shutdownWithAction(function() {
                return WritableStreamDefaultWriterCloseWithErrorPropagation(writer);
              });
            } else {
              shutdown();
            }
            return null;
          });
          if (WritableStreamCloseQueuedOrInFlight(dest) || dest._state === "closed") {
            var destClosed_1 = new TypeError("the destination writable stream closed before all data could be piped to it");
            if (!preventCancel) {
              shutdownWithAction(function() {
                return ReadableStreamCancel(source, destClosed_1);
              }, true, destClosed_1);
            } else {
              shutdown(true, destClosed_1);
            }
          }
          setPromiseIsHandledToTrue(pipeLoop());
          function waitForWritesToFinish() {
            var oldCurrentWrite = currentWrite;
            return PerformPromiseThen(currentWrite, function() {
              return oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : void 0;
            });
          }
          function isOrBecomesErrored(stream, promise, action) {
            if (stream._state === "errored") {
              action(stream._storedError);
            } else {
              uponRejection(promise, action);
            }
          }
          function isOrBecomesClosed(stream, promise, action) {
            if (stream._state === "closed") {
              action();
            } else {
              uponFulfillment(promise, action);
            }
          }
          function shutdownWithAction(action, originalIsError, originalError) {
            if (shuttingDown) {
              return;
            }
            shuttingDown = true;
            if (dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest)) {
              uponFulfillment(waitForWritesToFinish(), doTheRest);
            } else {
              doTheRest();
            }
            function doTheRest() {
              uponPromise(action(), function() {
                return finalize(originalIsError, originalError);
              }, function(newError) {
                return finalize(true, newError);
              });
              return null;
            }
          }
          function shutdown(isError, error) {
            if (shuttingDown) {
              return;
            }
            shuttingDown = true;
            if (dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest)) {
              uponFulfillment(waitForWritesToFinish(), function() {
                return finalize(isError, error);
              });
            } else {
              finalize(isError, error);
            }
          }
          function finalize(isError, error) {
            WritableStreamDefaultWriterRelease(writer);
            ReadableStreamReaderGenericRelease(reader);
            if (signal !== void 0) {
              signal.removeEventListener("abort", abortAlgorithm);
            }
            if (isError) {
              reject(error);
            } else {
              resolve(void 0);
            }
            return null;
          }
        });
      }
      var ReadableStreamDefaultController = (
        /** @class */
        function() {
          function ReadableStreamDefaultController2() {
            throw new TypeError("Illegal constructor");
          }
          Object.defineProperty(ReadableStreamDefaultController2.prototype, "desiredSize", {
            /**
             * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is
             * over-full. An underlying source ought to use this information to determine when and how to apply backpressure.
             */
            get: function() {
              if (!IsReadableStreamDefaultController(this)) {
                throw defaultControllerBrandCheckException$1("desiredSize");
              }
              return ReadableStreamDefaultControllerGetDesiredSize(this);
            },
            enumerable: false,
            configurable: true
          });
          ReadableStreamDefaultController2.prototype.close = function() {
            if (!IsReadableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$1("close");
            }
            if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
              throw new TypeError("The stream is not in a state that permits close");
            }
            ReadableStreamDefaultControllerClose(this);
          };
          ReadableStreamDefaultController2.prototype.enqueue = function(chunk) {
            if (chunk === void 0) {
              chunk = void 0;
            }
            if (!IsReadableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$1("enqueue");
            }
            if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
              throw new TypeError("The stream is not in a state that permits enqueue");
            }
            return ReadableStreamDefaultControllerEnqueue(this, chunk);
          };
          ReadableStreamDefaultController2.prototype.error = function(e) {
            if (e === void 0) {
              e = void 0;
            }
            if (!IsReadableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$1("error");
            }
            ReadableStreamDefaultControllerError(this, e);
          };
          ReadableStreamDefaultController2.prototype[CancelSteps] = function(reason) {
            ResetQueue(this);
            var result = this._cancelAlgorithm(reason);
            ReadableStreamDefaultControllerClearAlgorithms(this);
            return result;
          };
          ReadableStreamDefaultController2.prototype[PullSteps] = function(readRequest) {
            var stream = this._controlledReadableStream;
            if (this._queue.length > 0) {
              var chunk = DequeueValue(this);
              if (this._closeRequested && this._queue.length === 0) {
                ReadableStreamDefaultControllerClearAlgorithms(this);
                ReadableStreamClose(stream);
              } else {
                ReadableStreamDefaultControllerCallPullIfNeeded(this);
              }
              readRequest._chunkSteps(chunk);
            } else {
              ReadableStreamAddReadRequest(stream, readRequest);
              ReadableStreamDefaultControllerCallPullIfNeeded(this);
            }
          };
          ReadableStreamDefaultController2.prototype[ReleaseSteps] = function() {
          };
          return ReadableStreamDefaultController2;
        }()
      );
      Object.defineProperties(ReadableStreamDefaultController.prototype, {
        close: { enumerable: true },
        enqueue: { enumerable: true },
        error: { enumerable: true },
        desiredSize: { enumerable: true }
      });
      setFunctionName(ReadableStreamDefaultController.prototype.close, "close");
      setFunctionName(ReadableStreamDefaultController.prototype.enqueue, "enqueue");
      setFunctionName(ReadableStreamDefaultController.prototype.error, "error");
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(ReadableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
          value: "ReadableStreamDefaultController",
          configurable: true
        });
      }
      function IsReadableStreamDefaultController(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_controlledReadableStream")) {
          return false;
        }
        return x instanceof ReadableStreamDefaultController;
      }
      function ReadableStreamDefaultControllerCallPullIfNeeded(controller) {
        var shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);
        if (!shouldPull) {
          return;
        }
        if (controller._pulling) {
          controller._pullAgain = true;
          return;
        }
        controller._pulling = true;
        var pullPromise = controller._pullAlgorithm();
        uponPromise(pullPromise, function() {
          controller._pulling = false;
          if (controller._pullAgain) {
            controller._pullAgain = false;
            ReadableStreamDefaultControllerCallPullIfNeeded(controller);
          }
          return null;
        }, function(e) {
          ReadableStreamDefaultControllerError(controller, e);
          return null;
        });
      }
      function ReadableStreamDefaultControllerShouldCallPull(controller) {
        var stream = controller._controlledReadableStream;
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
          return false;
        }
        if (!controller._started) {
          return false;
        }
        if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
          return true;
        }
        var desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);
        if (desiredSize > 0) {
          return true;
        }
        return false;
      }
      function ReadableStreamDefaultControllerClearAlgorithms(controller) {
        controller._pullAlgorithm = void 0;
        controller._cancelAlgorithm = void 0;
        controller._strategySizeAlgorithm = void 0;
      }
      function ReadableStreamDefaultControllerClose(controller) {
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
          return;
        }
        var stream = controller._controlledReadableStream;
        controller._closeRequested = true;
        if (controller._queue.length === 0) {
          ReadableStreamDefaultControllerClearAlgorithms(controller);
          ReadableStreamClose(stream);
        }
      }
      function ReadableStreamDefaultControllerEnqueue(controller, chunk) {
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
          return;
        }
        var stream = controller._controlledReadableStream;
        if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
          ReadableStreamFulfillReadRequest(stream, chunk, false);
        } else {
          var chunkSize = void 0;
          try {
            chunkSize = controller._strategySizeAlgorithm(chunk);
          } catch (chunkSizeE) {
            ReadableStreamDefaultControllerError(controller, chunkSizeE);
            throw chunkSizeE;
          }
          try {
            EnqueueValueWithSize(controller, chunk, chunkSize);
          } catch (enqueueE) {
            ReadableStreamDefaultControllerError(controller, enqueueE);
            throw enqueueE;
          }
        }
        ReadableStreamDefaultControllerCallPullIfNeeded(controller);
      }
      function ReadableStreamDefaultControllerError(controller, e) {
        var stream = controller._controlledReadableStream;
        if (stream._state !== "readable") {
          return;
        }
        ResetQueue(controller);
        ReadableStreamDefaultControllerClearAlgorithms(controller);
        ReadableStreamError(stream, e);
      }
      function ReadableStreamDefaultControllerGetDesiredSize(controller) {
        var state = controller._controlledReadableStream._state;
        if (state === "errored") {
          return null;
        }
        if (state === "closed") {
          return 0;
        }
        return controller._strategyHWM - controller._queueTotalSize;
      }
      function ReadableStreamDefaultControllerHasBackpressure(controller) {
        if (ReadableStreamDefaultControllerShouldCallPull(controller)) {
          return false;
        }
        return true;
      }
      function ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {
        var state = controller._controlledReadableStream._state;
        if (!controller._closeRequested && state === "readable") {
          return true;
        }
        return false;
      }
      function SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {
        controller._controlledReadableStream = stream;
        controller._queue = void 0;
        controller._queueTotalSize = void 0;
        ResetQueue(controller);
        controller._started = false;
        controller._closeRequested = false;
        controller._pullAgain = false;
        controller._pulling = false;
        controller._strategySizeAlgorithm = sizeAlgorithm;
        controller._strategyHWM = highWaterMark;
        controller._pullAlgorithm = pullAlgorithm;
        controller._cancelAlgorithm = cancelAlgorithm;
        stream._readableStreamController = controller;
        var startResult = startAlgorithm();
        uponPromise(promiseResolvedWith(startResult), function() {
          controller._started = true;
          ReadableStreamDefaultControllerCallPullIfNeeded(controller);
          return null;
        }, function(r2) {
          ReadableStreamDefaultControllerError(controller, r2);
          return null;
        });
      }
      function SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark, sizeAlgorithm) {
        var controller = Object.create(ReadableStreamDefaultController.prototype);
        var startAlgorithm;
        var pullAlgorithm;
        var cancelAlgorithm;
        if (underlyingSource.start !== void 0) {
          startAlgorithm = function() {
            return underlyingSource.start(controller);
          };
        } else {
          startAlgorithm = function() {
            return void 0;
          };
        }
        if (underlyingSource.pull !== void 0) {
          pullAlgorithm = function() {
            return underlyingSource.pull(controller);
          };
        } else {
          pullAlgorithm = function() {
            return promiseResolvedWith(void 0);
          };
        }
        if (underlyingSource.cancel !== void 0) {
          cancelAlgorithm = function(reason) {
            return underlyingSource.cancel(reason);
          };
        } else {
          cancelAlgorithm = function() {
            return promiseResolvedWith(void 0);
          };
        }
        SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
      }
      function defaultControllerBrandCheckException$1(name) {
        return new TypeError("ReadableStreamDefaultController.prototype.".concat(name, " can only be used on a ReadableStreamDefaultController"));
      }
      function ReadableStreamTee(stream, cloneForBranch2) {
        if (IsReadableByteStreamController(stream._readableStreamController)) {
          return ReadableByteStreamTee(stream);
        }
        return ReadableStreamDefaultTee(stream);
      }
      function ReadableStreamDefaultTee(stream, cloneForBranch2) {
        var reader = AcquireReadableStreamDefaultReader(stream);
        var reading = false;
        var readAgain = false;
        var canceled1 = false;
        var canceled2 = false;
        var reason1;
        var reason2;
        var branch1;
        var branch2;
        var resolveCancelPromise;
        var cancelPromise = newPromise(function(resolve) {
          resolveCancelPromise = resolve;
        });
        function pullAlgorithm() {
          if (reading) {
            readAgain = true;
            return promiseResolvedWith(void 0);
          }
          reading = true;
          var readRequest = {
            _chunkSteps: function(chunk) {
              _queueMicrotask(function() {
                readAgain = false;
                var chunk1 = chunk;
                var chunk2 = chunk;
                if (!canceled1) {
                  ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, chunk1);
                }
                if (!canceled2) {
                  ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, chunk2);
                }
                reading = false;
                if (readAgain) {
                  pullAlgorithm();
                }
              });
            },
            _closeSteps: function() {
              reading = false;
              if (!canceled1) {
                ReadableStreamDefaultControllerClose(branch1._readableStreamController);
              }
              if (!canceled2) {
                ReadableStreamDefaultControllerClose(branch2._readableStreamController);
              }
              if (!canceled1 || !canceled2) {
                resolveCancelPromise(void 0);
              }
            },
            _errorSteps: function() {
              reading = false;
            }
          };
          ReadableStreamDefaultReaderRead(reader, readRequest);
          return promiseResolvedWith(void 0);
        }
        function cancel1Algorithm(reason) {
          canceled1 = true;
          reason1 = reason;
          if (canceled2) {
            var compositeReason = CreateArrayFromList([reason1, reason2]);
            var cancelResult = ReadableStreamCancel(stream, compositeReason);
            resolveCancelPromise(cancelResult);
          }
          return cancelPromise;
        }
        function cancel2Algorithm(reason) {
          canceled2 = true;
          reason2 = reason;
          if (canceled1) {
            var compositeReason = CreateArrayFromList([reason1, reason2]);
            var cancelResult = ReadableStreamCancel(stream, compositeReason);
            resolveCancelPromise(cancelResult);
          }
          return cancelPromise;
        }
        function startAlgorithm() {
        }
        branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);
        branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);
        uponRejection(reader._closedPromise, function(r2) {
          ReadableStreamDefaultControllerError(branch1._readableStreamController, r2);
          ReadableStreamDefaultControllerError(branch2._readableStreamController, r2);
          if (!canceled1 || !canceled2) {
            resolveCancelPromise(void 0);
          }
          return null;
        });
        return [branch1, branch2];
      }
      function ReadableByteStreamTee(stream) {
        var reader = AcquireReadableStreamDefaultReader(stream);
        var reading = false;
        var readAgainForBranch1 = false;
        var readAgainForBranch2 = false;
        var canceled1 = false;
        var canceled2 = false;
        var reason1;
        var reason2;
        var branch1;
        var branch2;
        var resolveCancelPromise;
        var cancelPromise = newPromise(function(resolve) {
          resolveCancelPromise = resolve;
        });
        function forwardReaderError(thisReader) {
          uponRejection(thisReader._closedPromise, function(r2) {
            if (thisReader !== reader) {
              return null;
            }
            ReadableByteStreamControllerError(branch1._readableStreamController, r2);
            ReadableByteStreamControllerError(branch2._readableStreamController, r2);
            if (!canceled1 || !canceled2) {
              resolveCancelPromise(void 0);
            }
            return null;
          });
        }
        function pullWithDefaultReader() {
          if (IsReadableStreamBYOBReader(reader)) {
            ReadableStreamReaderGenericRelease(reader);
            reader = AcquireReadableStreamDefaultReader(stream);
            forwardReaderError(reader);
          }
          var readRequest = {
            _chunkSteps: function(chunk) {
              _queueMicrotask(function() {
                readAgainForBranch1 = false;
                readAgainForBranch2 = false;
                var chunk1 = chunk;
                var chunk2 = chunk;
                if (!canceled1 && !canceled2) {
                  try {
                    chunk2 = CloneAsUint8Array(chunk);
                  } catch (cloneE) {
                    ReadableByteStreamControllerError(branch1._readableStreamController, cloneE);
                    ReadableByteStreamControllerError(branch2._readableStreamController, cloneE);
                    resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                    return;
                  }
                }
                if (!canceled1) {
                  ReadableByteStreamControllerEnqueue(branch1._readableStreamController, chunk1);
                }
                if (!canceled2) {
                  ReadableByteStreamControllerEnqueue(branch2._readableStreamController, chunk2);
                }
                reading = false;
                if (readAgainForBranch1) {
                  pull1Algorithm();
                } else if (readAgainForBranch2) {
                  pull2Algorithm();
                }
              });
            },
            _closeSteps: function() {
              reading = false;
              if (!canceled1) {
                ReadableByteStreamControllerClose(branch1._readableStreamController);
              }
              if (!canceled2) {
                ReadableByteStreamControllerClose(branch2._readableStreamController);
              }
              if (branch1._readableStreamController._pendingPullIntos.length > 0) {
                ReadableByteStreamControllerRespond(branch1._readableStreamController, 0);
              }
              if (branch2._readableStreamController._pendingPullIntos.length > 0) {
                ReadableByteStreamControllerRespond(branch2._readableStreamController, 0);
              }
              if (!canceled1 || !canceled2) {
                resolveCancelPromise(void 0);
              }
            },
            _errorSteps: function() {
              reading = false;
            }
          };
          ReadableStreamDefaultReaderRead(reader, readRequest);
        }
        function pullWithBYOBReader(view, forBranch2) {
          if (IsReadableStreamDefaultReader(reader)) {
            ReadableStreamReaderGenericRelease(reader);
            reader = AcquireReadableStreamBYOBReader(stream);
            forwardReaderError(reader);
          }
          var byobBranch = forBranch2 ? branch2 : branch1;
          var otherBranch = forBranch2 ? branch1 : branch2;
          var readIntoRequest = {
            _chunkSteps: function(chunk) {
              _queueMicrotask(function() {
                readAgainForBranch1 = false;
                readAgainForBranch2 = false;
                var byobCanceled = forBranch2 ? canceled2 : canceled1;
                var otherCanceled = forBranch2 ? canceled1 : canceled2;
                if (!otherCanceled) {
                  var clonedChunk = void 0;
                  try {
                    clonedChunk = CloneAsUint8Array(chunk);
                  } catch (cloneE) {
                    ReadableByteStreamControllerError(byobBranch._readableStreamController, cloneE);
                    ReadableByteStreamControllerError(otherBranch._readableStreamController, cloneE);
                    resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                    return;
                  }
                  if (!byobCanceled) {
                    ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                  }
                  ReadableByteStreamControllerEnqueue(otherBranch._readableStreamController, clonedChunk);
                } else if (!byobCanceled) {
                  ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                }
                reading = false;
                if (readAgainForBranch1) {
                  pull1Algorithm();
                } else if (readAgainForBranch2) {
                  pull2Algorithm();
                }
              });
            },
            _closeSteps: function(chunk) {
              reading = false;
              var byobCanceled = forBranch2 ? canceled2 : canceled1;
              var otherCanceled = forBranch2 ? canceled1 : canceled2;
              if (!byobCanceled) {
                ReadableByteStreamControllerClose(byobBranch._readableStreamController);
              }
              if (!otherCanceled) {
                ReadableByteStreamControllerClose(otherBranch._readableStreamController);
              }
              if (chunk !== void 0) {
                if (!byobCanceled) {
                  ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                }
                if (!otherCanceled && otherBranch._readableStreamController._pendingPullIntos.length > 0) {
                  ReadableByteStreamControllerRespond(otherBranch._readableStreamController, 0);
                }
              }
              if (!byobCanceled || !otherCanceled) {
                resolveCancelPromise(void 0);
              }
            },
            _errorSteps: function() {
              reading = false;
            }
          };
          ReadableStreamBYOBReaderRead(reader, view, 1, readIntoRequest);
        }
        function pull1Algorithm() {
          if (reading) {
            readAgainForBranch1 = true;
            return promiseResolvedWith(void 0);
          }
          reading = true;
          var byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch1._readableStreamController);
          if (byobRequest === null) {
            pullWithDefaultReader();
          } else {
            pullWithBYOBReader(byobRequest._view, false);
          }
          return promiseResolvedWith(void 0);
        }
        function pull2Algorithm() {
          if (reading) {
            readAgainForBranch2 = true;
            return promiseResolvedWith(void 0);
          }
          reading = true;
          var byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch2._readableStreamController);
          if (byobRequest === null) {
            pullWithDefaultReader();
          } else {
            pullWithBYOBReader(byobRequest._view, true);
          }
          return promiseResolvedWith(void 0);
        }
        function cancel1Algorithm(reason) {
          canceled1 = true;
          reason1 = reason;
          if (canceled2) {
            var compositeReason = CreateArrayFromList([reason1, reason2]);
            var cancelResult = ReadableStreamCancel(stream, compositeReason);
            resolveCancelPromise(cancelResult);
          }
          return cancelPromise;
        }
        function cancel2Algorithm(reason) {
          canceled2 = true;
          reason2 = reason;
          if (canceled1) {
            var compositeReason = CreateArrayFromList([reason1, reason2]);
            var cancelResult = ReadableStreamCancel(stream, compositeReason);
            resolveCancelPromise(cancelResult);
          }
          return cancelPromise;
        }
        function startAlgorithm() {
          return;
        }
        branch1 = CreateReadableByteStream(startAlgorithm, pull1Algorithm, cancel1Algorithm);
        branch2 = CreateReadableByteStream(startAlgorithm, pull2Algorithm, cancel2Algorithm);
        forwardReaderError(reader);
        return [branch1, branch2];
      }
      function isReadableStreamLike(stream) {
        return typeIsObject(stream) && typeof stream.getReader !== "undefined";
      }
      function ReadableStreamFrom(source) {
        if (isReadableStreamLike(source)) {
          return ReadableStreamFromDefaultReader(source.getReader());
        }
        return ReadableStreamFromIterable(source);
      }
      function ReadableStreamFromIterable(asyncIterable) {
        var stream;
        var iteratorRecord = GetIterator(asyncIterable, "async");
        var startAlgorithm = noop;
        function pullAlgorithm() {
          var nextResult;
          try {
            nextResult = IteratorNext(iteratorRecord);
          } catch (e) {
            return promiseRejectedWith(e);
          }
          var nextPromise = promiseResolvedWith(nextResult);
          return transformPromiseWith(nextPromise, function(iterResult) {
            if (!typeIsObject(iterResult)) {
              throw new TypeError("The promise returned by the iterator.next() method must fulfill with an object");
            }
            var done = IteratorComplete(iterResult);
            if (done) {
              ReadableStreamDefaultControllerClose(stream._readableStreamController);
            } else {
              var value = IteratorValue(iterResult);
              ReadableStreamDefaultControllerEnqueue(stream._readableStreamController, value);
            }
          });
        }
        function cancelAlgorithm(reason) {
          var iterator = iteratorRecord.iterator;
          var returnMethod;
          try {
            returnMethod = GetMethod(iterator, "return");
          } catch (e) {
            return promiseRejectedWith(e);
          }
          if (returnMethod === void 0) {
            return promiseResolvedWith(void 0);
          }
          var returnResult;
          try {
            returnResult = reflectCall(returnMethod, iterator, [reason]);
          } catch (e) {
            return promiseRejectedWith(e);
          }
          var returnPromise = promiseResolvedWith(returnResult);
          return transformPromiseWith(returnPromise, function(iterResult) {
            if (!typeIsObject(iterResult)) {
              throw new TypeError("The promise returned by the iterator.return() method must fulfill with an object");
            }
            return void 0;
          });
        }
        stream = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, 0);
        return stream;
      }
      function ReadableStreamFromDefaultReader(reader) {
        var stream;
        var startAlgorithm = noop;
        function pullAlgorithm() {
          var readPromise;
          try {
            readPromise = reader.read();
          } catch (e) {
            return promiseRejectedWith(e);
          }
          return transformPromiseWith(readPromise, function(readResult) {
            if (!typeIsObject(readResult)) {
              throw new TypeError("The promise returned by the reader.read() method must fulfill with an object");
            }
            if (readResult.done) {
              ReadableStreamDefaultControllerClose(stream._readableStreamController);
            } else {
              var value = readResult.value;
              ReadableStreamDefaultControllerEnqueue(stream._readableStreamController, value);
            }
          });
        }
        function cancelAlgorithm(reason) {
          try {
            return promiseResolvedWith(reader.cancel(reason));
          } catch (e) {
            return promiseRejectedWith(e);
          }
        }
        stream = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, 0);
        return stream;
      }
      function convertUnderlyingDefaultOrByteSource(source, context) {
        assertDictionary(source, context);
        var original = source;
        var autoAllocateChunkSize = original === null || original === void 0 ? void 0 : original.autoAllocateChunkSize;
        var cancel = original === null || original === void 0 ? void 0 : original.cancel;
        var pull = original === null || original === void 0 ? void 0 : original.pull;
        var start = original === null || original === void 0 ? void 0 : original.start;
        var type = original === null || original === void 0 ? void 0 : original.type;
        return {
          autoAllocateChunkSize: autoAllocateChunkSize === void 0 ? void 0 : convertUnsignedLongLongWithEnforceRange(autoAllocateChunkSize, "".concat(context, " has member 'autoAllocateChunkSize' that")),
          cancel: cancel === void 0 ? void 0 : convertUnderlyingSourceCancelCallback(cancel, original, "".concat(context, " has member 'cancel' that")),
          pull: pull === void 0 ? void 0 : convertUnderlyingSourcePullCallback(pull, original, "".concat(context, " has member 'pull' that")),
          start: start === void 0 ? void 0 : convertUnderlyingSourceStartCallback(start, original, "".concat(context, " has member 'start' that")),
          type: type === void 0 ? void 0 : convertReadableStreamType(type, "".concat(context, " has member 'type' that"))
        };
      }
      function convertUnderlyingSourceCancelCallback(fn, original, context) {
        assertFunction(fn, context);
        return function(reason) {
          return promiseCall(fn, original, [reason]);
        };
      }
      function convertUnderlyingSourcePullCallback(fn, original, context) {
        assertFunction(fn, context);
        return function(controller) {
          return promiseCall(fn, original, [controller]);
        };
      }
      function convertUnderlyingSourceStartCallback(fn, original, context) {
        assertFunction(fn, context);
        return function(controller) {
          return reflectCall(fn, original, [controller]);
        };
      }
      function convertReadableStreamType(type, context) {
        type = "".concat(type);
        if (type !== "bytes") {
          throw new TypeError("".concat(context, " '").concat(type, "' is not a valid enumeration value for ReadableStreamType"));
        }
        return type;
      }
      function convertIteratorOptions(options, context) {
        assertDictionary(options, context);
        var preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;
        return { preventCancel: Boolean(preventCancel) };
      }
      function convertPipeOptions(options, context) {
        assertDictionary(options, context);
        var preventAbort = options === null || options === void 0 ? void 0 : options.preventAbort;
        var preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;
        var preventClose = options === null || options === void 0 ? void 0 : options.preventClose;
        var signal = options === null || options === void 0 ? void 0 : options.signal;
        if (signal !== void 0) {
          assertAbortSignal(signal, "".concat(context, " has member 'signal' that"));
        }
        return {
          preventAbort: Boolean(preventAbort),
          preventCancel: Boolean(preventCancel),
          preventClose: Boolean(preventClose),
          signal
        };
      }
      function assertAbortSignal(signal, context) {
        if (!isAbortSignal(signal)) {
          throw new TypeError("".concat(context, " is not an AbortSignal."));
        }
      }
      function convertReadableWritablePair(pair, context) {
        assertDictionary(pair, context);
        var readable = pair === null || pair === void 0 ? void 0 : pair.readable;
        assertRequiredField(readable, "readable", "ReadableWritablePair");
        assertReadableStream(readable, "".concat(context, " has member 'readable' that"));
        var writable = pair === null || pair === void 0 ? void 0 : pair.writable;
        assertRequiredField(writable, "writable", "ReadableWritablePair");
        assertWritableStream(writable, "".concat(context, " has member 'writable' that"));
        return { readable, writable };
      }
      var ReadableStream2 = (
        /** @class */
        function() {
          function ReadableStream3(rawUnderlyingSource, rawStrategy) {
            if (rawUnderlyingSource === void 0) {
              rawUnderlyingSource = {};
            }
            if (rawStrategy === void 0) {
              rawStrategy = {};
            }
            if (rawUnderlyingSource === void 0) {
              rawUnderlyingSource = null;
            } else {
              assertObject(rawUnderlyingSource, "First parameter");
            }
            var strategy = convertQueuingStrategy(rawStrategy, "Second parameter");
            var underlyingSource = convertUnderlyingDefaultOrByteSource(rawUnderlyingSource, "First parameter");
            InitializeReadableStream(this);
            if (underlyingSource.type === "bytes") {
              if (strategy.size !== void 0) {
                throw new RangeError("The strategy for a byte stream cannot have a size function");
              }
              var highWaterMark = ExtractHighWaterMark(strategy, 0);
              SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);
            } else {
              var sizeAlgorithm = ExtractSizeAlgorithm(strategy);
              var highWaterMark = ExtractHighWaterMark(strategy, 1);
              SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);
            }
          }
          Object.defineProperty(ReadableStream3.prototype, "locked", {
            /**
             * Whether or not the readable stream is locked to a {@link ReadableStreamDefaultReader | reader}.
             */
            get: function() {
              if (!IsReadableStream(this)) {
                throw streamBrandCheckException$1("locked");
              }
              return IsReadableStreamLocked(this);
            },
            enumerable: false,
            configurable: true
          });
          ReadableStream3.prototype.cancel = function(reason) {
            if (reason === void 0) {
              reason = void 0;
            }
            if (!IsReadableStream(this)) {
              return promiseRejectedWith(streamBrandCheckException$1("cancel"));
            }
            if (IsReadableStreamLocked(this)) {
              return promiseRejectedWith(new TypeError("Cannot cancel a stream that already has a reader"));
            }
            return ReadableStreamCancel(this, reason);
          };
          ReadableStream3.prototype.getReader = function(rawOptions) {
            if (rawOptions === void 0) {
              rawOptions = void 0;
            }
            if (!IsReadableStream(this)) {
              throw streamBrandCheckException$1("getReader");
            }
            var options = convertReaderOptions(rawOptions, "First parameter");
            if (options.mode === void 0) {
              return AcquireReadableStreamDefaultReader(this);
            }
            return AcquireReadableStreamBYOBReader(this);
          };
          ReadableStream3.prototype.pipeThrough = function(rawTransform, rawOptions) {
            if (rawOptions === void 0) {
              rawOptions = {};
            }
            if (!IsReadableStream(this)) {
              throw streamBrandCheckException$1("pipeThrough");
            }
            assertRequiredArgument(rawTransform, 1, "pipeThrough");
            var transform = convertReadableWritablePair(rawTransform, "First parameter");
            var options = convertPipeOptions(rawOptions, "Second parameter");
            if (IsReadableStreamLocked(this)) {
              throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream");
            }
            if (IsWritableStreamLocked(transform.writable)) {
              throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream");
            }
            var promise = ReadableStreamPipeTo(this, transform.writable, options.preventClose, options.preventAbort, options.preventCancel, options.signal);
            setPromiseIsHandledToTrue(promise);
            return transform.readable;
          };
          ReadableStream3.prototype.pipeTo = function(destination, rawOptions) {
            if (rawOptions === void 0) {
              rawOptions = {};
            }
            if (!IsReadableStream(this)) {
              return promiseRejectedWith(streamBrandCheckException$1("pipeTo"));
            }
            if (destination === void 0) {
              return promiseRejectedWith("Parameter 1 is required in 'pipeTo'.");
            }
            if (!IsWritableStream(destination)) {
              return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo's first argument must be a WritableStream"));
            }
            var options;
            try {
              options = convertPipeOptions(rawOptions, "Second parameter");
            } catch (e) {
              return promiseRejectedWith(e);
            }
            if (IsReadableStreamLocked(this)) {
              return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream"));
            }
            if (IsWritableStreamLocked(destination)) {
              return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream"));
            }
            return ReadableStreamPipeTo(this, destination, options.preventClose, options.preventAbort, options.preventCancel, options.signal);
          };
          ReadableStream3.prototype.tee = function() {
            if (!IsReadableStream(this)) {
              throw streamBrandCheckException$1("tee");
            }
            var branches = ReadableStreamTee(this);
            return CreateArrayFromList(branches);
          };
          ReadableStream3.prototype.values = function(rawOptions) {
            if (rawOptions === void 0) {
              rawOptions = void 0;
            }
            if (!IsReadableStream(this)) {
              throw streamBrandCheckException$1("values");
            }
            var options = convertIteratorOptions(rawOptions, "First parameter");
            return AcquireReadableStreamAsyncIterator(this, options.preventCancel);
          };
          ReadableStream3.prototype[SymbolAsyncIterator] = function(options) {
            return this.values(options);
          };
          ReadableStream3.from = function(asyncIterable) {
            return ReadableStreamFrom(asyncIterable);
          };
          return ReadableStream3;
        }()
      );
      Object.defineProperties(ReadableStream2, {
        from: { enumerable: true }
      });
      Object.defineProperties(ReadableStream2.prototype, {
        cancel: { enumerable: true },
        getReader: { enumerable: true },
        pipeThrough: { enumerable: true },
        pipeTo: { enumerable: true },
        tee: { enumerable: true },
        values: { enumerable: true },
        locked: { enumerable: true }
      });
      setFunctionName(ReadableStream2.from, "from");
      setFunctionName(ReadableStream2.prototype.cancel, "cancel");
      setFunctionName(ReadableStream2.prototype.getReader, "getReader");
      setFunctionName(ReadableStream2.prototype.pipeThrough, "pipeThrough");
      setFunctionName(ReadableStream2.prototype.pipeTo, "pipeTo");
      setFunctionName(ReadableStream2.prototype.tee, "tee");
      setFunctionName(ReadableStream2.prototype.values, "values");
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(ReadableStream2.prototype, SymbolPolyfill.toStringTag, {
          value: "ReadableStream",
          configurable: true
        });
      }
      Object.defineProperty(ReadableStream2.prototype, SymbolAsyncIterator, {
        value: ReadableStream2.prototype.values,
        writable: true,
        configurable: true
      });
      function CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {
        if (highWaterMark === void 0) {
          highWaterMark = 1;
        }
        if (sizeAlgorithm === void 0) {
          sizeAlgorithm = function() {
            return 1;
          };
        }
        var stream = Object.create(ReadableStream2.prototype);
        InitializeReadableStream(stream);
        var controller = Object.create(ReadableStreamDefaultController.prototype);
        SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
        return stream;
      }
      function CreateReadableByteStream(startAlgorithm, pullAlgorithm, cancelAlgorithm) {
        var stream = Object.create(ReadableStream2.prototype);
        InitializeReadableStream(stream);
        var controller = Object.create(ReadableByteStreamController.prototype);
        SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, 0, void 0);
        return stream;
      }
      function InitializeReadableStream(stream) {
        stream._state = "readable";
        stream._reader = void 0;
        stream._storedError = void 0;
        stream._disturbed = false;
      }
      function IsReadableStream(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_readableStreamController")) {
          return false;
        }
        return x instanceof ReadableStream2;
      }
      function IsReadableStreamLocked(stream) {
        if (stream._reader === void 0) {
          return false;
        }
        return true;
      }
      function ReadableStreamCancel(stream, reason) {
        stream._disturbed = true;
        if (stream._state === "closed") {
          return promiseResolvedWith(void 0);
        }
        if (stream._state === "errored") {
          return promiseRejectedWith(stream._storedError);
        }
        ReadableStreamClose(stream);
        var reader = stream._reader;
        if (reader !== void 0 && IsReadableStreamBYOBReader(reader)) {
          var readIntoRequests = reader._readIntoRequests;
          reader._readIntoRequests = new SimpleQueue();
          readIntoRequests.forEach(function(readIntoRequest) {
            readIntoRequest._closeSteps(void 0);
          });
        }
        var sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);
        return transformPromiseWith(sourceCancelPromise, noop);
      }
      function ReadableStreamClose(stream) {
        stream._state = "closed";
        var reader = stream._reader;
        if (reader === void 0) {
          return;
        }
        defaultReaderClosedPromiseResolve(reader);
        if (IsReadableStreamDefaultReader(reader)) {
          var readRequests = reader._readRequests;
          reader._readRequests = new SimpleQueue();
          readRequests.forEach(function(readRequest) {
            readRequest._closeSteps();
          });
        }
      }
      function ReadableStreamError(stream, e) {
        stream._state = "errored";
        stream._storedError = e;
        var reader = stream._reader;
        if (reader === void 0) {
          return;
        }
        defaultReaderClosedPromiseReject(reader, e);
        if (IsReadableStreamDefaultReader(reader)) {
          ReadableStreamDefaultReaderErrorReadRequests(reader, e);
        } else {
          ReadableStreamBYOBReaderErrorReadIntoRequests(reader, e);
        }
      }
      function streamBrandCheckException$1(name) {
        return new TypeError("ReadableStream.prototype.".concat(name, " can only be used on a ReadableStream"));
      }
      function convertQueuingStrategyInit(init, context) {
        assertDictionary(init, context);
        var highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;
        assertRequiredField(highWaterMark, "highWaterMark", "QueuingStrategyInit");
        return {
          highWaterMark: convertUnrestrictedDouble(highWaterMark)
        };
      }
      var byteLengthSizeFunction = function(chunk) {
        return chunk.byteLength;
      };
      setFunctionName(byteLengthSizeFunction, "size");
      var ByteLengthQueuingStrategy = (
        /** @class */
        function() {
          function ByteLengthQueuingStrategy2(options) {
            assertRequiredArgument(options, 1, "ByteLengthQueuingStrategy");
            options = convertQueuingStrategyInit(options, "First parameter");
            this._byteLengthQueuingStrategyHighWaterMark = options.highWaterMark;
          }
          Object.defineProperty(ByteLengthQueuingStrategy2.prototype, "highWaterMark", {
            /**
             * Returns the high water mark provided to the constructor.
             */
            get: function() {
              if (!IsByteLengthQueuingStrategy(this)) {
                throw byteLengthBrandCheckException("highWaterMark");
              }
              return this._byteLengthQueuingStrategyHighWaterMark;
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(ByteLengthQueuingStrategy2.prototype, "size", {
            /**
             * Measures the size of `chunk` by returning the value of its `byteLength` property.
             */
            get: function() {
              if (!IsByteLengthQueuingStrategy(this)) {
                throw byteLengthBrandCheckException("size");
              }
              return byteLengthSizeFunction;
            },
            enumerable: false,
            configurable: true
          });
          return ByteLengthQueuingStrategy2;
        }()
      );
      Object.defineProperties(ByteLengthQueuingStrategy.prototype, {
        highWaterMark: { enumerable: true },
        size: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(ByteLengthQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
          value: "ByteLengthQueuingStrategy",
          configurable: true
        });
      }
      function byteLengthBrandCheckException(name) {
        return new TypeError("ByteLengthQueuingStrategy.prototype.".concat(name, " can only be used on a ByteLengthQueuingStrategy"));
      }
      function IsByteLengthQueuingStrategy(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_byteLengthQueuingStrategyHighWaterMark")) {
          return false;
        }
        return x instanceof ByteLengthQueuingStrategy;
      }
      var countSizeFunction = function() {
        return 1;
      };
      setFunctionName(countSizeFunction, "size");
      var CountQueuingStrategy = (
        /** @class */
        function() {
          function CountQueuingStrategy2(options) {
            assertRequiredArgument(options, 1, "CountQueuingStrategy");
            options = convertQueuingStrategyInit(options, "First parameter");
            this._countQueuingStrategyHighWaterMark = options.highWaterMark;
          }
          Object.defineProperty(CountQueuingStrategy2.prototype, "highWaterMark", {
            /**
             * Returns the high water mark provided to the constructor.
             */
            get: function() {
              if (!IsCountQueuingStrategy(this)) {
                throw countBrandCheckException("highWaterMark");
              }
              return this._countQueuingStrategyHighWaterMark;
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(CountQueuingStrategy2.prototype, "size", {
            /**
             * Measures the size of `chunk` by always returning 1.
             * This ensures that the total queue size is a count of the number of chunks in the queue.
             */
            get: function() {
              if (!IsCountQueuingStrategy(this)) {
                throw countBrandCheckException("size");
              }
              return countSizeFunction;
            },
            enumerable: false,
            configurable: true
          });
          return CountQueuingStrategy2;
        }()
      );
      Object.defineProperties(CountQueuingStrategy.prototype, {
        highWaterMark: { enumerable: true },
        size: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(CountQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
          value: "CountQueuingStrategy",
          configurable: true
        });
      }
      function countBrandCheckException(name) {
        return new TypeError("CountQueuingStrategy.prototype.".concat(name, " can only be used on a CountQueuingStrategy"));
      }
      function IsCountQueuingStrategy(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_countQueuingStrategyHighWaterMark")) {
          return false;
        }
        return x instanceof CountQueuingStrategy;
      }
      function convertTransformer(original, context) {
        assertDictionary(original, context);
        var cancel = original === null || original === void 0 ? void 0 : original.cancel;
        var flush = original === null || original === void 0 ? void 0 : original.flush;
        var readableType = original === null || original === void 0 ? void 0 : original.readableType;
        var start = original === null || original === void 0 ? void 0 : original.start;
        var transform = original === null || original === void 0 ? void 0 : original.transform;
        var writableType = original === null || original === void 0 ? void 0 : original.writableType;
        return {
          cancel: cancel === void 0 ? void 0 : convertTransformerCancelCallback(cancel, original, "".concat(context, " has member 'cancel' that")),
          flush: flush === void 0 ? void 0 : convertTransformerFlushCallback(flush, original, "".concat(context, " has member 'flush' that")),
          readableType,
          start: start === void 0 ? void 0 : convertTransformerStartCallback(start, original, "".concat(context, " has member 'start' that")),
          transform: transform === void 0 ? void 0 : convertTransformerTransformCallback(transform, original, "".concat(context, " has member 'transform' that")),
          writableType
        };
      }
      function convertTransformerFlushCallback(fn, original, context) {
        assertFunction(fn, context);
        return function(controller) {
          return promiseCall(fn, original, [controller]);
        };
      }
      function convertTransformerStartCallback(fn, original, context) {
        assertFunction(fn, context);
        return function(controller) {
          return reflectCall(fn, original, [controller]);
        };
      }
      function convertTransformerTransformCallback(fn, original, context) {
        assertFunction(fn, context);
        return function(chunk, controller) {
          return promiseCall(fn, original, [chunk, controller]);
        };
      }
      function convertTransformerCancelCallback(fn, original, context) {
        assertFunction(fn, context);
        return function(reason) {
          return promiseCall(fn, original, [reason]);
        };
      }
      var TransformStream = (
        /** @class */
        function() {
          function TransformStream2(rawTransformer, rawWritableStrategy, rawReadableStrategy) {
            if (rawTransformer === void 0) {
              rawTransformer = {};
            }
            if (rawWritableStrategy === void 0) {
              rawWritableStrategy = {};
            }
            if (rawReadableStrategy === void 0) {
              rawReadableStrategy = {};
            }
            if (rawTransformer === void 0) {
              rawTransformer = null;
            }
            var writableStrategy = convertQueuingStrategy(rawWritableStrategy, "Second parameter");
            var readableStrategy = convertQueuingStrategy(rawReadableStrategy, "Third parameter");
            var transformer = convertTransformer(rawTransformer, "First parameter");
            if (transformer.readableType !== void 0) {
              throw new RangeError("Invalid readableType specified");
            }
            if (transformer.writableType !== void 0) {
              throw new RangeError("Invalid writableType specified");
            }
            var readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0);
            var readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy);
            var writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1);
            var writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);
            var startPromise_resolve;
            var startPromise = newPromise(function(resolve) {
              startPromise_resolve = resolve;
            });
            InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
            SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);
            if (transformer.start !== void 0) {
              startPromise_resolve(transformer.start(this._transformStreamController));
            } else {
              startPromise_resolve(void 0);
            }
          }
          Object.defineProperty(TransformStream2.prototype, "readable", {
            /**
             * The readable side of the transform stream.
             */
            get: function() {
              if (!IsTransformStream(this)) {
                throw streamBrandCheckException("readable");
              }
              return this._readable;
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(TransformStream2.prototype, "writable", {
            /**
             * The writable side of the transform stream.
             */
            get: function() {
              if (!IsTransformStream(this)) {
                throw streamBrandCheckException("writable");
              }
              return this._writable;
            },
            enumerable: false,
            configurable: true
          });
          return TransformStream2;
        }()
      );
      Object.defineProperties(TransformStream.prototype, {
        readable: { enumerable: true },
        writable: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(TransformStream.prototype, SymbolPolyfill.toStringTag, {
          value: "TransformStream",
          configurable: true
        });
      }
      function InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {
        function startAlgorithm() {
          return startPromise;
        }
        function writeAlgorithm(chunk) {
          return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);
        }
        function abortAlgorithm(reason) {
          return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);
        }
        function closeAlgorithm() {
          return TransformStreamDefaultSinkCloseAlgorithm(stream);
        }
        stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);
        function pullAlgorithm() {
          return TransformStreamDefaultSourcePullAlgorithm(stream);
        }
        function cancelAlgorithm(reason) {
          return TransformStreamDefaultSourceCancelAlgorithm(stream, reason);
        }
        stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
        stream._backpressure = void 0;
        stream._backpressureChangePromise = void 0;
        stream._backpressureChangePromise_resolve = void 0;
        TransformStreamSetBackpressure(stream, true);
        stream._transformStreamController = void 0;
      }
      function IsTransformStream(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_transformStreamController")) {
          return false;
        }
        return x instanceof TransformStream;
      }
      function TransformStreamError(stream, e) {
        ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e);
        TransformStreamErrorWritableAndUnblockWrite(stream, e);
      }
      function TransformStreamErrorWritableAndUnblockWrite(stream, e) {
        TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController);
        WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e);
        TransformStreamUnblockWrite(stream);
      }
      function TransformStreamUnblockWrite(stream) {
        if (stream._backpressure) {
          TransformStreamSetBackpressure(stream, false);
        }
      }
      function TransformStreamSetBackpressure(stream, backpressure) {
        if (stream._backpressureChangePromise !== void 0) {
          stream._backpressureChangePromise_resolve();
        }
        stream._backpressureChangePromise = newPromise(function(resolve) {
          stream._backpressureChangePromise_resolve = resolve;
        });
        stream._backpressure = backpressure;
      }
      var TransformStreamDefaultController = (
        /** @class */
        function() {
          function TransformStreamDefaultController2() {
            throw new TypeError("Illegal constructor");
          }
          Object.defineProperty(TransformStreamDefaultController2.prototype, "desiredSize", {
            /**
             * Returns the desired size to fill the readable side’s internal queue. It can be negative, if the queue is over-full.
             */
            get: function() {
              if (!IsTransformStreamDefaultController(this)) {
                throw defaultControllerBrandCheckException("desiredSize");
              }
              var readableController = this._controlledTransformStream._readable._readableStreamController;
              return ReadableStreamDefaultControllerGetDesiredSize(readableController);
            },
            enumerable: false,
            configurable: true
          });
          TransformStreamDefaultController2.prototype.enqueue = function(chunk) {
            if (chunk === void 0) {
              chunk = void 0;
            }
            if (!IsTransformStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException("enqueue");
            }
            TransformStreamDefaultControllerEnqueue(this, chunk);
          };
          TransformStreamDefaultController2.prototype.error = function(reason) {
            if (reason === void 0) {
              reason = void 0;
            }
            if (!IsTransformStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException("error");
            }
            TransformStreamDefaultControllerError(this, reason);
          };
          TransformStreamDefaultController2.prototype.terminate = function() {
            if (!IsTransformStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException("terminate");
            }
            TransformStreamDefaultControllerTerminate(this);
          };
          return TransformStreamDefaultController2;
        }()
      );
      Object.defineProperties(TransformStreamDefaultController.prototype, {
        enqueue: { enumerable: true },
        error: { enumerable: true },
        terminate: { enumerable: true },
        desiredSize: { enumerable: true }
      });
      setFunctionName(TransformStreamDefaultController.prototype.enqueue, "enqueue");
      setFunctionName(TransformStreamDefaultController.prototype.error, "error");
      setFunctionName(TransformStreamDefaultController.prototype.terminate, "terminate");
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(TransformStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
          value: "TransformStreamDefaultController",
          configurable: true
        });
      }
      function IsTransformStreamDefaultController(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_controlledTransformStream")) {
          return false;
        }
        return x instanceof TransformStreamDefaultController;
      }
      function SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm, cancelAlgorithm) {
        controller._controlledTransformStream = stream;
        stream._transformStreamController = controller;
        controller._transformAlgorithm = transformAlgorithm;
        controller._flushAlgorithm = flushAlgorithm;
        controller._cancelAlgorithm = cancelAlgorithm;
        controller._finishPromise = void 0;
        controller._finishPromise_resolve = void 0;
        controller._finishPromise_reject = void 0;
      }
      function SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer) {
        var controller = Object.create(TransformStreamDefaultController.prototype);
        var transformAlgorithm;
        var flushAlgorithm;
        var cancelAlgorithm;
        if (transformer.transform !== void 0) {
          transformAlgorithm = function(chunk) {
            return transformer.transform(chunk, controller);
          };
        } else {
          transformAlgorithm = function(chunk) {
            try {
              TransformStreamDefaultControllerEnqueue(controller, chunk);
              return promiseResolvedWith(void 0);
            } catch (transformResultE) {
              return promiseRejectedWith(transformResultE);
            }
          };
        }
        if (transformer.flush !== void 0) {
          flushAlgorithm = function() {
            return transformer.flush(controller);
          };
        } else {
          flushAlgorithm = function() {
            return promiseResolvedWith(void 0);
          };
        }
        if (transformer.cancel !== void 0) {
          cancelAlgorithm = function(reason) {
            return transformer.cancel(reason);
          };
        } else {
          cancelAlgorithm = function() {
            return promiseResolvedWith(void 0);
          };
        }
        SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm, cancelAlgorithm);
      }
      function TransformStreamDefaultControllerClearAlgorithms(controller) {
        controller._transformAlgorithm = void 0;
        controller._flushAlgorithm = void 0;
        controller._cancelAlgorithm = void 0;
      }
      function TransformStreamDefaultControllerEnqueue(controller, chunk) {
        var stream = controller._controlledTransformStream;
        var readableController = stream._readable._readableStreamController;
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) {
          throw new TypeError("Readable side is not in a state that permits enqueue");
        }
        try {
          ReadableStreamDefaultControllerEnqueue(readableController, chunk);
        } catch (e) {
          TransformStreamErrorWritableAndUnblockWrite(stream, e);
          throw stream._readable._storedError;
        }
        var backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);
        if (backpressure !== stream._backpressure) {
          TransformStreamSetBackpressure(stream, true);
        }
      }
      function TransformStreamDefaultControllerError(controller, e) {
        TransformStreamError(controller._controlledTransformStream, e);
      }
      function TransformStreamDefaultControllerPerformTransform(controller, chunk) {
        var transformPromise = controller._transformAlgorithm(chunk);
        return transformPromiseWith(transformPromise, void 0, function(r2) {
          TransformStreamError(controller._controlledTransformStream, r2);
          throw r2;
        });
      }
      function TransformStreamDefaultControllerTerminate(controller) {
        var stream = controller._controlledTransformStream;
        var readableController = stream._readable._readableStreamController;
        ReadableStreamDefaultControllerClose(readableController);
        var error = new TypeError("TransformStream terminated");
        TransformStreamErrorWritableAndUnblockWrite(stream, error);
      }
      function TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {
        var controller = stream._transformStreamController;
        if (stream._backpressure) {
          var backpressureChangePromise = stream._backpressureChangePromise;
          return transformPromiseWith(backpressureChangePromise, function() {
            var writable = stream._writable;
            var state = writable._state;
            if (state === "erroring") {
              throw writable._storedError;
            }
            return TransformStreamDefaultControllerPerformTransform(controller, chunk);
          });
        }
        return TransformStreamDefaultControllerPerformTransform(controller, chunk);
      }
      function TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {
        var controller = stream._transformStreamController;
        if (controller._finishPromise !== void 0) {
          return controller._finishPromise;
        }
        var readable = stream._readable;
        controller._finishPromise = newPromise(function(resolve, reject) {
          controller._finishPromise_resolve = resolve;
          controller._finishPromise_reject = reject;
        });
        var cancelPromise = controller._cancelAlgorithm(reason);
        TransformStreamDefaultControllerClearAlgorithms(controller);
        uponPromise(cancelPromise, function() {
          if (readable._state === "errored") {
            defaultControllerFinishPromiseReject(controller, readable._storedError);
          } else {
            ReadableStreamDefaultControllerError(readable._readableStreamController, reason);
            defaultControllerFinishPromiseResolve(controller);
          }
          return null;
        }, function(r2) {
          ReadableStreamDefaultControllerError(readable._readableStreamController, r2);
          defaultControllerFinishPromiseReject(controller, r2);
          return null;
        });
        return controller._finishPromise;
      }
      function TransformStreamDefaultSinkCloseAlgorithm(stream) {
        var controller = stream._transformStreamController;
        if (controller._finishPromise !== void 0) {
          return controller._finishPromise;
        }
        var readable = stream._readable;
        controller._finishPromise = newPromise(function(resolve, reject) {
          controller._finishPromise_resolve = resolve;
          controller._finishPromise_reject = reject;
        });
        var flushPromise = controller._flushAlgorithm();
        TransformStreamDefaultControllerClearAlgorithms(controller);
        uponPromise(flushPromise, function() {
          if (readable._state === "errored") {
            defaultControllerFinishPromiseReject(controller, readable._storedError);
          } else {
            ReadableStreamDefaultControllerClose(readable._readableStreamController);
            defaultControllerFinishPromiseResolve(controller);
          }
          return null;
        }, function(r2) {
          ReadableStreamDefaultControllerError(readable._readableStreamController, r2);
          defaultControllerFinishPromiseReject(controller, r2);
          return null;
        });
        return controller._finishPromise;
      }
      function TransformStreamDefaultSourcePullAlgorithm(stream) {
        TransformStreamSetBackpressure(stream, false);
        return stream._backpressureChangePromise;
      }
      function TransformStreamDefaultSourceCancelAlgorithm(stream, reason) {
        var controller = stream._transformStreamController;
        if (controller._finishPromise !== void 0) {
          return controller._finishPromise;
        }
        var writable = stream._writable;
        controller._finishPromise = newPromise(function(resolve, reject) {
          controller._finishPromise_resolve = resolve;
          controller._finishPromise_reject = reject;
        });
        var cancelPromise = controller._cancelAlgorithm(reason);
        TransformStreamDefaultControllerClearAlgorithms(controller);
        uponPromise(cancelPromise, function() {
          if (writable._state === "errored") {
            defaultControllerFinishPromiseReject(controller, writable._storedError);
          } else {
            WritableStreamDefaultControllerErrorIfNeeded(writable._writableStreamController, reason);
            TransformStreamUnblockWrite(stream);
            defaultControllerFinishPromiseResolve(controller);
          }
          return null;
        }, function(r2) {
          WritableStreamDefaultControllerErrorIfNeeded(writable._writableStreamController, r2);
          TransformStreamUnblockWrite(stream);
          defaultControllerFinishPromiseReject(controller, r2);
          return null;
        });
        return controller._finishPromise;
      }
      function defaultControllerBrandCheckException(name) {
        return new TypeError("TransformStreamDefaultController.prototype.".concat(name, " can only be used on a TransformStreamDefaultController"));
      }
      function defaultControllerFinishPromiseResolve(controller) {
        if (controller._finishPromise_resolve === void 0) {
          return;
        }
        controller._finishPromise_resolve();
        controller._finishPromise_resolve = void 0;
        controller._finishPromise_reject = void 0;
      }
      function defaultControllerFinishPromiseReject(controller, reason) {
        if (controller._finishPromise_reject === void 0) {
          return;
        }
        setPromiseIsHandledToTrue(controller._finishPromise);
        controller._finishPromise_reject(reason);
        controller._finishPromise_resolve = void 0;
        controller._finishPromise_reject = void 0;
      }
      function streamBrandCheckException(name) {
        return new TypeError("TransformStream.prototype.".concat(name, " can only be used on a TransformStream"));
      }
      exports3.ByteLengthQueuingStrategy = ByteLengthQueuingStrategy;
      exports3.CountQueuingStrategy = CountQueuingStrategy;
      exports3.ReadableByteStreamController = ReadableByteStreamController;
      exports3.ReadableStream = ReadableStream2;
      exports3.ReadableStreamBYOBReader = ReadableStreamBYOBReader;
      exports3.ReadableStreamBYOBRequest = ReadableStreamBYOBRequest;
      exports3.ReadableStreamDefaultController = ReadableStreamDefaultController;
      exports3.ReadableStreamDefaultReader = ReadableStreamDefaultReader;
      exports3.TransformStream = TransformStream;
      exports3.TransformStreamDefaultController = TransformStreamDefaultController;
      exports3.WritableStream = WritableStream;
      exports3.WritableStreamDefaultController = WritableStreamDefaultController;
      exports3.WritableStreamDefaultWriter = WritableStreamDefaultWriter;
    });
  }
});

// browser-external:canvas
var require_canvas = __commonJS({
  "browser-external:canvas"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "canvas" has been externalized for browser compatibility. Cannot access "canvas.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:zlib
var require_zlib = __commonJS({
  "browser-external:zlib"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "zlib" has been externalized for browser compatibility. Cannot access "zlib.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/react-pdf-highlighter/node_modules/pdfjs-dist/legacy/build/pdf.js
var require_pdf = __commonJS({
  "node_modules/react-pdf-highlighter/node_modules/pdfjs-dist/legacy/build/pdf.js"(exports, module) {
    (function webpackUniversalModuleDefinition(root, factory) {
      if (typeof exports === "object" && typeof module === "object")
        module.exports = factory();
      else if (typeof define === "function" && define.amd)
        define("pdfjs-dist/build/pdf", [], factory);
      else if (typeof exports === "object")
        exports["pdfjs-dist/build/pdf"] = factory();
      else
        root["pdfjs-dist/build/pdf"] = root.pdfjsLib = factory();
    })(globalThis, () => {
      return (
        /******/
        (() => {
          var __webpack_modules__ = [
            ,
            /* 1 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.VerbosityLevel = exports2.Util = exports2.UnknownErrorException = exports2.UnexpectedResponseException = exports2.UNSUPPORTED_FEATURES = exports2.TextRenderingMode = exports2.StreamType = exports2.RenderingIntentFlag = exports2.PermissionFlag = exports2.PasswordResponses = exports2.PasswordException = exports2.PageActionEventType = exports2.OPS = exports2.MissingPDFException = exports2.LINE_FACTOR = exports2.LINE_DESCENT_FACTOR = exports2.InvalidPDFException = exports2.ImageKind = exports2.IDENTITY_MATRIX = exports2.FormatError = exports2.FontType = exports2.FeatureTest = exports2.FONT_IDENTITY_MATRIX = exports2.DocumentActionEventType = exports2.CMapCompressionType = exports2.BaseException = exports2.AnnotationType = exports2.AnnotationStateModelType = exports2.AnnotationReviewState = exports2.AnnotationReplyType = exports2.AnnotationMode = exports2.AnnotationMarkedState = exports2.AnnotationFlag = exports2.AnnotationFieldFlag = exports2.AnnotationEditorType = exports2.AnnotationEditorPrefix = exports2.AnnotationEditorParamsType = exports2.AnnotationBorderStyleType = exports2.AnnotationActionEventType = exports2.AbortException = void 0;
              exports2.arrayByteLength = arrayByteLength;
              exports2.arraysToBytes = arraysToBytes;
              exports2.assert = assert;
              exports2.bytesToString = bytesToString;
              exports2.createPromiseCapability = createPromiseCapability;
              exports2.createValidAbsoluteUrl = createValidAbsoluteUrl;
              exports2.escapeString = escapeString;
              exports2.getModificationDate = getModificationDate;
              exports2.getVerbosityLevel = getVerbosityLevel;
              exports2.info = info;
              exports2.isArrayBuffer = isArrayBuffer;
              exports2.isArrayEqual = isArrayEqual;
              exports2.isAscii = isAscii;
              exports2.objectFromMap = objectFromMap;
              exports2.objectSize = objectSize;
              exports2.setVerbosityLevel = setVerbosityLevel;
              exports2.shadow = shadow;
              exports2.string32 = string32;
              exports2.stringToBytes = stringToBytes;
              exports2.stringToPDFString = stringToPDFString;
              exports2.stringToUTF16BEString = stringToUTF16BEString;
              exports2.stringToUTF8String = stringToUTF8String;
              exports2.unreachable = unreachable;
              exports2.utf8StringToString = utf8StringToString;
              exports2.warn = warn;
              __w_pdfjs_require__2(2);
              const IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0];
              exports2.IDENTITY_MATRIX = IDENTITY_MATRIX;
              const FONT_IDENTITY_MATRIX = [1e-3, 0, 0, 1e-3, 0, 0];
              exports2.FONT_IDENTITY_MATRIX = FONT_IDENTITY_MATRIX;
              const LINE_FACTOR = 1.35;
              exports2.LINE_FACTOR = LINE_FACTOR;
              const LINE_DESCENT_FACTOR = 0.35;
              exports2.LINE_DESCENT_FACTOR = LINE_DESCENT_FACTOR;
              const RenderingIntentFlag = {
                ANY: 1,
                DISPLAY: 2,
                PRINT: 4,
                ANNOTATIONS_FORMS: 16,
                ANNOTATIONS_STORAGE: 32,
                ANNOTATIONS_DISABLE: 64,
                OPLIST: 256
              };
              exports2.RenderingIntentFlag = RenderingIntentFlag;
              const AnnotationMode = {
                DISABLE: 0,
                ENABLE: 1,
                ENABLE_FORMS: 2,
                ENABLE_STORAGE: 3
              };
              exports2.AnnotationMode = AnnotationMode;
              const AnnotationEditorPrefix = "pdfjs_internal_editor_";
              exports2.AnnotationEditorPrefix = AnnotationEditorPrefix;
              const AnnotationEditorType = {
                DISABLE: -1,
                NONE: 0,
                FREETEXT: 3,
                INK: 15
              };
              exports2.AnnotationEditorType = AnnotationEditorType;
              const AnnotationEditorParamsType = {
                FREETEXT_SIZE: 1,
                FREETEXT_COLOR: 2,
                FREETEXT_OPACITY: 3,
                INK_COLOR: 11,
                INK_THICKNESS: 12,
                INK_OPACITY: 13
              };
              exports2.AnnotationEditorParamsType = AnnotationEditorParamsType;
              const PermissionFlag = {
                PRINT: 4,
                MODIFY_CONTENTS: 8,
                COPY: 16,
                MODIFY_ANNOTATIONS: 32,
                FILL_INTERACTIVE_FORMS: 256,
                COPY_FOR_ACCESSIBILITY: 512,
                ASSEMBLE: 1024,
                PRINT_HIGH_QUALITY: 2048
              };
              exports2.PermissionFlag = PermissionFlag;
              const TextRenderingMode = {
                FILL: 0,
                STROKE: 1,
                FILL_STROKE: 2,
                INVISIBLE: 3,
                FILL_ADD_TO_PATH: 4,
                STROKE_ADD_TO_PATH: 5,
                FILL_STROKE_ADD_TO_PATH: 6,
                ADD_TO_PATH: 7,
                FILL_STROKE_MASK: 3,
                ADD_TO_PATH_FLAG: 4
              };
              exports2.TextRenderingMode = TextRenderingMode;
              const ImageKind = {
                GRAYSCALE_1BPP: 1,
                RGB_24BPP: 2,
                RGBA_32BPP: 3
              };
              exports2.ImageKind = ImageKind;
              const AnnotationType = {
                TEXT: 1,
                LINK: 2,
                FREETEXT: 3,
                LINE: 4,
                SQUARE: 5,
                CIRCLE: 6,
                POLYGON: 7,
                POLYLINE: 8,
                HIGHLIGHT: 9,
                UNDERLINE: 10,
                SQUIGGLY: 11,
                STRIKEOUT: 12,
                STAMP: 13,
                CARET: 14,
                INK: 15,
                POPUP: 16,
                FILEATTACHMENT: 17,
                SOUND: 18,
                MOVIE: 19,
                WIDGET: 20,
                SCREEN: 21,
                PRINTERMARK: 22,
                TRAPNET: 23,
                WATERMARK: 24,
                THREED: 25,
                REDACT: 26
              };
              exports2.AnnotationType = AnnotationType;
              const AnnotationStateModelType = {
                MARKED: "Marked",
                REVIEW: "Review"
              };
              exports2.AnnotationStateModelType = AnnotationStateModelType;
              const AnnotationMarkedState = {
                MARKED: "Marked",
                UNMARKED: "Unmarked"
              };
              exports2.AnnotationMarkedState = AnnotationMarkedState;
              const AnnotationReviewState = {
                ACCEPTED: "Accepted",
                REJECTED: "Rejected",
                CANCELLED: "Cancelled",
                COMPLETED: "Completed",
                NONE: "None"
              };
              exports2.AnnotationReviewState = AnnotationReviewState;
              const AnnotationReplyType = {
                GROUP: "Group",
                REPLY: "R"
              };
              exports2.AnnotationReplyType = AnnotationReplyType;
              const AnnotationFlag = {
                INVISIBLE: 1,
                HIDDEN: 2,
                PRINT: 4,
                NOZOOM: 8,
                NOROTATE: 16,
                NOVIEW: 32,
                READONLY: 64,
                LOCKED: 128,
                TOGGLENOVIEW: 256,
                LOCKEDCONTENTS: 512
              };
              exports2.AnnotationFlag = AnnotationFlag;
              const AnnotationFieldFlag = {
                READONLY: 1,
                REQUIRED: 2,
                NOEXPORT: 4,
                MULTILINE: 4096,
                PASSWORD: 8192,
                NOTOGGLETOOFF: 16384,
                RADIO: 32768,
                PUSHBUTTON: 65536,
                COMBO: 131072,
                EDIT: 262144,
                SORT: 524288,
                FILESELECT: 1048576,
                MULTISELECT: 2097152,
                DONOTSPELLCHECK: 4194304,
                DONOTSCROLL: 8388608,
                COMB: 16777216,
                RICHTEXT: 33554432,
                RADIOSINUNISON: 33554432,
                COMMITONSELCHANGE: 67108864
              };
              exports2.AnnotationFieldFlag = AnnotationFieldFlag;
              const AnnotationBorderStyleType = {
                SOLID: 1,
                DASHED: 2,
                BEVELED: 3,
                INSET: 4,
                UNDERLINE: 5
              };
              exports2.AnnotationBorderStyleType = AnnotationBorderStyleType;
              const AnnotationActionEventType = {
                E: "Mouse Enter",
                X: "Mouse Exit",
                D: "Mouse Down",
                U: "Mouse Up",
                Fo: "Focus",
                Bl: "Blur",
                PO: "PageOpen",
                PC: "PageClose",
                PV: "PageVisible",
                PI: "PageInvisible",
                K: "Keystroke",
                F: "Format",
                V: "Validate",
                C: "Calculate"
              };
              exports2.AnnotationActionEventType = AnnotationActionEventType;
              const DocumentActionEventType = {
                WC: "WillClose",
                WS: "WillSave",
                DS: "DidSave",
                WP: "WillPrint",
                DP: "DidPrint"
              };
              exports2.DocumentActionEventType = DocumentActionEventType;
              const PageActionEventType = {
                O: "PageOpen",
                C: "PageClose"
              };
              exports2.PageActionEventType = PageActionEventType;
              const StreamType = {
                UNKNOWN: "UNKNOWN",
                FLATE: "FLATE",
                LZW: "LZW",
                DCT: "DCT",
                JPX: "JPX",
                JBIG: "JBIG",
                A85: "A85",
                AHX: "AHX",
                CCF: "CCF",
                RLX: "RLX"
              };
              exports2.StreamType = StreamType;
              const FontType = {
                UNKNOWN: "UNKNOWN",
                TYPE1: "TYPE1",
                TYPE1STANDARD: "TYPE1STANDARD",
                TYPE1C: "TYPE1C",
                CIDFONTTYPE0: "CIDFONTTYPE0",
                CIDFONTTYPE0C: "CIDFONTTYPE0C",
                TRUETYPE: "TRUETYPE",
                CIDFONTTYPE2: "CIDFONTTYPE2",
                TYPE3: "TYPE3",
                OPENTYPE: "OPENTYPE",
                TYPE0: "TYPE0",
                MMTYPE1: "MMTYPE1"
              };
              exports2.FontType = FontType;
              const VerbosityLevel = {
                ERRORS: 0,
                WARNINGS: 1,
                INFOS: 5
              };
              exports2.VerbosityLevel = VerbosityLevel;
              const CMapCompressionType = {
                NONE: 0,
                BINARY: 1,
                STREAM: 2
              };
              exports2.CMapCompressionType = CMapCompressionType;
              const OPS = {
                dependency: 1,
                setLineWidth: 2,
                setLineCap: 3,
                setLineJoin: 4,
                setMiterLimit: 5,
                setDash: 6,
                setRenderingIntent: 7,
                setFlatness: 8,
                setGState: 9,
                save: 10,
                restore: 11,
                transform: 12,
                moveTo: 13,
                lineTo: 14,
                curveTo: 15,
                curveTo2: 16,
                curveTo3: 17,
                closePath: 18,
                rectangle: 19,
                stroke: 20,
                closeStroke: 21,
                fill: 22,
                eoFill: 23,
                fillStroke: 24,
                eoFillStroke: 25,
                closeFillStroke: 26,
                closeEOFillStroke: 27,
                endPath: 28,
                clip: 29,
                eoClip: 30,
                beginText: 31,
                endText: 32,
                setCharSpacing: 33,
                setWordSpacing: 34,
                setHScale: 35,
                setLeading: 36,
                setFont: 37,
                setTextRenderingMode: 38,
                setTextRise: 39,
                moveText: 40,
                setLeadingMoveText: 41,
                setTextMatrix: 42,
                nextLine: 43,
                showText: 44,
                showSpacedText: 45,
                nextLineShowText: 46,
                nextLineSetSpacingShowText: 47,
                setCharWidth: 48,
                setCharWidthAndBounds: 49,
                setStrokeColorSpace: 50,
                setFillColorSpace: 51,
                setStrokeColor: 52,
                setStrokeColorN: 53,
                setFillColor: 54,
                setFillColorN: 55,
                setStrokeGray: 56,
                setFillGray: 57,
                setStrokeRGBColor: 58,
                setFillRGBColor: 59,
                setStrokeCMYKColor: 60,
                setFillCMYKColor: 61,
                shadingFill: 62,
                beginInlineImage: 63,
                beginImageData: 64,
                endInlineImage: 65,
                paintXObject: 66,
                markPoint: 67,
                markPointProps: 68,
                beginMarkedContent: 69,
                beginMarkedContentProps: 70,
                endMarkedContent: 71,
                beginCompat: 72,
                endCompat: 73,
                paintFormXObjectBegin: 74,
                paintFormXObjectEnd: 75,
                beginGroup: 76,
                endGroup: 77,
                beginAnnotations: 78,
                endAnnotations: 79,
                beginAnnotation: 80,
                endAnnotation: 81,
                paintJpegXObject: 82,
                paintImageMaskXObject: 83,
                paintImageMaskXObjectGroup: 84,
                paintImageXObject: 85,
                paintInlineImageXObject: 86,
                paintInlineImageXObjectGroup: 87,
                paintImageXObjectRepeat: 88,
                paintImageMaskXObjectRepeat: 89,
                paintSolidColorImageMask: 90,
                constructPath: 91
              };
              exports2.OPS = OPS;
              const UNSUPPORTED_FEATURES = {
                unknown: "unknown",
                forms: "forms",
                javaScript: "javaScript",
                signatures: "signatures",
                smask: "smask",
                shadingPattern: "shadingPattern",
                font: "font",
                errorTilingPattern: "errorTilingPattern",
                errorExtGState: "errorExtGState",
                errorXObject: "errorXObject",
                errorFontLoadType3: "errorFontLoadType3",
                errorFontState: "errorFontState",
                errorFontMissing: "errorFontMissing",
                errorFontTranslate: "errorFontTranslate",
                errorColorSpace: "errorColorSpace",
                errorOperatorList: "errorOperatorList",
                errorFontToUnicode: "errorFontToUnicode",
                errorFontLoadNative: "errorFontLoadNative",
                errorFontBuildPath: "errorFontBuildPath",
                errorFontGetPath: "errorFontGetPath",
                errorMarkedContent: "errorMarkedContent",
                errorContentSubStream: "errorContentSubStream"
              };
              exports2.UNSUPPORTED_FEATURES = UNSUPPORTED_FEATURES;
              const PasswordResponses = {
                NEED_PASSWORD: 1,
                INCORRECT_PASSWORD: 2
              };
              exports2.PasswordResponses = PasswordResponses;
              let verbosity = VerbosityLevel.WARNINGS;
              function setVerbosityLevel(level) {
                if (Number.isInteger(level)) {
                  verbosity = level;
                }
              }
              function getVerbosityLevel() {
                return verbosity;
              }
              function info(msg) {
                if (verbosity >= VerbosityLevel.INFOS) {
                  console.log(`Info: ${msg}`);
                }
              }
              function warn(msg) {
                if (verbosity >= VerbosityLevel.WARNINGS) {
                  console.log(`Warning: ${msg}`);
                }
              }
              function unreachable(msg) {
                throw new Error(msg);
              }
              function assert(cond, msg) {
                if (!cond) {
                  unreachable(msg);
                }
              }
              function _isValidProtocol(url) {
                if (!url) {
                  return false;
                }
                switch (url.protocol) {
                  case "http:":
                  case "https:":
                  case "ftp:":
                  case "mailto:":
                  case "tel:":
                    return true;
                  default:
                    return false;
                }
              }
              function createValidAbsoluteUrl(url) {
                let baseUrl = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
                let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
                if (!url) {
                  return null;
                }
                try {
                  if (options && typeof url === "string") {
                    if (options.addDefaultProtocol && url.startsWith("www.")) {
                      const dots = url.match(/\./g);
                      if (dots && dots.length >= 2) {
                        url = `http://${url}`;
                      }
                    }
                    if (options.tryConvertEncoding) {
                      try {
                        url = stringToUTF8String(url);
                      } catch (ex) {
                      }
                    }
                  }
                  const absoluteUrl = baseUrl ? new URL(url, baseUrl) : new URL(url);
                  if (_isValidProtocol(absoluteUrl)) {
                    return absoluteUrl;
                  }
                } catch (ex) {
                }
                return null;
              }
              function shadow(obj, prop, value) {
                Object.defineProperty(obj, prop, {
                  value,
                  enumerable: true,
                  configurable: true,
                  writable: false
                });
                return value;
              }
              const BaseException = function BaseExceptionClosure() {
                function BaseException2(message, name) {
                  if (this.constructor === BaseException2) {
                    unreachable("Cannot initialize BaseException.");
                  }
                  this.message = message;
                  this.name = name;
                }
                BaseException2.prototype = new Error();
                BaseException2.constructor = BaseException2;
                return BaseException2;
              }();
              exports2.BaseException = BaseException;
              class PasswordException extends BaseException {
                constructor(msg, code) {
                  super(msg, "PasswordException");
                  this.code = code;
                }
              }
              exports2.PasswordException = PasswordException;
              class UnknownErrorException extends BaseException {
                constructor(msg, details) {
                  super(msg, "UnknownErrorException");
                  this.details = details;
                }
              }
              exports2.UnknownErrorException = UnknownErrorException;
              class InvalidPDFException extends BaseException {
                constructor(msg) {
                  super(msg, "InvalidPDFException");
                }
              }
              exports2.InvalidPDFException = InvalidPDFException;
              class MissingPDFException extends BaseException {
                constructor(msg) {
                  super(msg, "MissingPDFException");
                }
              }
              exports2.MissingPDFException = MissingPDFException;
              class UnexpectedResponseException extends BaseException {
                constructor(msg, status) {
                  super(msg, "UnexpectedResponseException");
                  this.status = status;
                }
              }
              exports2.UnexpectedResponseException = UnexpectedResponseException;
              class FormatError extends BaseException {
                constructor(msg) {
                  super(msg, "FormatError");
                }
              }
              exports2.FormatError = FormatError;
              class AbortException extends BaseException {
                constructor(msg) {
                  super(msg, "AbortException");
                }
              }
              exports2.AbortException = AbortException;
              function bytesToString(bytes) {
                if (typeof bytes !== "object" || bytes === null || bytes.length === void 0) {
                  unreachable("Invalid argument for bytesToString");
                }
                const length = bytes.length;
                const MAX_ARGUMENT_COUNT = 8192;
                if (length < MAX_ARGUMENT_COUNT) {
                  return String.fromCharCode.apply(null, bytes);
                }
                const strBuf = [];
                for (let i = 0; i < length; i += MAX_ARGUMENT_COUNT) {
                  const chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length);
                  const chunk = bytes.subarray(i, chunkEnd);
                  strBuf.push(String.fromCharCode.apply(null, chunk));
                }
                return strBuf.join("");
              }
              function stringToBytes(str) {
                if (typeof str !== "string") {
                  unreachable("Invalid argument for stringToBytes");
                }
                const length = str.length;
                const bytes = new Uint8Array(length);
                for (let i = 0; i < length; ++i) {
                  bytes[i] = str.charCodeAt(i) & 255;
                }
                return bytes;
              }
              function arrayByteLength(arr) {
                if (arr.length !== void 0) {
                  return arr.length;
                }
                if (arr.byteLength !== void 0) {
                  return arr.byteLength;
                }
                unreachable("Invalid argument for arrayByteLength");
              }
              function arraysToBytes(arr) {
                const length = arr.length;
                if (length === 1 && arr[0] instanceof Uint8Array) {
                  return arr[0];
                }
                let resultLength = 0;
                for (let i = 0; i < length; i++) {
                  resultLength += arrayByteLength(arr[i]);
                }
                let pos = 0;
                const data = new Uint8Array(resultLength);
                for (let i = 0; i < length; i++) {
                  let item = arr[i];
                  if (!(item instanceof Uint8Array)) {
                    if (typeof item === "string") {
                      item = stringToBytes(item);
                    } else {
                      item = new Uint8Array(item);
                    }
                  }
                  const itemLength = item.byteLength;
                  data.set(item, pos);
                  pos += itemLength;
                }
                return data;
              }
              function string32(value) {
                return String.fromCharCode(value >> 24 & 255, value >> 16 & 255, value >> 8 & 255, value & 255);
              }
              function objectSize(obj) {
                return Object.keys(obj).length;
              }
              function objectFromMap(map) {
                const obj = /* @__PURE__ */ Object.create(null);
                for (const [key, value] of map) {
                  obj[key] = value;
                }
                return obj;
              }
              function isLittleEndian() {
                const buffer8 = new Uint8Array(4);
                buffer8[0] = 1;
                const view32 = new Uint32Array(buffer8.buffer, 0, 1);
                return view32[0] === 1;
              }
              function isEvalSupported() {
                try {
                  new Function("");
                  return true;
                } catch (e) {
                  return false;
                }
              }
              class FeatureTest {
                static get isLittleEndian() {
                  return shadow(this, "isLittleEndian", isLittleEndian());
                }
                static get isEvalSupported() {
                  return shadow(this, "isEvalSupported", isEvalSupported());
                }
                static get isOffscreenCanvasSupported() {
                  return shadow(this, "isOffscreenCanvasSupported", typeof OffscreenCanvas !== "undefined");
                }
              }
              exports2.FeatureTest = FeatureTest;
              const hexNumbers = [...Array(256).keys()].map((n) => n.toString(16).padStart(2, "0"));
              class Util {
                static makeHexColor(r2, g, b) {
                  return `#${hexNumbers[r2]}${hexNumbers[g]}${hexNumbers[b]}`;
                }
                static scaleMinMax(transform, minMax) {
                  let temp;
                  if (transform[0]) {
                    if (transform[0] < 0) {
                      temp = minMax[0];
                      minMax[0] = minMax[1];
                      minMax[1] = temp;
                    }
                    minMax[0] *= transform[0];
                    minMax[1] *= transform[0];
                    if (transform[3] < 0) {
                      temp = minMax[2];
                      minMax[2] = minMax[3];
                      minMax[3] = temp;
                    }
                    minMax[2] *= transform[3];
                    minMax[3] *= transform[3];
                  } else {
                    temp = minMax[0];
                    minMax[0] = minMax[2];
                    minMax[2] = temp;
                    temp = minMax[1];
                    minMax[1] = minMax[3];
                    minMax[3] = temp;
                    if (transform[1] < 0) {
                      temp = minMax[2];
                      minMax[2] = minMax[3];
                      minMax[3] = temp;
                    }
                    minMax[2] *= transform[1];
                    minMax[3] *= transform[1];
                    if (transform[2] < 0) {
                      temp = minMax[0];
                      minMax[0] = minMax[1];
                      minMax[1] = temp;
                    }
                    minMax[0] *= transform[2];
                    minMax[1] *= transform[2];
                  }
                  minMax[0] += transform[4];
                  minMax[1] += transform[4];
                  minMax[2] += transform[5];
                  minMax[3] += transform[5];
                }
                static transform(m1, m2) {
                  return [m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1], m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3], m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]];
                }
                static applyTransform(p, m) {
                  const xt = p[0] * m[0] + p[1] * m[2] + m[4];
                  const yt = p[0] * m[1] + p[1] * m[3] + m[5];
                  return [xt, yt];
                }
                static applyInverseTransform(p, m) {
                  const d = m[0] * m[3] - m[1] * m[2];
                  const xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d;
                  const yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d;
                  return [xt, yt];
                }
                static getAxialAlignedBoundingBox(r2, m) {
                  const p1 = Util.applyTransform(r2, m);
                  const p2 = Util.applyTransform(r2.slice(2, 4), m);
                  const p3 = Util.applyTransform([r2[0], r2[3]], m);
                  const p4 = Util.applyTransform([r2[2], r2[1]], m);
                  return [Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1])];
                }
                static inverseTransform(m) {
                  const d = m[0] * m[3] - m[1] * m[2];
                  return [m[3] / d, -m[1] / d, -m[2] / d, m[0] / d, (m[2] * m[5] - m[4] * m[3]) / d, (m[4] * m[1] - m[5] * m[0]) / d];
                }
                static apply3dTransform(m, v) {
                  return [m[0] * v[0] + m[1] * v[1] + m[2] * v[2], m[3] * v[0] + m[4] * v[1] + m[5] * v[2], m[6] * v[0] + m[7] * v[1] + m[8] * v[2]];
                }
                static singularValueDecompose2dScale(m) {
                  const transpose = [m[0], m[2], m[1], m[3]];
                  const a = m[0] * transpose[0] + m[1] * transpose[2];
                  const b = m[0] * transpose[1] + m[1] * transpose[3];
                  const c = m[2] * transpose[0] + m[3] * transpose[2];
                  const d = m[2] * transpose[1] + m[3] * transpose[3];
                  const first = (a + d) / 2;
                  const second = Math.sqrt((a + d) ** 2 - 4 * (a * d - c * b)) / 2;
                  const sx = first + second || 1;
                  const sy = first - second || 1;
                  return [Math.sqrt(sx), Math.sqrt(sy)];
                }
                static normalizeRect(rect) {
                  const r2 = rect.slice(0);
                  if (rect[0] > rect[2]) {
                    r2[0] = rect[2];
                    r2[2] = rect[0];
                  }
                  if (rect[1] > rect[3]) {
                    r2[1] = rect[3];
                    r2[3] = rect[1];
                  }
                  return r2;
                }
                static intersect(rect1, rect2) {
                  const xLow = Math.max(Math.min(rect1[0], rect1[2]), Math.min(rect2[0], rect2[2]));
                  const xHigh = Math.min(Math.max(rect1[0], rect1[2]), Math.max(rect2[0], rect2[2]));
                  if (xLow > xHigh) {
                    return null;
                  }
                  const yLow = Math.max(Math.min(rect1[1], rect1[3]), Math.min(rect2[1], rect2[3]));
                  const yHigh = Math.min(Math.max(rect1[1], rect1[3]), Math.max(rect2[1], rect2[3]));
                  if (yLow > yHigh) {
                    return null;
                  }
                  return [xLow, yLow, xHigh, yHigh];
                }
                static bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3) {
                  const tvalues = [], bounds = [[], []];
                  let a, b, c, t, t1, t2, b2ac, sqrtb2ac;
                  for (let i = 0; i < 2; ++i) {
                    if (i === 0) {
                      b = 6 * x0 - 12 * x1 + 6 * x2;
                      a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
                      c = 3 * x1 - 3 * x0;
                    } else {
                      b = 6 * y0 - 12 * y1 + 6 * y2;
                      a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
                      c = 3 * y1 - 3 * y0;
                    }
                    if (Math.abs(a) < 1e-12) {
                      if (Math.abs(b) < 1e-12) {
                        continue;
                      }
                      t = -c / b;
                      if (0 < t && t < 1) {
                        tvalues.push(t);
                      }
                      continue;
                    }
                    b2ac = b * b - 4 * c * a;
                    sqrtb2ac = Math.sqrt(b2ac);
                    if (b2ac < 0) {
                      continue;
                    }
                    t1 = (-b + sqrtb2ac) / (2 * a);
                    if (0 < t1 && t1 < 1) {
                      tvalues.push(t1);
                    }
                    t2 = (-b - sqrtb2ac) / (2 * a);
                    if (0 < t2 && t2 < 1) {
                      tvalues.push(t2);
                    }
                  }
                  let j = tvalues.length, mt;
                  const jlen = j;
                  while (j--) {
                    t = tvalues[j];
                    mt = 1 - t;
                    bounds[0][j] = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;
                    bounds[1][j] = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;
                  }
                  bounds[0][jlen] = x0;
                  bounds[1][jlen] = y0;
                  bounds[0][jlen + 1] = x3;
                  bounds[1][jlen + 1] = y3;
                  bounds[0].length = bounds[1].length = jlen + 2;
                  return [Math.min(...bounds[0]), Math.min(...bounds[1]), Math.max(...bounds[0]), Math.max(...bounds[1])];
                }
              }
              exports2.Util = Util;
              const PDFStringTranslateTable = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 728, 711, 710, 729, 733, 731, 730, 732, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8226, 8224, 8225, 8230, 8212, 8211, 402, 8260, 8249, 8250, 8722, 8240, 8222, 8220, 8221, 8216, 8217, 8218, 8482, 64257, 64258, 321, 338, 352, 376, 381, 305, 322, 339, 353, 382, 0, 8364];
              function stringToPDFString(str) {
                if (str[0] >= "ï") {
                  let encoding;
                  if (str[0] === "þ" && str[1] === "ÿ") {
                    encoding = "utf-16be";
                  } else if (str[0] === "ÿ" && str[1] === "þ") {
                    encoding = "utf-16le";
                  } else if (str[0] === "ï" && str[1] === "»" && str[2] === "¿") {
                    encoding = "utf-8";
                  }
                  if (encoding) {
                    try {
                      const decoder = new TextDecoder(encoding, {
                        fatal: true
                      });
                      const buffer = stringToBytes(str);
                      return decoder.decode(buffer);
                    } catch (ex) {
                      warn(`stringToPDFString: "${ex}".`);
                    }
                  }
                }
                const strBuf = [];
                for (let i = 0, ii = str.length; i < ii; i++) {
                  const code = PDFStringTranslateTable[str.charCodeAt(i)];
                  strBuf.push(code ? String.fromCharCode(code) : str.charAt(i));
                }
                return strBuf.join("");
              }
              function escapeString(str) {
                return str.replace(/([()\\\n\r])/g, (match) => {
                  if (match === "\n") {
                    return "\\n";
                  } else if (match === "\r") {
                    return "\\r";
                  }
                  return `\\${match}`;
                });
              }
              function isAscii(str) {
                return /^[\x00-\x7F]*$/.test(str);
              }
              function stringToUTF16BEString(str) {
                const buf = ["þÿ"];
                for (let i = 0, ii = str.length; i < ii; i++) {
                  const char = str.charCodeAt(i);
                  buf.push(String.fromCharCode(char >> 8 & 255), String.fromCharCode(char & 255));
                }
                return buf.join("");
              }
              function stringToUTF8String(str) {
                return decodeURIComponent(escape(str));
              }
              function utf8StringToString(str) {
                return unescape(encodeURIComponent(str));
              }
              function isArrayBuffer(v) {
                return typeof v === "object" && v !== null && v.byteLength !== void 0;
              }
              function isArrayEqual(arr1, arr2) {
                if (arr1.length !== arr2.length) {
                  return false;
                }
                for (let i = 0, ii = arr1.length; i < ii; i++) {
                  if (arr1[i] !== arr2[i]) {
                    return false;
                  }
                }
                return true;
              }
              function getModificationDate() {
                let date = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : /* @__PURE__ */ new Date();
                const buffer = [date.getUTCFullYear().toString(), (date.getUTCMonth() + 1).toString().padStart(2, "0"), date.getUTCDate().toString().padStart(2, "0"), date.getUTCHours().toString().padStart(2, "0"), date.getUTCMinutes().toString().padStart(2, "0"), date.getUTCSeconds().toString().padStart(2, "0")];
                return buffer.join("");
              }
              function createPromiseCapability() {
                const capability = /* @__PURE__ */ Object.create(null);
                let isSettled = false;
                Object.defineProperty(capability, "settled", {
                  get() {
                    return isSettled;
                  }
                });
                capability.promise = new Promise(function(resolve, reject) {
                  capability.resolve = function(data) {
                    isSettled = true;
                    resolve(data);
                  };
                  capability.reject = function(reason) {
                    isSettled = true;
                    reject(reason);
                  };
                });
                return capability;
              }
            },
            /* 2 */
            /***/
            (__unused_webpack_module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              "use strict";
              var _is_node2 = __w_pdfjs_require__2(3);
              if (!globalThis._pdfjsCompatibilityChecked) {
                globalThis._pdfjsCompatibilityChecked = true;
                (function checkNodeBtoa() {
                  if (globalThis.btoa || !_is_node2.isNodeJS) {
                    return;
                  }
                  globalThis.btoa = function(chars) {
                    return Buffer.from(chars, "binary").toString("base64");
                  };
                })();
                (function checkNodeAtob() {
                  if (globalThis.atob || !_is_node2.isNodeJS) {
                    return;
                  }
                  globalThis.atob = function(input) {
                    return Buffer.from(input, "base64").toString("binary");
                  };
                })();
                (function checkDOMMatrix() {
                  if (globalThis.DOMMatrix || !_is_node2.isNodeJS) {
                    return;
                  }
                  globalThis.DOMMatrix = require_dommatrix();
                })();
                (function checkReadableStream() {
                  if (globalThis.ReadableStream || !_is_node2.isNodeJS) {
                    return;
                  }
                  globalThis.ReadableStream = require_ponyfill().ReadableStream;
                })();
                (function checkArrayAt() {
                  if (Array.prototype.at) {
                    return;
                  }
                  __w_pdfjs_require__2(4);
                })();
                (function checkTypedArrayAt() {
                  if (Uint8Array.prototype.at) {
                    return;
                  }
                  __w_pdfjs_require__2(76);
                })();
                (function checkStructuredClone() {
                  if (globalThis.structuredClone) {
                    return;
                  }
                  __w_pdfjs_require__2(86);
                })();
              }
            },
            /* 3 */
            /***/
            (__unused_webpack_module2, exports2) => {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.isNodeJS = void 0;
              const isNodeJS = typeof process === "object" && process + "" === "[object process]" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== "browser");
              exports2.isNodeJS = isNodeJS;
            },
            /* 4 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              __w_pdfjs_require__2(5);
              var entryUnbind = __w_pdfjs_require__2(75);
              module2.exports = entryUnbind("Array", "at");
            },
            /* 5 */
            /***/
            (__unused_webpack_module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              "use strict";
              var $ = __w_pdfjs_require__2(6);
              var toObject = __w_pdfjs_require__2(41);
              var lengthOfArrayLike = __w_pdfjs_require__2(65);
              var toIntegerOrInfinity = __w_pdfjs_require__2(63);
              var addToUnscopables = __w_pdfjs_require__2(70);
              $({
                target: "Array",
                proto: true
              }, {
                at: function at(index) {
                  var O = toObject(this);
                  var len = lengthOfArrayLike(O);
                  var relativeIndex = toIntegerOrInfinity(index);
                  var k = relativeIndex >= 0 ? relativeIndex : len + relativeIndex;
                  return k < 0 || k >= len ? void 0 : O[k];
                }
              });
              addToUnscopables("at");
            },
            /* 6 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var global2 = __w_pdfjs_require__2(7);
              var getOwnPropertyDescriptor = __w_pdfjs_require__2(8).f;
              var createNonEnumerableProperty = __w_pdfjs_require__2(45);
              var defineBuiltIn = __w_pdfjs_require__2(49);
              var defineGlobalProperty = __w_pdfjs_require__2(39);
              var copyConstructorProperties = __w_pdfjs_require__2(57);
              var isForced = __w_pdfjs_require__2(69);
              module2.exports = function(options, source) {
                var TARGET = options.target;
                var GLOBAL = options.global;
                var STATIC = options.stat;
                var FORCED, target, key, targetProperty, sourceProperty, descriptor;
                if (GLOBAL) {
                  target = global2;
                } else if (STATIC) {
                  target = global2[TARGET] || defineGlobalProperty(TARGET, {});
                } else {
                  target = (global2[TARGET] || {}).prototype;
                }
                if (target)
                  for (key in source) {
                    sourceProperty = source[key];
                    if (options.dontCallGetSet) {
                      descriptor = getOwnPropertyDescriptor(target, key);
                      targetProperty = descriptor && descriptor.value;
                    } else
                      targetProperty = target[key];
                    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options.forced);
                    if (!FORCED && targetProperty !== void 0) {
                      if (typeof sourceProperty == typeof targetProperty)
                        continue;
                      copyConstructorProperties(sourceProperty, targetProperty);
                    }
                    if (options.sham || targetProperty && targetProperty.sham) {
                      createNonEnumerableProperty(sourceProperty, "sham", true);
                    }
                    defineBuiltIn(target, key, sourceProperty, options);
                  }
              };
            },
            /* 7 */
            /***/
            (module2) => {
              var check = function(it) {
                return it && it.Math == Math && it;
              };
              module2.exports = check(typeof globalThis == "object" && globalThis) || check(typeof window == "object" && window) || check(typeof self == "object" && self) || check(typeof global == "object" && global) || /* @__PURE__ */ function() {
                return this;
              }() || Function("return this")();
            },
            /* 8 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              var DESCRIPTORS = __w_pdfjs_require__2(9);
              var call = __w_pdfjs_require__2(11);
              var propertyIsEnumerableModule = __w_pdfjs_require__2(13);
              var createPropertyDescriptor = __w_pdfjs_require__2(14);
              var toIndexedObject = __w_pdfjs_require__2(15);
              var toPropertyKey = __w_pdfjs_require__2(20);
              var hasOwn = __w_pdfjs_require__2(40);
              var IE8_DOM_DEFINE = __w_pdfjs_require__2(43);
              var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
              exports2.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
                O = toIndexedObject(O);
                P = toPropertyKey(P);
                if (IE8_DOM_DEFINE)
                  try {
                    return $getOwnPropertyDescriptor(O, P);
                  } catch (error) {
                  }
                if (hasOwn(O, P))
                  return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);
              };
            },
            /* 9 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var fails = __w_pdfjs_require__2(10);
              module2.exports = !fails(function() {
                return Object.defineProperty({}, 1, {
                  get: function() {
                    return 7;
                  }
                })[1] != 7;
              });
            },
            /* 10 */
            /***/
            (module2) => {
              module2.exports = function(exec) {
                try {
                  return !!exec();
                } catch (error) {
                  return true;
                }
              };
            },
            /* 11 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var NATIVE_BIND = __w_pdfjs_require__2(12);
              var call = Function.prototype.call;
              module2.exports = NATIVE_BIND ? call.bind(call) : function() {
                return call.apply(call, arguments);
              };
            },
            /* 12 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var fails = __w_pdfjs_require__2(10);
              module2.exports = !fails(function() {
                var test = (function() {
                }).bind();
                return typeof test != "function" || test.hasOwnProperty("prototype");
              });
            },
            /* 13 */
            /***/
            (__unused_webpack_module2, exports2) => {
              "use strict";
              var $propertyIsEnumerable = {}.propertyIsEnumerable;
              var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
              var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);
              exports2.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
                var descriptor = getOwnPropertyDescriptor(this, V);
                return !!descriptor && descriptor.enumerable;
              } : $propertyIsEnumerable;
            },
            /* 14 */
            /***/
            (module2) => {
              module2.exports = function(bitmap, value) {
                return {
                  enumerable: !(bitmap & 1),
                  configurable: !(bitmap & 2),
                  writable: !(bitmap & 4),
                  value
                };
              };
            },
            /* 15 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var IndexedObject = __w_pdfjs_require__2(16);
              var requireObjectCoercible = __w_pdfjs_require__2(19);
              module2.exports = function(it) {
                return IndexedObject(requireObjectCoercible(it));
              };
            },
            /* 16 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var uncurryThis = __w_pdfjs_require__2(17);
              var fails = __w_pdfjs_require__2(10);
              var classof = __w_pdfjs_require__2(18);
              var $Object = Object;
              var split = uncurryThis("".split);
              module2.exports = fails(function() {
                return !$Object("z").propertyIsEnumerable(0);
              }) ? function(it) {
                return classof(it) == "String" ? split(it, "") : $Object(it);
              } : $Object;
            },
            /* 17 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var NATIVE_BIND = __w_pdfjs_require__2(12);
              var FunctionPrototype = Function.prototype;
              var bind = FunctionPrototype.bind;
              var call = FunctionPrototype.call;
              var uncurryThis = NATIVE_BIND && bind.bind(call, call);
              module2.exports = NATIVE_BIND ? function(fn) {
                return fn && uncurryThis(fn);
              } : function(fn) {
                return fn && function() {
                  return call.apply(fn, arguments);
                };
              };
            },
            /* 18 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var uncurryThis = __w_pdfjs_require__2(17);
              var toString = uncurryThis({}.toString);
              var stringSlice = uncurryThis("".slice);
              module2.exports = function(it) {
                return stringSlice(toString(it), 8, -1);
              };
            },
            /* 19 */
            /***/
            (module2) => {
              var $TypeError = TypeError;
              module2.exports = function(it) {
                if (it == void 0)
                  throw $TypeError("Can't call method on " + it);
                return it;
              };
            },
            /* 20 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var toPrimitive = __w_pdfjs_require__2(21);
              var isSymbol = __w_pdfjs_require__2(24);
              module2.exports = function(argument) {
                var key = toPrimitive(argument, "string");
                return isSymbol(key) ? key : key + "";
              };
            },
            /* 21 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var call = __w_pdfjs_require__2(11);
              var isObject = __w_pdfjs_require__2(22);
              var isSymbol = __w_pdfjs_require__2(24);
              var getMethod = __w_pdfjs_require__2(31);
              var ordinaryToPrimitive = __w_pdfjs_require__2(34);
              var wellKnownSymbol = __w_pdfjs_require__2(35);
              var $TypeError = TypeError;
              var TO_PRIMITIVE = wellKnownSymbol("toPrimitive");
              module2.exports = function(input, pref) {
                if (!isObject(input) || isSymbol(input))
                  return input;
                var exoticToPrim = getMethod(input, TO_PRIMITIVE);
                var result;
                if (exoticToPrim) {
                  if (pref === void 0)
                    pref = "default";
                  result = call(exoticToPrim, input, pref);
                  if (!isObject(result) || isSymbol(result))
                    return result;
                  throw $TypeError("Can't convert object to primitive value");
                }
                if (pref === void 0)
                  pref = "number";
                return ordinaryToPrimitive(input, pref);
              };
            },
            /* 22 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var isCallable = __w_pdfjs_require__2(23);
              module2.exports = function(it) {
                return typeof it == "object" ? it !== null : isCallable(it);
              };
            },
            /* 23 */
            /***/
            (module2) => {
              module2.exports = function(argument) {
                return typeof argument == "function";
              };
            },
            /* 24 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var getBuiltIn = __w_pdfjs_require__2(25);
              var isCallable = __w_pdfjs_require__2(23);
              var isPrototypeOf = __w_pdfjs_require__2(26);
              var USE_SYMBOL_AS_UID = __w_pdfjs_require__2(27);
              var $Object = Object;
              module2.exports = USE_SYMBOL_AS_UID ? function(it) {
                return typeof it == "symbol";
              } : function(it) {
                var $Symbol = getBuiltIn("Symbol");
                return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));
              };
            },
            /* 25 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var global2 = __w_pdfjs_require__2(7);
              var isCallable = __w_pdfjs_require__2(23);
              var aFunction = function(argument) {
                return isCallable(argument) ? argument : void 0;
              };
              module2.exports = function(namespace, method) {
                return arguments.length < 2 ? aFunction(global2[namespace]) : global2[namespace] && global2[namespace][method];
              };
            },
            /* 26 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var uncurryThis = __w_pdfjs_require__2(17);
              module2.exports = uncurryThis({}.isPrototypeOf);
            },
            /* 27 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var NATIVE_SYMBOL = __w_pdfjs_require__2(28);
              module2.exports = NATIVE_SYMBOL && !Symbol.sham && typeof Symbol.iterator == "symbol";
            },
            /* 28 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var V8_VERSION = __w_pdfjs_require__2(29);
              var fails = __w_pdfjs_require__2(10);
              module2.exports = !!Object.getOwnPropertySymbols && !fails(function() {
                var symbol = Symbol();
                return !String(symbol) || !(Object(symbol) instanceof Symbol) || !Symbol.sham && V8_VERSION && V8_VERSION < 41;
              });
            },
            /* 29 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var global2 = __w_pdfjs_require__2(7);
              var userAgent = __w_pdfjs_require__2(30);
              var process2 = global2.process;
              var Deno2 = global2.Deno;
              var versions = process2 && process2.versions || Deno2 && Deno2.version;
              var v8 = versions && versions.v8;
              var match, version2;
              if (v8) {
                match = v8.split(".");
                version2 = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
              }
              if (!version2 && userAgent) {
                match = userAgent.match(/Edge\/(\d+)/);
                if (!match || match[1] >= 74) {
                  match = userAgent.match(/Chrome\/(\d+)/);
                  if (match)
                    version2 = +match[1];
                }
              }
              module2.exports = version2;
            },
            /* 30 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var getBuiltIn = __w_pdfjs_require__2(25);
              module2.exports = getBuiltIn("navigator", "userAgent") || "";
            },
            /* 31 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var aCallable = __w_pdfjs_require__2(32);
              module2.exports = function(V, P) {
                var func = V[P];
                return func == null ? void 0 : aCallable(func);
              };
            },
            /* 32 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var isCallable = __w_pdfjs_require__2(23);
              var tryToString = __w_pdfjs_require__2(33);
              var $TypeError = TypeError;
              module2.exports = function(argument) {
                if (isCallable(argument))
                  return argument;
                throw $TypeError(tryToString(argument) + " is not a function");
              };
            },
            /* 33 */
            /***/
            (module2) => {
              var $String = String;
              module2.exports = function(argument) {
                try {
                  return $String(argument);
                } catch (error) {
                  return "Object";
                }
              };
            },
            /* 34 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var call = __w_pdfjs_require__2(11);
              var isCallable = __w_pdfjs_require__2(23);
              var isObject = __w_pdfjs_require__2(22);
              var $TypeError = TypeError;
              module2.exports = function(input, pref) {
                var fn, val;
                if (pref === "string" && isCallable(fn = input.toString) && !isObject(val = call(fn, input)))
                  return val;
                if (isCallable(fn = input.valueOf) && !isObject(val = call(fn, input)))
                  return val;
                if (pref !== "string" && isCallable(fn = input.toString) && !isObject(val = call(fn, input)))
                  return val;
                throw $TypeError("Can't convert object to primitive value");
              };
            },
            /* 35 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var global2 = __w_pdfjs_require__2(7);
              var shared = __w_pdfjs_require__2(36);
              var hasOwn = __w_pdfjs_require__2(40);
              var uid = __w_pdfjs_require__2(42);
              var NATIVE_SYMBOL = __w_pdfjs_require__2(28);
              var USE_SYMBOL_AS_UID = __w_pdfjs_require__2(27);
              var WellKnownSymbolsStore = shared("wks");
              var Symbol2 = global2.Symbol;
              var symbolFor = Symbol2 && Symbol2["for"];
              var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol2 : Symbol2 && Symbol2.withoutSetter || uid;
              module2.exports = function(name) {
                if (!hasOwn(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == "string")) {
                  var description = "Symbol." + name;
                  if (NATIVE_SYMBOL && hasOwn(Symbol2, name)) {
                    WellKnownSymbolsStore[name] = Symbol2[name];
                  } else if (USE_SYMBOL_AS_UID && symbolFor) {
                    WellKnownSymbolsStore[name] = symbolFor(description);
                  } else {
                    WellKnownSymbolsStore[name] = createWellKnownSymbol(description);
                  }
                }
                return WellKnownSymbolsStore[name];
              };
            },
            /* 36 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var IS_PURE = __w_pdfjs_require__2(37);
              var store = __w_pdfjs_require__2(38);
              (module2.exports = function(key, value) {
                return store[key] || (store[key] = value !== void 0 ? value : {});
              })("versions", []).push({
                version: "3.24.1",
                mode: IS_PURE ? "pure" : "global",
                copyright: "© 2014-2022 Denis Pushkarev (zloirock.ru)",
                license: "https://github.com/zloirock/core-js/blob/v3.24.1/LICENSE",
                source: "https://github.com/zloirock/core-js"
              });
            },
            /* 37 */
            /***/
            (module2) => {
              module2.exports = false;
            },
            /* 38 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var global2 = __w_pdfjs_require__2(7);
              var defineGlobalProperty = __w_pdfjs_require__2(39);
              var SHARED = "__core-js_shared__";
              var store = global2[SHARED] || defineGlobalProperty(SHARED, {});
              module2.exports = store;
            },
            /* 39 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var global2 = __w_pdfjs_require__2(7);
              var defineProperty = Object.defineProperty;
              module2.exports = function(key, value) {
                try {
                  defineProperty(global2, key, {
                    value,
                    configurable: true,
                    writable: true
                  });
                } catch (error) {
                  global2[key] = value;
                }
                return value;
              };
            },
            /* 40 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var uncurryThis = __w_pdfjs_require__2(17);
              var toObject = __w_pdfjs_require__2(41);
              var hasOwnProperty = uncurryThis({}.hasOwnProperty);
              module2.exports = Object.hasOwn || function hasOwn(it, key) {
                return hasOwnProperty(toObject(it), key);
              };
            },
            /* 41 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var requireObjectCoercible = __w_pdfjs_require__2(19);
              var $Object = Object;
              module2.exports = function(argument) {
                return $Object(requireObjectCoercible(argument));
              };
            },
            /* 42 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var uncurryThis = __w_pdfjs_require__2(17);
              var id = 0;
              var postfix = Math.random();
              var toString = uncurryThis(1 .toString);
              module2.exports = function(key) {
                return "Symbol(" + (key === void 0 ? "" : key) + ")_" + toString(++id + postfix, 36);
              };
            },
            /* 43 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var DESCRIPTORS = __w_pdfjs_require__2(9);
              var fails = __w_pdfjs_require__2(10);
              var createElement4 = __w_pdfjs_require__2(44);
              module2.exports = !DESCRIPTORS && !fails(function() {
                return Object.defineProperty(createElement4("div"), "a", {
                  get: function() {
                    return 7;
                  }
                }).a != 7;
              });
            },
            /* 44 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var global2 = __w_pdfjs_require__2(7);
              var isObject = __w_pdfjs_require__2(22);
              var document2 = global2.document;
              var EXISTS = isObject(document2) && isObject(document2.createElement);
              module2.exports = function(it) {
                return EXISTS ? document2.createElement(it) : {};
              };
            },
            /* 45 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var DESCRIPTORS = __w_pdfjs_require__2(9);
              var definePropertyModule = __w_pdfjs_require__2(46);
              var createPropertyDescriptor = __w_pdfjs_require__2(14);
              module2.exports = DESCRIPTORS ? function(object, key, value) {
                return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
              } : function(object, key, value) {
                object[key] = value;
                return object;
              };
            },
            /* 46 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              var DESCRIPTORS = __w_pdfjs_require__2(9);
              var IE8_DOM_DEFINE = __w_pdfjs_require__2(43);
              var V8_PROTOTYPE_DEFINE_BUG = __w_pdfjs_require__2(47);
              var anObject = __w_pdfjs_require__2(48);
              var toPropertyKey = __w_pdfjs_require__2(20);
              var $TypeError = TypeError;
              var $defineProperty = Object.defineProperty;
              var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
              var ENUMERABLE = "enumerable";
              var CONFIGURABLE = "configurable";
              var WRITABLE = "writable";
              exports2.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {
                anObject(O);
                P = toPropertyKey(P);
                anObject(Attributes);
                if (typeof O === "function" && P === "prototype" && "value" in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
                  var current = $getOwnPropertyDescriptor(O, P);
                  if (current && current[WRITABLE]) {
                    O[P] = Attributes.value;
                    Attributes = {
                      configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],
                      enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
                      writable: false
                    };
                  }
                }
                return $defineProperty(O, P, Attributes);
              } : $defineProperty : function defineProperty(O, P, Attributes) {
                anObject(O);
                P = toPropertyKey(P);
                anObject(Attributes);
                if (IE8_DOM_DEFINE)
                  try {
                    return $defineProperty(O, P, Attributes);
                  } catch (error) {
                  }
                if ("get" in Attributes || "set" in Attributes)
                  throw $TypeError("Accessors not supported");
                if ("value" in Attributes)
                  O[P] = Attributes.value;
                return O;
              };
            },
            /* 47 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var DESCRIPTORS = __w_pdfjs_require__2(9);
              var fails = __w_pdfjs_require__2(10);
              module2.exports = DESCRIPTORS && fails(function() {
                return Object.defineProperty(function() {
                }, "prototype", {
                  value: 42,
                  writable: false
                }).prototype != 42;
              });
            },
            /* 48 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var isObject = __w_pdfjs_require__2(22);
              var $String = String;
              var $TypeError = TypeError;
              module2.exports = function(argument) {
                if (isObject(argument))
                  return argument;
                throw $TypeError($String(argument) + " is not an object");
              };
            },
            /* 49 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var isCallable = __w_pdfjs_require__2(23);
              var definePropertyModule = __w_pdfjs_require__2(46);
              var makeBuiltIn = __w_pdfjs_require__2(50);
              var defineGlobalProperty = __w_pdfjs_require__2(39);
              module2.exports = function(O, key, value, options) {
                if (!options)
                  options = {};
                var simple = options.enumerable;
                var name = options.name !== void 0 ? options.name : key;
                if (isCallable(value))
                  makeBuiltIn(value, name, options);
                if (options.global) {
                  if (simple)
                    O[key] = value;
                  else
                    defineGlobalProperty(key, value);
                } else {
                  try {
                    if (!options.unsafe)
                      delete O[key];
                    else if (O[key])
                      simple = true;
                  } catch (error) {
                  }
                  if (simple)
                    O[key] = value;
                  else
                    definePropertyModule.f(O, key, {
                      value,
                      enumerable: false,
                      configurable: !options.nonConfigurable,
                      writable: !options.nonWritable
                    });
                }
                return O;
              };
            },
            /* 50 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var fails = __w_pdfjs_require__2(10);
              var isCallable = __w_pdfjs_require__2(23);
              var hasOwn = __w_pdfjs_require__2(40);
              var DESCRIPTORS = __w_pdfjs_require__2(9);
              var CONFIGURABLE_FUNCTION_NAME = __w_pdfjs_require__2(51).CONFIGURABLE;
              var inspectSource = __w_pdfjs_require__2(52);
              var InternalStateModule = __w_pdfjs_require__2(53);
              var enforceInternalState = InternalStateModule.enforce;
              var getInternalState = InternalStateModule.get;
              var defineProperty = Object.defineProperty;
              var CONFIGURABLE_LENGTH = DESCRIPTORS && !fails(function() {
                return defineProperty(function() {
                }, "length", { value: 8 }).length !== 8;
              });
              var TEMPLATE = String(String).split("String");
              var makeBuiltIn = module2.exports = function(value, name, options) {
                if (String(name).slice(0, 7) === "Symbol(") {
                  name = "[" + String(name).replace(/^Symbol\(([^)]*)\)/, "$1") + "]";
                }
                if (options && options.getter)
                  name = "get " + name;
                if (options && options.setter)
                  name = "set " + name;
                if (!hasOwn(value, "name") || CONFIGURABLE_FUNCTION_NAME && value.name !== name) {
                  if (DESCRIPTORS)
                    defineProperty(value, "name", {
                      value: name,
                      configurable: true
                    });
                  else
                    value.name = name;
                }
                if (CONFIGURABLE_LENGTH && options && hasOwn(options, "arity") && value.length !== options.arity) {
                  defineProperty(value, "length", { value: options.arity });
                }
                try {
                  if (options && hasOwn(options, "constructor") && options.constructor) {
                    if (DESCRIPTORS)
                      defineProperty(value, "prototype", { writable: false });
                  } else if (value.prototype)
                    value.prototype = void 0;
                } catch (error) {
                }
                var state = enforceInternalState(value);
                if (!hasOwn(state, "source")) {
                  state.source = TEMPLATE.join(typeof name == "string" ? name : "");
                }
                return value;
              };
              Function.prototype.toString = makeBuiltIn(function toString() {
                return isCallable(this) && getInternalState(this).source || inspectSource(this);
              }, "toString");
            },
            /* 51 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var DESCRIPTORS = __w_pdfjs_require__2(9);
              var hasOwn = __w_pdfjs_require__2(40);
              var FunctionPrototype = Function.prototype;
              var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;
              var EXISTS = hasOwn(FunctionPrototype, "name");
              var PROPER = EXISTS && (function something() {
              }).name === "something";
              var CONFIGURABLE = EXISTS && (!DESCRIPTORS || DESCRIPTORS && getDescriptor(FunctionPrototype, "name").configurable);
              module2.exports = {
                EXISTS,
                PROPER,
                CONFIGURABLE
              };
            },
            /* 52 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var uncurryThis = __w_pdfjs_require__2(17);
              var isCallable = __w_pdfjs_require__2(23);
              var store = __w_pdfjs_require__2(38);
              var functionToString = uncurryThis(Function.toString);
              if (!isCallable(store.inspectSource)) {
                store.inspectSource = function(it) {
                  return functionToString(it);
                };
              }
              module2.exports = store.inspectSource;
            },
            /* 53 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var NATIVE_WEAK_MAP = __w_pdfjs_require__2(54);
              var global2 = __w_pdfjs_require__2(7);
              var uncurryThis = __w_pdfjs_require__2(17);
              var isObject = __w_pdfjs_require__2(22);
              var createNonEnumerableProperty = __w_pdfjs_require__2(45);
              var hasOwn = __w_pdfjs_require__2(40);
              var shared = __w_pdfjs_require__2(38);
              var sharedKey = __w_pdfjs_require__2(55);
              var hiddenKeys = __w_pdfjs_require__2(56);
              var OBJECT_ALREADY_INITIALIZED = "Object already initialized";
              var TypeError2 = global2.TypeError;
              var WeakMap2 = global2.WeakMap;
              var set, get, has;
              var enforce = function(it) {
                return has(it) ? get(it) : set(it, {});
              };
              var getterFor = function(TYPE) {
                return function(it) {
                  var state;
                  if (!isObject(it) || (state = get(it)).type !== TYPE) {
                    throw TypeError2("Incompatible receiver, " + TYPE + " required");
                  }
                  return state;
                };
              };
              if (NATIVE_WEAK_MAP || shared.state) {
                var store = shared.state || (shared.state = new WeakMap2());
                var wmget = uncurryThis(store.get);
                var wmhas = uncurryThis(store.has);
                var wmset = uncurryThis(store.set);
                set = function(it, metadata) {
                  if (wmhas(store, it))
                    throw new TypeError2(OBJECT_ALREADY_INITIALIZED);
                  metadata.facade = it;
                  wmset(store, it, metadata);
                  return metadata;
                };
                get = function(it) {
                  return wmget(store, it) || {};
                };
                has = function(it) {
                  return wmhas(store, it);
                };
              } else {
                var STATE = sharedKey("state");
                hiddenKeys[STATE] = true;
                set = function(it, metadata) {
                  if (hasOwn(it, STATE))
                    throw new TypeError2(OBJECT_ALREADY_INITIALIZED);
                  metadata.facade = it;
                  createNonEnumerableProperty(it, STATE, metadata);
                  return metadata;
                };
                get = function(it) {
                  return hasOwn(it, STATE) ? it[STATE] : {};
                };
                has = function(it) {
                  return hasOwn(it, STATE);
                };
              }
              module2.exports = {
                set,
                get,
                has,
                enforce,
                getterFor
              };
            },
            /* 54 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var global2 = __w_pdfjs_require__2(7);
              var isCallable = __w_pdfjs_require__2(23);
              var inspectSource = __w_pdfjs_require__2(52);
              var WeakMap2 = global2.WeakMap;
              module2.exports = isCallable(WeakMap2) && /native code/.test(inspectSource(WeakMap2));
            },
            /* 55 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var shared = __w_pdfjs_require__2(36);
              var uid = __w_pdfjs_require__2(42);
              var keys = shared("keys");
              module2.exports = function(key) {
                return keys[key] || (keys[key] = uid(key));
              };
            },
            /* 56 */
            /***/
            (module2) => {
              module2.exports = {};
            },
            /* 57 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var hasOwn = __w_pdfjs_require__2(40);
              var ownKeys = __w_pdfjs_require__2(58);
              var getOwnPropertyDescriptorModule = __w_pdfjs_require__2(8);
              var definePropertyModule = __w_pdfjs_require__2(46);
              module2.exports = function(target, source, exceptions) {
                var keys = ownKeys(source);
                var defineProperty = definePropertyModule.f;
                var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
                for (var i = 0; i < keys.length; i++) {
                  var key = keys[i];
                  if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) {
                    defineProperty(target, key, getOwnPropertyDescriptor(source, key));
                  }
                }
              };
            },
            /* 58 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var getBuiltIn = __w_pdfjs_require__2(25);
              var uncurryThis = __w_pdfjs_require__2(17);
              var getOwnPropertyNamesModule = __w_pdfjs_require__2(59);
              var getOwnPropertySymbolsModule = __w_pdfjs_require__2(68);
              var anObject = __w_pdfjs_require__2(48);
              var concat = uncurryThis([].concat);
              module2.exports = getBuiltIn("Reflect", "ownKeys") || function ownKeys(it) {
                var keys = getOwnPropertyNamesModule.f(anObject(it));
                var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
                return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;
              };
            },
            /* 59 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              var internalObjectKeys = __w_pdfjs_require__2(60);
              var enumBugKeys = __w_pdfjs_require__2(67);
              var hiddenKeys = enumBugKeys.concat("length", "prototype");
              exports2.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
                return internalObjectKeys(O, hiddenKeys);
              };
            },
            /* 60 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var uncurryThis = __w_pdfjs_require__2(17);
              var hasOwn = __w_pdfjs_require__2(40);
              var toIndexedObject = __w_pdfjs_require__2(15);
              var indexOf = __w_pdfjs_require__2(61).indexOf;
              var hiddenKeys = __w_pdfjs_require__2(56);
              var push = uncurryThis([].push);
              module2.exports = function(object, names) {
                var O = toIndexedObject(object);
                var i = 0;
                var result = [];
                var key;
                for (key in O)
                  !hasOwn(hiddenKeys, key) && hasOwn(O, key) && push(result, key);
                while (names.length > i)
                  if (hasOwn(O, key = names[i++])) {
                    ~indexOf(result, key) || push(result, key);
                  }
                return result;
              };
            },
            /* 61 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var toIndexedObject = __w_pdfjs_require__2(15);
              var toAbsoluteIndex = __w_pdfjs_require__2(62);
              var lengthOfArrayLike = __w_pdfjs_require__2(65);
              var createMethod = function(IS_INCLUDES) {
                return function($this, el, fromIndex) {
                  var O = toIndexedObject($this);
                  var length = lengthOfArrayLike(O);
                  var index = toAbsoluteIndex(fromIndex, length);
                  var value;
                  if (IS_INCLUDES && el != el)
                    while (length > index) {
                      value = O[index++];
                      if (value != value)
                        return true;
                    }
                  else
                    for (; length > index; index++) {
                      if ((IS_INCLUDES || index in O) && O[index] === el)
                        return IS_INCLUDES || index || 0;
                    }
                  return !IS_INCLUDES && -1;
                };
              };
              module2.exports = {
                includes: createMethod(true),
                indexOf: createMethod(false)
              };
            },
            /* 62 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var toIntegerOrInfinity = __w_pdfjs_require__2(63);
              var max = Math.max;
              var min = Math.min;
              module2.exports = function(index, length) {
                var integer = toIntegerOrInfinity(index);
                return integer < 0 ? max(integer + length, 0) : min(integer, length);
              };
            },
            /* 63 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var trunc = __w_pdfjs_require__2(64);
              module2.exports = function(argument) {
                var number = +argument;
                return number !== number || number === 0 ? 0 : trunc(number);
              };
            },
            /* 64 */
            /***/
            (module2) => {
              var ceil = Math.ceil;
              var floor = Math.floor;
              module2.exports = Math.trunc || function trunc(x) {
                var n = +x;
                return (n > 0 ? floor : ceil)(n);
              };
            },
            /* 65 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var toLength = __w_pdfjs_require__2(66);
              module2.exports = function(obj) {
                return toLength(obj.length);
              };
            },
            /* 66 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var toIntegerOrInfinity = __w_pdfjs_require__2(63);
              var min = Math.min;
              module2.exports = function(argument) {
                return argument > 0 ? min(toIntegerOrInfinity(argument), 9007199254740991) : 0;
              };
            },
            /* 67 */
            /***/
            (module2) => {
              module2.exports = [
                "constructor",
                "hasOwnProperty",
                "isPrototypeOf",
                "propertyIsEnumerable",
                "toLocaleString",
                "toString",
                "valueOf"
              ];
            },
            /* 68 */
            /***/
            (__unused_webpack_module2, exports2) => {
              exports2.f = Object.getOwnPropertySymbols;
            },
            /* 69 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var fails = __w_pdfjs_require__2(10);
              var isCallable = __w_pdfjs_require__2(23);
              var replacement = /#|\.prototype\./;
              var isForced = function(feature, detection) {
                var value = data[normalize(feature)];
                return value == POLYFILL ? true : value == NATIVE ? false : isCallable(detection) ? fails(detection) : !!detection;
              };
              var normalize = isForced.normalize = function(string) {
                return String(string).replace(replacement, ".").toLowerCase();
              };
              var data = isForced.data = {};
              var NATIVE = isForced.NATIVE = "N";
              var POLYFILL = isForced.POLYFILL = "P";
              module2.exports = isForced;
            },
            /* 70 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var wellKnownSymbol = __w_pdfjs_require__2(35);
              var create = __w_pdfjs_require__2(71);
              var defineProperty = __w_pdfjs_require__2(46).f;
              var UNSCOPABLES = wellKnownSymbol("unscopables");
              var ArrayPrototype = Array.prototype;
              if (ArrayPrototype[UNSCOPABLES] == void 0) {
                defineProperty(ArrayPrototype, UNSCOPABLES, {
                  configurable: true,
                  value: create(null)
                });
              }
              module2.exports = function(key) {
                ArrayPrototype[UNSCOPABLES][key] = true;
              };
            },
            /* 71 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var anObject = __w_pdfjs_require__2(48);
              var definePropertiesModule = __w_pdfjs_require__2(72);
              var enumBugKeys = __w_pdfjs_require__2(67);
              var hiddenKeys = __w_pdfjs_require__2(56);
              var html = __w_pdfjs_require__2(74);
              var documentCreateElement = __w_pdfjs_require__2(44);
              var sharedKey = __w_pdfjs_require__2(55);
              var GT = ">";
              var LT = "<";
              var PROTOTYPE = "prototype";
              var SCRIPT = "script";
              var IE_PROTO = sharedKey("IE_PROTO");
              var EmptyConstructor = function() {
              };
              var scriptTag = function(content) {
                return LT + SCRIPT + GT + content + LT + "/" + SCRIPT + GT;
              };
              var NullProtoObjectViaActiveX = function(activeXDocument2) {
                activeXDocument2.write(scriptTag(""));
                activeXDocument2.close();
                var temp = activeXDocument2.parentWindow.Object;
                activeXDocument2 = null;
                return temp;
              };
              var NullProtoObjectViaIFrame = function() {
                var iframe = documentCreateElement("iframe");
                var JS = "java" + SCRIPT + ":";
                var iframeDocument;
                iframe.style.display = "none";
                html.appendChild(iframe);
                iframe.src = String(JS);
                iframeDocument = iframe.contentWindow.document;
                iframeDocument.open();
                iframeDocument.write(scriptTag("document.F=Object"));
                iframeDocument.close();
                return iframeDocument.F;
              };
              var activeXDocument;
              var NullProtoObject = function() {
                try {
                  activeXDocument = new ActiveXObject("htmlfile");
                } catch (error) {
                }
                NullProtoObject = typeof document != "undefined" ? document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame() : NullProtoObjectViaActiveX(activeXDocument);
                var length = enumBugKeys.length;
                while (length--)
                  delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
                return NullProtoObject();
              };
              hiddenKeys[IE_PROTO] = true;
              module2.exports = Object.create || function create(O, Properties) {
                var result;
                if (O !== null) {
                  EmptyConstructor[PROTOTYPE] = anObject(O);
                  result = new EmptyConstructor();
                  EmptyConstructor[PROTOTYPE] = null;
                  result[IE_PROTO] = O;
                } else
                  result = NullProtoObject();
                return Properties === void 0 ? result : definePropertiesModule.f(result, Properties);
              };
            },
            /* 72 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              var DESCRIPTORS = __w_pdfjs_require__2(9);
              var V8_PROTOTYPE_DEFINE_BUG = __w_pdfjs_require__2(47);
              var definePropertyModule = __w_pdfjs_require__2(46);
              var anObject = __w_pdfjs_require__2(48);
              var toIndexedObject = __w_pdfjs_require__2(15);
              var objectKeys = __w_pdfjs_require__2(73);
              exports2.f = DESCRIPTORS && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {
                anObject(O);
                var props = toIndexedObject(Properties);
                var keys = objectKeys(Properties);
                var length = keys.length;
                var index = 0;
                var key;
                while (length > index)
                  definePropertyModule.f(O, key = keys[index++], props[key]);
                return O;
              };
            },
            /* 73 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var internalObjectKeys = __w_pdfjs_require__2(60);
              var enumBugKeys = __w_pdfjs_require__2(67);
              module2.exports = Object.keys || function keys(O) {
                return internalObjectKeys(O, enumBugKeys);
              };
            },
            /* 74 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var getBuiltIn = __w_pdfjs_require__2(25);
              module2.exports = getBuiltIn("document", "documentElement");
            },
            /* 75 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var global2 = __w_pdfjs_require__2(7);
              var uncurryThis = __w_pdfjs_require__2(17);
              module2.exports = function(CONSTRUCTOR, METHOD) {
                return uncurryThis(global2[CONSTRUCTOR].prototype[METHOD]);
              };
            },
            /* 76 */
            /***/
            (__unused_webpack_module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              __w_pdfjs_require__2(77);
            },
            /* 77 */
            /***/
            (__unused_webpack_module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              "use strict";
              var ArrayBufferViewCore = __w_pdfjs_require__2(78);
              var lengthOfArrayLike = __w_pdfjs_require__2(65);
              var toIntegerOrInfinity = __w_pdfjs_require__2(63);
              var aTypedArray = ArrayBufferViewCore.aTypedArray;
              var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
              exportTypedArrayMethod("at", function at(index) {
                var O = aTypedArray(this);
                var len = lengthOfArrayLike(O);
                var relativeIndex = toIntegerOrInfinity(index);
                var k = relativeIndex >= 0 ? relativeIndex : len + relativeIndex;
                return k < 0 || k >= len ? void 0 : O[k];
              });
            },
            /* 78 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              "use strict";
              var NATIVE_ARRAY_BUFFER = __w_pdfjs_require__2(79);
              var DESCRIPTORS = __w_pdfjs_require__2(9);
              var global2 = __w_pdfjs_require__2(7);
              var isCallable = __w_pdfjs_require__2(23);
              var isObject = __w_pdfjs_require__2(22);
              var hasOwn = __w_pdfjs_require__2(40);
              var classof = __w_pdfjs_require__2(80);
              var tryToString = __w_pdfjs_require__2(33);
              var createNonEnumerableProperty = __w_pdfjs_require__2(45);
              var defineBuiltIn = __w_pdfjs_require__2(49);
              var defineProperty = __w_pdfjs_require__2(46).f;
              var isPrototypeOf = __w_pdfjs_require__2(26);
              var getPrototypeOf = __w_pdfjs_require__2(82);
              var setPrototypeOf = __w_pdfjs_require__2(84);
              var wellKnownSymbol = __w_pdfjs_require__2(35);
              var uid = __w_pdfjs_require__2(42);
              var InternalStateModule = __w_pdfjs_require__2(53);
              var enforceInternalState = InternalStateModule.enforce;
              var getInternalState = InternalStateModule.get;
              var Int8Array = global2.Int8Array;
              var Int8ArrayPrototype = Int8Array && Int8Array.prototype;
              var Uint8ClampedArray = global2.Uint8ClampedArray;
              var Uint8ClampedArrayPrototype = Uint8ClampedArray && Uint8ClampedArray.prototype;
              var TypedArray = Int8Array && getPrototypeOf(Int8Array);
              var TypedArrayPrototype = Int8ArrayPrototype && getPrototypeOf(Int8ArrayPrototype);
              var ObjectPrototype = Object.prototype;
              var TypeError2 = global2.TypeError;
              var TO_STRING_TAG = wellKnownSymbol("toStringTag");
              var TYPED_ARRAY_TAG = uid("TYPED_ARRAY_TAG");
              var TYPED_ARRAY_CONSTRUCTOR = "TypedArrayConstructor";
              var NATIVE_ARRAY_BUFFER_VIEWS = NATIVE_ARRAY_BUFFER && !!setPrototypeOf && classof(global2.opera) !== "Opera";
              var TYPED_ARRAY_TAG_REQUIRED = false;
              var NAME, Constructor, Prototype;
              var TypedArrayConstructorsList = {
                Int8Array: 1,
                Uint8Array: 1,
                Uint8ClampedArray: 1,
                Int16Array: 2,
                Uint16Array: 2,
                Int32Array: 4,
                Uint32Array: 4,
                Float32Array: 4,
                Float64Array: 8
              };
              var BigIntArrayConstructorsList = {
                BigInt64Array: 8,
                BigUint64Array: 8
              };
              var isView = function isView2(it) {
                if (!isObject(it))
                  return false;
                var klass = classof(it);
                return klass === "DataView" || hasOwn(TypedArrayConstructorsList, klass) || hasOwn(BigIntArrayConstructorsList, klass);
              };
              var getTypedArrayConstructor = function(it) {
                var proto = getPrototypeOf(it);
                if (!isObject(proto))
                  return;
                var state = getInternalState(proto);
                return state && hasOwn(state, TYPED_ARRAY_CONSTRUCTOR) ? state[TYPED_ARRAY_CONSTRUCTOR] : getTypedArrayConstructor(proto);
              };
              var isTypedArray = function(it) {
                if (!isObject(it))
                  return false;
                var klass = classof(it);
                return hasOwn(TypedArrayConstructorsList, klass) || hasOwn(BigIntArrayConstructorsList, klass);
              };
              var aTypedArray = function(it) {
                if (isTypedArray(it))
                  return it;
                throw TypeError2("Target is not a typed array");
              };
              var aTypedArrayConstructor = function(C) {
                if (isCallable(C) && (!setPrototypeOf || isPrototypeOf(TypedArray, C)))
                  return C;
                throw TypeError2(tryToString(C) + " is not a typed array constructor");
              };
              var exportTypedArrayMethod = function(KEY, property, forced, options) {
                if (!DESCRIPTORS)
                  return;
                if (forced)
                  for (var ARRAY in TypedArrayConstructorsList) {
                    var TypedArrayConstructor = global2[ARRAY];
                    if (TypedArrayConstructor && hasOwn(TypedArrayConstructor.prototype, KEY))
                      try {
                        delete TypedArrayConstructor.prototype[KEY];
                      } catch (error) {
                        try {
                          TypedArrayConstructor.prototype[KEY] = property;
                        } catch (error2) {
                        }
                      }
                  }
                if (!TypedArrayPrototype[KEY] || forced) {
                  defineBuiltIn(TypedArrayPrototype, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && Int8ArrayPrototype[KEY] || property, options);
                }
              };
              var exportTypedArrayStaticMethod = function(KEY, property, forced) {
                var ARRAY, TypedArrayConstructor;
                if (!DESCRIPTORS)
                  return;
                if (setPrototypeOf) {
                  if (forced)
                    for (ARRAY in TypedArrayConstructorsList) {
                      TypedArrayConstructor = global2[ARRAY];
                      if (TypedArrayConstructor && hasOwn(TypedArrayConstructor, KEY))
                        try {
                          delete TypedArrayConstructor[KEY];
                        } catch (error) {
                        }
                    }
                  if (!TypedArray[KEY] || forced) {
                    try {
                      return defineBuiltIn(TypedArray, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && TypedArray[KEY] || property);
                    } catch (error) {
                    }
                  } else
                    return;
                }
                for (ARRAY in TypedArrayConstructorsList) {
                  TypedArrayConstructor = global2[ARRAY];
                  if (TypedArrayConstructor && (!TypedArrayConstructor[KEY] || forced)) {
                    defineBuiltIn(TypedArrayConstructor, KEY, property);
                  }
                }
              };
              for (NAME in TypedArrayConstructorsList) {
                Constructor = global2[NAME];
                Prototype = Constructor && Constructor.prototype;
                if (Prototype)
                  enforceInternalState(Prototype)[TYPED_ARRAY_CONSTRUCTOR] = Constructor;
                else
                  NATIVE_ARRAY_BUFFER_VIEWS = false;
              }
              for (NAME in BigIntArrayConstructorsList) {
                Constructor = global2[NAME];
                Prototype = Constructor && Constructor.prototype;
                if (Prototype)
                  enforceInternalState(Prototype)[TYPED_ARRAY_CONSTRUCTOR] = Constructor;
              }
              if (!NATIVE_ARRAY_BUFFER_VIEWS || !isCallable(TypedArray) || TypedArray === Function.prototype) {
                TypedArray = function TypedArray2() {
                  throw TypeError2("Incorrect invocation");
                };
                if (NATIVE_ARRAY_BUFFER_VIEWS)
                  for (NAME in TypedArrayConstructorsList) {
                    if (global2[NAME])
                      setPrototypeOf(global2[NAME], TypedArray);
                  }
              }
              if (!NATIVE_ARRAY_BUFFER_VIEWS || !TypedArrayPrototype || TypedArrayPrototype === ObjectPrototype) {
                TypedArrayPrototype = TypedArray.prototype;
                if (NATIVE_ARRAY_BUFFER_VIEWS)
                  for (NAME in TypedArrayConstructorsList) {
                    if (global2[NAME])
                      setPrototypeOf(global2[NAME].prototype, TypedArrayPrototype);
                  }
              }
              if (NATIVE_ARRAY_BUFFER_VIEWS && getPrototypeOf(Uint8ClampedArrayPrototype) !== TypedArrayPrototype) {
                setPrototypeOf(Uint8ClampedArrayPrototype, TypedArrayPrototype);
              }
              if (DESCRIPTORS && !hasOwn(TypedArrayPrototype, TO_STRING_TAG)) {
                TYPED_ARRAY_TAG_REQUIRED = true;
                defineProperty(TypedArrayPrototype, TO_STRING_TAG, {
                  get: function() {
                    return isObject(this) ? this[TYPED_ARRAY_TAG] : void 0;
                  }
                });
                for (NAME in TypedArrayConstructorsList)
                  if (global2[NAME]) {
                    createNonEnumerableProperty(global2[NAME], TYPED_ARRAY_TAG, NAME);
                  }
              }
              module2.exports = {
                NATIVE_ARRAY_BUFFER_VIEWS,
                TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQUIRED && TYPED_ARRAY_TAG,
                aTypedArray,
                aTypedArrayConstructor,
                exportTypedArrayMethod,
                exportTypedArrayStaticMethod,
                getTypedArrayConstructor,
                isView,
                isTypedArray,
                TypedArray,
                TypedArrayPrototype
              };
            },
            /* 79 */
            /***/
            (module2) => {
              module2.exports = typeof ArrayBuffer != "undefined" && typeof DataView != "undefined";
            },
            /* 80 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var TO_STRING_TAG_SUPPORT = __w_pdfjs_require__2(81);
              var isCallable = __w_pdfjs_require__2(23);
              var classofRaw = __w_pdfjs_require__2(18);
              var wellKnownSymbol = __w_pdfjs_require__2(35);
              var TO_STRING_TAG = wellKnownSymbol("toStringTag");
              var $Object = Object;
              var CORRECT_ARGUMENTS = classofRaw(/* @__PURE__ */ function() {
                return arguments;
              }()) == "Arguments";
              var tryGet = function(it, key) {
                try {
                  return it[key];
                } catch (error) {
                }
              };
              module2.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function(it) {
                var O, tag, result;
                return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : (result = classofRaw(O)) == "Object" && isCallable(O.callee) ? "Arguments" : result;
              };
            },
            /* 81 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var wellKnownSymbol = __w_pdfjs_require__2(35);
              var TO_STRING_TAG = wellKnownSymbol("toStringTag");
              var test = {};
              test[TO_STRING_TAG] = "z";
              module2.exports = String(test) === "[object z]";
            },
            /* 82 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var hasOwn = __w_pdfjs_require__2(40);
              var isCallable = __w_pdfjs_require__2(23);
              var toObject = __w_pdfjs_require__2(41);
              var sharedKey = __w_pdfjs_require__2(55);
              var CORRECT_PROTOTYPE_GETTER = __w_pdfjs_require__2(83);
              var IE_PROTO = sharedKey("IE_PROTO");
              var $Object = Object;
              var ObjectPrototype = $Object.prototype;
              module2.exports = CORRECT_PROTOTYPE_GETTER ? $Object.getPrototypeOf : function(O) {
                var object = toObject(O);
                if (hasOwn(object, IE_PROTO))
                  return object[IE_PROTO];
                var constructor = object.constructor;
                if (isCallable(constructor) && object instanceof constructor) {
                  return constructor.prototype;
                }
                return object instanceof $Object ? ObjectPrototype : null;
              };
            },
            /* 83 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var fails = __w_pdfjs_require__2(10);
              module2.exports = !fails(function() {
                function F() {
                }
                F.prototype.constructor = null;
                return Object.getPrototypeOf(new F()) !== F.prototype;
              });
            },
            /* 84 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var uncurryThis = __w_pdfjs_require__2(17);
              var anObject = __w_pdfjs_require__2(48);
              var aPossiblePrototype = __w_pdfjs_require__2(85);
              module2.exports = Object.setPrototypeOf || ("__proto__" in {} ? function() {
                var CORRECT_SETTER = false;
                var test = {};
                var setter;
                try {
                  setter = uncurryThis(Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set);
                  setter(test, []);
                  CORRECT_SETTER = test instanceof Array;
                } catch (error) {
                }
                return function setPrototypeOf(O, proto) {
                  anObject(O);
                  aPossiblePrototype(proto);
                  if (CORRECT_SETTER)
                    setter(O, proto);
                  else
                    O.__proto__ = proto;
                  return O;
                };
              }() : void 0);
            },
            /* 85 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var isCallable = __w_pdfjs_require__2(23);
              var $String = String;
              var $TypeError = TypeError;
              module2.exports = function(argument) {
                if (typeof argument == "object" || isCallable(argument))
                  return argument;
                throw $TypeError("Can't set " + $String(argument) + " as a prototype");
              };
            },
            /* 86 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              __w_pdfjs_require__2(87);
              __w_pdfjs_require__2(93);
              __w_pdfjs_require__2(95);
              __w_pdfjs_require__2(117);
              __w_pdfjs_require__2(119);
              var path = __w_pdfjs_require__2(128);
              module2.exports = path.structuredClone;
            },
            /* 87 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              "use strict";
              var toIndexedObject = __w_pdfjs_require__2(15);
              var addToUnscopables = __w_pdfjs_require__2(70);
              var Iterators = __w_pdfjs_require__2(88);
              var InternalStateModule = __w_pdfjs_require__2(53);
              var defineProperty = __w_pdfjs_require__2(46).f;
              var defineIterator = __w_pdfjs_require__2(89);
              var IS_PURE = __w_pdfjs_require__2(37);
              var DESCRIPTORS = __w_pdfjs_require__2(9);
              var ARRAY_ITERATOR = "Array Iterator";
              var setInternalState = InternalStateModule.set;
              var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);
              module2.exports = defineIterator(Array, "Array", function(iterated, kind) {
                setInternalState(this, {
                  type: ARRAY_ITERATOR,
                  target: toIndexedObject(iterated),
                  index: 0,
                  kind
                });
              }, function() {
                var state = getInternalState(this);
                var target = state.target;
                var kind = state.kind;
                var index = state.index++;
                if (!target || index >= target.length) {
                  state.target = void 0;
                  return {
                    value: void 0,
                    done: true
                  };
                }
                if (kind == "keys")
                  return {
                    value: index,
                    done: false
                  };
                if (kind == "values")
                  return {
                    value: target[index],
                    done: false
                  };
                return {
                  value: [
                    index,
                    target[index]
                  ],
                  done: false
                };
              }, "values");
              var values = Iterators.Arguments = Iterators.Array;
              addToUnscopables("keys");
              addToUnscopables("values");
              addToUnscopables("entries");
              if (!IS_PURE && DESCRIPTORS && values.name !== "values")
                try {
                  defineProperty(values, "name", { value: "values" });
                } catch (error) {
                }
            },
            /* 88 */
            /***/
            (module2) => {
              module2.exports = {};
            },
            /* 89 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              "use strict";
              var $ = __w_pdfjs_require__2(6);
              var call = __w_pdfjs_require__2(11);
              var IS_PURE = __w_pdfjs_require__2(37);
              var FunctionName = __w_pdfjs_require__2(51);
              var isCallable = __w_pdfjs_require__2(23);
              var createIteratorConstructor = __w_pdfjs_require__2(90);
              var getPrototypeOf = __w_pdfjs_require__2(82);
              var setPrototypeOf = __w_pdfjs_require__2(84);
              var setToStringTag = __w_pdfjs_require__2(92);
              var createNonEnumerableProperty = __w_pdfjs_require__2(45);
              var defineBuiltIn = __w_pdfjs_require__2(49);
              var wellKnownSymbol = __w_pdfjs_require__2(35);
              var Iterators = __w_pdfjs_require__2(88);
              var IteratorsCore = __w_pdfjs_require__2(91);
              var PROPER_FUNCTION_NAME = FunctionName.PROPER;
              var CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
              var IteratorPrototype = IteratorsCore.IteratorPrototype;
              var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
              var ITERATOR = wellKnownSymbol("iterator");
              var KEYS = "keys";
              var VALUES = "values";
              var ENTRIES = "entries";
              var returnThis = function() {
                return this;
              };
              module2.exports = function(Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
                createIteratorConstructor(IteratorConstructor, NAME, next);
                var getIterationMethod = function(KIND) {
                  if (KIND === DEFAULT && defaultIterator)
                    return defaultIterator;
                  if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype)
                    return IterablePrototype[KIND];
                  switch (KIND) {
                    case KEYS:
                      return function keys() {
                        return new IteratorConstructor(this, KIND);
                      };
                    case VALUES:
                      return function values() {
                        return new IteratorConstructor(this, KIND);
                      };
                    case ENTRIES:
                      return function entries() {
                        return new IteratorConstructor(this, KIND);
                      };
                  }
                  return function() {
                    return new IteratorConstructor(this);
                  };
                };
                var TO_STRING_TAG = NAME + " Iterator";
                var INCORRECT_VALUES_NAME = false;
                var IterablePrototype = Iterable.prototype;
                var nativeIterator = IterablePrototype[ITERATOR] || IterablePrototype["@@iterator"] || DEFAULT && IterablePrototype[DEFAULT];
                var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
                var anyNativeIterator = NAME == "Array" ? IterablePrototype.entries || nativeIterator : nativeIterator;
                var CurrentIteratorPrototype, methods, KEY;
                if (anyNativeIterator) {
                  CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
                  if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
                    if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
                      if (setPrototypeOf) {
                        setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
                      } else if (!isCallable(CurrentIteratorPrototype[ITERATOR])) {
                        defineBuiltIn(CurrentIteratorPrototype, ITERATOR, returnThis);
                      }
                    }
                    setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
                    if (IS_PURE)
                      Iterators[TO_STRING_TAG] = returnThis;
                  }
                }
                if (PROPER_FUNCTION_NAME && DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
                  if (!IS_PURE && CONFIGURABLE_FUNCTION_NAME) {
                    createNonEnumerableProperty(IterablePrototype, "name", VALUES);
                  } else {
                    INCORRECT_VALUES_NAME = true;
                    defaultIterator = function values() {
                      return call(nativeIterator, this);
                    };
                  }
                }
                if (DEFAULT) {
                  methods = {
                    values: getIterationMethod(VALUES),
                    keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
                    entries: getIterationMethod(ENTRIES)
                  };
                  if (FORCED)
                    for (KEY in methods) {
                      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
                        defineBuiltIn(IterablePrototype, KEY, methods[KEY]);
                      }
                    }
                  else
                    $({
                      target: NAME,
                      proto: true,
                      forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME
                    }, methods);
                }
                if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
                  defineBuiltIn(IterablePrototype, ITERATOR, defaultIterator, { name: DEFAULT });
                }
                Iterators[NAME] = defaultIterator;
                return methods;
              };
            },
            /* 90 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              "use strict";
              var IteratorPrototype = __w_pdfjs_require__2(91).IteratorPrototype;
              var create = __w_pdfjs_require__2(71);
              var createPropertyDescriptor = __w_pdfjs_require__2(14);
              var setToStringTag = __w_pdfjs_require__2(92);
              var Iterators = __w_pdfjs_require__2(88);
              var returnThis = function() {
                return this;
              };
              module2.exports = function(IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {
                var TO_STRING_TAG = NAME + " Iterator";
                IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(+!ENUMERABLE_NEXT, next) });
                setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
                Iterators[TO_STRING_TAG] = returnThis;
                return IteratorConstructor;
              };
            },
            /* 91 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              "use strict";
              var fails = __w_pdfjs_require__2(10);
              var isCallable = __w_pdfjs_require__2(23);
              var create = __w_pdfjs_require__2(71);
              var getPrototypeOf = __w_pdfjs_require__2(82);
              var defineBuiltIn = __w_pdfjs_require__2(49);
              var wellKnownSymbol = __w_pdfjs_require__2(35);
              var IS_PURE = __w_pdfjs_require__2(37);
              var ITERATOR = wellKnownSymbol("iterator");
              var BUGGY_SAFARI_ITERATORS = false;
              var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;
              if ([].keys) {
                arrayIterator = [].keys();
                if (!("next" in arrayIterator))
                  BUGGY_SAFARI_ITERATORS = true;
                else {
                  PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
                  if (PrototypeOfArrayIteratorPrototype !== Object.prototype)
                    IteratorPrototype = PrototypeOfArrayIteratorPrototype;
                }
              }
              var NEW_ITERATOR_PROTOTYPE = IteratorPrototype == void 0 || fails(function() {
                var test = {};
                return IteratorPrototype[ITERATOR].call(test) !== test;
              });
              if (NEW_ITERATOR_PROTOTYPE)
                IteratorPrototype = {};
              else if (IS_PURE)
                IteratorPrototype = create(IteratorPrototype);
              if (!isCallable(IteratorPrototype[ITERATOR])) {
                defineBuiltIn(IteratorPrototype, ITERATOR, function() {
                  return this;
                });
              }
              module2.exports = {
                IteratorPrototype,
                BUGGY_SAFARI_ITERATORS
              };
            },
            /* 92 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var defineProperty = __w_pdfjs_require__2(46).f;
              var hasOwn = __w_pdfjs_require__2(40);
              var wellKnownSymbol = __w_pdfjs_require__2(35);
              var TO_STRING_TAG = wellKnownSymbol("toStringTag");
              module2.exports = function(target, TAG, STATIC) {
                if (target && !STATIC)
                  target = target.prototype;
                if (target && !hasOwn(target, TO_STRING_TAG)) {
                  defineProperty(target, TO_STRING_TAG, {
                    configurable: true,
                    value: TAG
                  });
                }
              };
            },
            /* 93 */
            /***/
            (__unused_webpack_module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var TO_STRING_TAG_SUPPORT = __w_pdfjs_require__2(81);
              var defineBuiltIn = __w_pdfjs_require__2(49);
              var toString = __w_pdfjs_require__2(94);
              if (!TO_STRING_TAG_SUPPORT) {
                defineBuiltIn(Object.prototype, "toString", toString, { unsafe: true });
              }
            },
            /* 94 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              "use strict";
              var TO_STRING_TAG_SUPPORT = __w_pdfjs_require__2(81);
              var classof = __w_pdfjs_require__2(80);
              module2.exports = TO_STRING_TAG_SUPPORT ? {}.toString : function toString() {
                return "[object " + classof(this) + "]";
              };
            },
            /* 95 */
            /***/
            (__unused_webpack_module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              __w_pdfjs_require__2(96);
            },
            /* 96 */
            /***/
            (__unused_webpack_module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              "use strict";
              var collection = __w_pdfjs_require__2(97);
              var collectionStrong = __w_pdfjs_require__2(114);
              collection("Map", function(init) {
                return function Map2() {
                  return init(this, arguments.length ? arguments[0] : void 0);
                };
              }, collectionStrong);
            },
            /* 97 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              "use strict";
              var $ = __w_pdfjs_require__2(6);
              var global2 = __w_pdfjs_require__2(7);
              var uncurryThis = __w_pdfjs_require__2(17);
              var isForced = __w_pdfjs_require__2(69);
              var defineBuiltIn = __w_pdfjs_require__2(49);
              var InternalMetadataModule = __w_pdfjs_require__2(98);
              var iterate = __w_pdfjs_require__2(105);
              var anInstance = __w_pdfjs_require__2(111);
              var isCallable = __w_pdfjs_require__2(23);
              var isObject = __w_pdfjs_require__2(22);
              var fails = __w_pdfjs_require__2(10);
              var checkCorrectnessOfIteration = __w_pdfjs_require__2(112);
              var setToStringTag = __w_pdfjs_require__2(92);
              var inheritIfRequired = __w_pdfjs_require__2(113);
              module2.exports = function(CONSTRUCTOR_NAME, wrapper, common) {
                var IS_MAP = CONSTRUCTOR_NAME.indexOf("Map") !== -1;
                var IS_WEAK = CONSTRUCTOR_NAME.indexOf("Weak") !== -1;
                var ADDER = IS_MAP ? "set" : "add";
                var NativeConstructor = global2[CONSTRUCTOR_NAME];
                var NativePrototype = NativeConstructor && NativeConstructor.prototype;
                var Constructor = NativeConstructor;
                var exported = {};
                var fixMethod = function(KEY) {
                  var uncurriedNativeMethod = uncurryThis(NativePrototype[KEY]);
                  defineBuiltIn(NativePrototype, KEY, KEY == "add" ? function add(value) {
                    uncurriedNativeMethod(this, value === 0 ? 0 : value);
                    return this;
                  } : KEY == "delete" ? function(key) {
                    return IS_WEAK && !isObject(key) ? false : uncurriedNativeMethod(this, key === 0 ? 0 : key);
                  } : KEY == "get" ? function get(key) {
                    return IS_WEAK && !isObject(key) ? void 0 : uncurriedNativeMethod(this, key === 0 ? 0 : key);
                  } : KEY == "has" ? function has(key) {
                    return IS_WEAK && !isObject(key) ? false : uncurriedNativeMethod(this, key === 0 ? 0 : key);
                  } : function set(key, value) {
                    uncurriedNativeMethod(this, key === 0 ? 0 : key, value);
                    return this;
                  });
                };
                var REPLACE = isForced(CONSTRUCTOR_NAME, !isCallable(NativeConstructor) || !(IS_WEAK || NativePrototype.forEach && !fails(function() {
                  new NativeConstructor().entries().next();
                })));
                if (REPLACE) {
                  Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);
                  InternalMetadataModule.enable();
                } else if (isForced(CONSTRUCTOR_NAME, true)) {
                  var instance = new Constructor();
                  var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
                  var THROWS_ON_PRIMITIVES = fails(function() {
                    instance.has(1);
                  });
                  var ACCEPT_ITERABLES = checkCorrectnessOfIteration(function(iterable) {
                    new NativeConstructor(iterable);
                  });
                  var BUGGY_ZERO = !IS_WEAK && fails(function() {
                    var $instance = new NativeConstructor();
                    var index = 5;
                    while (index--)
                      $instance[ADDER](index, index);
                    return !$instance.has(-0);
                  });
                  if (!ACCEPT_ITERABLES) {
                    Constructor = wrapper(function(dummy, iterable) {
                      anInstance(dummy, NativePrototype);
                      var that = inheritIfRequired(new NativeConstructor(), dummy, Constructor);
                      if (iterable != void 0)
                        iterate(iterable, that[ADDER], {
                          that,
                          AS_ENTRIES: IS_MAP
                        });
                      return that;
                    });
                    Constructor.prototype = NativePrototype;
                    NativePrototype.constructor = Constructor;
                  }
                  if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
                    fixMethod("delete");
                    fixMethod("has");
                    IS_MAP && fixMethod("get");
                  }
                  if (BUGGY_ZERO || HASNT_CHAINING)
                    fixMethod(ADDER);
                  if (IS_WEAK && NativePrototype.clear)
                    delete NativePrototype.clear;
                }
                exported[CONSTRUCTOR_NAME] = Constructor;
                $({
                  global: true,
                  constructor: true,
                  forced: Constructor != NativeConstructor
                }, exported);
                setToStringTag(Constructor, CONSTRUCTOR_NAME);
                if (!IS_WEAK)
                  common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);
                return Constructor;
              };
            },
            /* 98 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var $ = __w_pdfjs_require__2(6);
              var uncurryThis = __w_pdfjs_require__2(17);
              var hiddenKeys = __w_pdfjs_require__2(56);
              var isObject = __w_pdfjs_require__2(22);
              var hasOwn = __w_pdfjs_require__2(40);
              var defineProperty = __w_pdfjs_require__2(46).f;
              var getOwnPropertyNamesModule = __w_pdfjs_require__2(59);
              var getOwnPropertyNamesExternalModule = __w_pdfjs_require__2(99);
              var isExtensible = __w_pdfjs_require__2(102);
              var uid = __w_pdfjs_require__2(42);
              var FREEZING = __w_pdfjs_require__2(104);
              var REQUIRED = false;
              var METADATA = uid("meta");
              var id = 0;
              var setMetadata = function(it) {
                defineProperty(it, METADATA, {
                  value: {
                    objectID: "O" + id++,
                    weakData: {}
                  }
                });
              };
              var fastKey = function(it, create) {
                if (!isObject(it))
                  return typeof it == "symbol" ? it : (typeof it == "string" ? "S" : "P") + it;
                if (!hasOwn(it, METADATA)) {
                  if (!isExtensible(it))
                    return "F";
                  if (!create)
                    return "E";
                  setMetadata(it);
                }
                return it[METADATA].objectID;
              };
              var getWeakData = function(it, create) {
                if (!hasOwn(it, METADATA)) {
                  if (!isExtensible(it))
                    return true;
                  if (!create)
                    return false;
                  setMetadata(it);
                }
                return it[METADATA].weakData;
              };
              var onFreeze = function(it) {
                if (FREEZING && REQUIRED && isExtensible(it) && !hasOwn(it, METADATA))
                  setMetadata(it);
                return it;
              };
              var enable = function() {
                meta.enable = function() {
                };
                REQUIRED = true;
                var getOwnPropertyNames = getOwnPropertyNamesModule.f;
                var splice = uncurryThis([].splice);
                var test = {};
                test[METADATA] = 1;
                if (getOwnPropertyNames(test).length) {
                  getOwnPropertyNamesModule.f = function(it) {
                    var result = getOwnPropertyNames(it);
                    for (var i = 0, length = result.length; i < length; i++) {
                      if (result[i] === METADATA) {
                        splice(result, i, 1);
                        break;
                      }
                    }
                    return result;
                  };
                  $({
                    target: "Object",
                    stat: true,
                    forced: true
                  }, { getOwnPropertyNames: getOwnPropertyNamesExternalModule.f });
                }
              };
              var meta = module2.exports = {
                enable,
                fastKey,
                getWeakData,
                onFreeze
              };
              hiddenKeys[METADATA] = true;
            },
            /* 99 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var classof = __w_pdfjs_require__2(18);
              var toIndexedObject = __w_pdfjs_require__2(15);
              var $getOwnPropertyNames = __w_pdfjs_require__2(59).f;
              var arraySlice = __w_pdfjs_require__2(100);
              var windowNames = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
              var getWindowNames = function(it) {
                try {
                  return $getOwnPropertyNames(it);
                } catch (error) {
                  return arraySlice(windowNames);
                }
              };
              module2.exports.f = function getOwnPropertyNames(it) {
                return windowNames && classof(it) == "Window" ? getWindowNames(it) : $getOwnPropertyNames(toIndexedObject(it));
              };
            },
            /* 100 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var toAbsoluteIndex = __w_pdfjs_require__2(62);
              var lengthOfArrayLike = __w_pdfjs_require__2(65);
              var createProperty = __w_pdfjs_require__2(101);
              var $Array = Array;
              var max = Math.max;
              module2.exports = function(O, start, end) {
                var length = lengthOfArrayLike(O);
                var k = toAbsoluteIndex(start, length);
                var fin = toAbsoluteIndex(end === void 0 ? length : end, length);
                var result = $Array(max(fin - k, 0));
                for (var n = 0; k < fin; k++, n++)
                  createProperty(result, n, O[k]);
                result.length = n;
                return result;
              };
            },
            /* 101 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              "use strict";
              var toPropertyKey = __w_pdfjs_require__2(20);
              var definePropertyModule = __w_pdfjs_require__2(46);
              var createPropertyDescriptor = __w_pdfjs_require__2(14);
              module2.exports = function(object, key, value) {
                var propertyKey = toPropertyKey(key);
                if (propertyKey in object)
                  definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));
                else
                  object[propertyKey] = value;
              };
            },
            /* 102 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var fails = __w_pdfjs_require__2(10);
              var isObject = __w_pdfjs_require__2(22);
              var classof = __w_pdfjs_require__2(18);
              var ARRAY_BUFFER_NON_EXTENSIBLE = __w_pdfjs_require__2(103);
              var $isExtensible = Object.isExtensible;
              var FAILS_ON_PRIMITIVES = fails(function() {
                $isExtensible(1);
              });
              module2.exports = FAILS_ON_PRIMITIVES || ARRAY_BUFFER_NON_EXTENSIBLE ? function isExtensible(it) {
                if (!isObject(it))
                  return false;
                if (ARRAY_BUFFER_NON_EXTENSIBLE && classof(it) == "ArrayBuffer")
                  return false;
                return $isExtensible ? $isExtensible(it) : true;
              } : $isExtensible;
            },
            /* 103 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var fails = __w_pdfjs_require__2(10);
              module2.exports = fails(function() {
                if (typeof ArrayBuffer == "function") {
                  var buffer = new ArrayBuffer(8);
                  if (Object.isExtensible(buffer))
                    Object.defineProperty(buffer, "a", { value: 8 });
                }
              });
            },
            /* 104 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var fails = __w_pdfjs_require__2(10);
              module2.exports = !fails(function() {
                return Object.isExtensible(Object.preventExtensions({}));
              });
            },
            /* 105 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var bind = __w_pdfjs_require__2(106);
              var call = __w_pdfjs_require__2(11);
              var anObject = __w_pdfjs_require__2(48);
              var tryToString = __w_pdfjs_require__2(33);
              var isArrayIteratorMethod = __w_pdfjs_require__2(107);
              var lengthOfArrayLike = __w_pdfjs_require__2(65);
              var isPrototypeOf = __w_pdfjs_require__2(26);
              var getIterator = __w_pdfjs_require__2(108);
              var getIteratorMethod = __w_pdfjs_require__2(109);
              var iteratorClose = __w_pdfjs_require__2(110);
              var $TypeError = TypeError;
              var Result = function(stopped, result) {
                this.stopped = stopped;
                this.result = result;
              };
              var ResultPrototype = Result.prototype;
              module2.exports = function(iterable, unboundFunction, options) {
                var that = options && options.that;
                var AS_ENTRIES = !!(options && options.AS_ENTRIES);
                var IS_RECORD = !!(options && options.IS_RECORD);
                var IS_ITERATOR = !!(options && options.IS_ITERATOR);
                var INTERRUPTED = !!(options && options.INTERRUPTED);
                var fn = bind(unboundFunction, that);
                var iterator, iterFn, index, length, result, next, step;
                var stop = function(condition) {
                  if (iterator)
                    iteratorClose(iterator, "normal", condition);
                  return new Result(true, condition);
                };
                var callFn = function(value) {
                  if (AS_ENTRIES) {
                    anObject(value);
                    return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
                  }
                  return INTERRUPTED ? fn(value, stop) : fn(value);
                };
                if (IS_RECORD) {
                  iterator = iterable.iterator;
                } else if (IS_ITERATOR) {
                  iterator = iterable;
                } else {
                  iterFn = getIteratorMethod(iterable);
                  if (!iterFn)
                    throw $TypeError(tryToString(iterable) + " is not iterable");
                  if (isArrayIteratorMethod(iterFn)) {
                    for (index = 0, length = lengthOfArrayLike(iterable); length > index; index++) {
                      result = callFn(iterable[index]);
                      if (result && isPrototypeOf(ResultPrototype, result))
                        return result;
                    }
                    return new Result(false);
                  }
                  iterator = getIterator(iterable, iterFn);
                }
                next = IS_RECORD ? iterable.next : iterator.next;
                while (!(step = call(next, iterator)).done) {
                  try {
                    result = callFn(step.value);
                  } catch (error) {
                    iteratorClose(iterator, "throw", error);
                  }
                  if (typeof result == "object" && result && isPrototypeOf(ResultPrototype, result))
                    return result;
                }
                return new Result(false);
              };
            },
            /* 106 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var uncurryThis = __w_pdfjs_require__2(17);
              var aCallable = __w_pdfjs_require__2(32);
              var NATIVE_BIND = __w_pdfjs_require__2(12);
              var bind = uncurryThis(uncurryThis.bind);
              module2.exports = function(fn, that) {
                aCallable(fn);
                return that === void 0 ? fn : NATIVE_BIND ? bind(fn, that) : function() {
                  return fn.apply(that, arguments);
                };
              };
            },
            /* 107 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var wellKnownSymbol = __w_pdfjs_require__2(35);
              var Iterators = __w_pdfjs_require__2(88);
              var ITERATOR = wellKnownSymbol("iterator");
              var ArrayPrototype = Array.prototype;
              module2.exports = function(it) {
                return it !== void 0 && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
              };
            },
            /* 108 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var call = __w_pdfjs_require__2(11);
              var aCallable = __w_pdfjs_require__2(32);
              var anObject = __w_pdfjs_require__2(48);
              var tryToString = __w_pdfjs_require__2(33);
              var getIteratorMethod = __w_pdfjs_require__2(109);
              var $TypeError = TypeError;
              module2.exports = function(argument, usingIterator) {
                var iteratorMethod = arguments.length < 2 ? getIteratorMethod(argument) : usingIterator;
                if (aCallable(iteratorMethod))
                  return anObject(call(iteratorMethod, argument));
                throw $TypeError(tryToString(argument) + " is not iterable");
              };
            },
            /* 109 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var classof = __w_pdfjs_require__2(80);
              var getMethod = __w_pdfjs_require__2(31);
              var Iterators = __w_pdfjs_require__2(88);
              var wellKnownSymbol = __w_pdfjs_require__2(35);
              var ITERATOR = wellKnownSymbol("iterator");
              module2.exports = function(it) {
                if (it != void 0)
                  return getMethod(it, ITERATOR) || getMethod(it, "@@iterator") || Iterators[classof(it)];
              };
            },
            /* 110 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var call = __w_pdfjs_require__2(11);
              var anObject = __w_pdfjs_require__2(48);
              var getMethod = __w_pdfjs_require__2(31);
              module2.exports = function(iterator, kind, value) {
                var innerResult, innerError;
                anObject(iterator);
                try {
                  innerResult = getMethod(iterator, "return");
                  if (!innerResult) {
                    if (kind === "throw")
                      throw value;
                    return value;
                  }
                  innerResult = call(innerResult, iterator);
                } catch (error) {
                  innerError = true;
                  innerResult = error;
                }
                if (kind === "throw")
                  throw value;
                if (innerError)
                  throw innerResult;
                anObject(innerResult);
                return value;
              };
            },
            /* 111 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var isPrototypeOf = __w_pdfjs_require__2(26);
              var $TypeError = TypeError;
              module2.exports = function(it, Prototype) {
                if (isPrototypeOf(Prototype, it))
                  return it;
                throw $TypeError("Incorrect invocation");
              };
            },
            /* 112 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var wellKnownSymbol = __w_pdfjs_require__2(35);
              var ITERATOR = wellKnownSymbol("iterator");
              var SAFE_CLOSING = false;
              try {
                var called = 0;
                var iteratorWithReturn = {
                  next: function() {
                    return { done: !!called++ };
                  },
                  "return": function() {
                    SAFE_CLOSING = true;
                  }
                };
                iteratorWithReturn[ITERATOR] = function() {
                  return this;
                };
                Array.from(iteratorWithReturn, function() {
                  throw 2;
                });
              } catch (error) {
              }
              module2.exports = function(exec, SKIP_CLOSING) {
                if (!SKIP_CLOSING && !SAFE_CLOSING)
                  return false;
                var ITERATION_SUPPORT = false;
                try {
                  var object = {};
                  object[ITERATOR] = function() {
                    return {
                      next: function() {
                        return { done: ITERATION_SUPPORT = true };
                      }
                    };
                  };
                  exec(object);
                } catch (error) {
                }
                return ITERATION_SUPPORT;
              };
            },
            /* 113 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var isCallable = __w_pdfjs_require__2(23);
              var isObject = __w_pdfjs_require__2(22);
              var setPrototypeOf = __w_pdfjs_require__2(84);
              module2.exports = function($this, dummy, Wrapper) {
                var NewTarget, NewTargetPrototype;
                if (setPrototypeOf && isCallable(NewTarget = dummy.constructor) && NewTarget !== Wrapper && isObject(NewTargetPrototype = NewTarget.prototype) && NewTargetPrototype !== Wrapper.prototype)
                  setPrototypeOf($this, NewTargetPrototype);
                return $this;
              };
            },
            /* 114 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              "use strict";
              var defineProperty = __w_pdfjs_require__2(46).f;
              var create = __w_pdfjs_require__2(71);
              var defineBuiltIns = __w_pdfjs_require__2(115);
              var bind = __w_pdfjs_require__2(106);
              var anInstance = __w_pdfjs_require__2(111);
              var iterate = __w_pdfjs_require__2(105);
              var defineIterator = __w_pdfjs_require__2(89);
              var setSpecies = __w_pdfjs_require__2(116);
              var DESCRIPTORS = __w_pdfjs_require__2(9);
              var fastKey = __w_pdfjs_require__2(98).fastKey;
              var InternalStateModule = __w_pdfjs_require__2(53);
              var setInternalState = InternalStateModule.set;
              var internalStateGetterFor = InternalStateModule.getterFor;
              module2.exports = {
                getConstructor: function(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
                  var Constructor = wrapper(function(that, iterable) {
                    anInstance(that, Prototype);
                    setInternalState(that, {
                      type: CONSTRUCTOR_NAME,
                      index: create(null),
                      first: void 0,
                      last: void 0,
                      size: 0
                    });
                    if (!DESCRIPTORS)
                      that.size = 0;
                    if (iterable != void 0)
                      iterate(iterable, that[ADDER], {
                        that,
                        AS_ENTRIES: IS_MAP
                      });
                  });
                  var Prototype = Constructor.prototype;
                  var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);
                  var define2 = function(that, key, value) {
                    var state = getInternalState(that);
                    var entry = getEntry(that, key);
                    var previous, index;
                    if (entry) {
                      entry.value = value;
                    } else {
                      state.last = entry = {
                        index: index = fastKey(key, true),
                        key,
                        value,
                        previous: previous = state.last,
                        next: void 0,
                        removed: false
                      };
                      if (!state.first)
                        state.first = entry;
                      if (previous)
                        previous.next = entry;
                      if (DESCRIPTORS)
                        state.size++;
                      else
                        that.size++;
                      if (index !== "F")
                        state.index[index] = entry;
                    }
                    return that;
                  };
                  var getEntry = function(that, key) {
                    var state = getInternalState(that);
                    var index = fastKey(key);
                    var entry;
                    if (index !== "F")
                      return state.index[index];
                    for (entry = state.first; entry; entry = entry.next) {
                      if (entry.key == key)
                        return entry;
                    }
                  };
                  defineBuiltIns(Prototype, {
                    clear: function clear() {
                      var that = this;
                      var state = getInternalState(that);
                      var data = state.index;
                      var entry = state.first;
                      while (entry) {
                        entry.removed = true;
                        if (entry.previous)
                          entry.previous = entry.previous.next = void 0;
                        delete data[entry.index];
                        entry = entry.next;
                      }
                      state.first = state.last = void 0;
                      if (DESCRIPTORS)
                        state.size = 0;
                      else
                        that.size = 0;
                    },
                    "delete": function(key) {
                      var that = this;
                      var state = getInternalState(that);
                      var entry = getEntry(that, key);
                      if (entry) {
                        var next = entry.next;
                        var prev = entry.previous;
                        delete state.index[entry.index];
                        entry.removed = true;
                        if (prev)
                          prev.next = next;
                        if (next)
                          next.previous = prev;
                        if (state.first == entry)
                          state.first = next;
                        if (state.last == entry)
                          state.last = prev;
                        if (DESCRIPTORS)
                          state.size--;
                        else
                          that.size--;
                      }
                      return !!entry;
                    },
                    forEach: function forEach(callbackfn) {
                      var state = getInternalState(this);
                      var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : void 0);
                      var entry;
                      while (entry = entry ? entry.next : state.first) {
                        boundFunction(entry.value, entry.key, this);
                        while (entry && entry.removed)
                          entry = entry.previous;
                      }
                    },
                    has: function has(key) {
                      return !!getEntry(this, key);
                    }
                  });
                  defineBuiltIns(Prototype, IS_MAP ? {
                    get: function get(key) {
                      var entry = getEntry(this, key);
                      return entry && entry.value;
                    },
                    set: function set(key, value) {
                      return define2(this, key === 0 ? 0 : key, value);
                    }
                  } : {
                    add: function add(value) {
                      return define2(this, value = value === 0 ? 0 : value, value);
                    }
                  });
                  if (DESCRIPTORS)
                    defineProperty(Prototype, "size", {
                      get: function() {
                        return getInternalState(this).size;
                      }
                    });
                  return Constructor;
                },
                setStrong: function(Constructor, CONSTRUCTOR_NAME, IS_MAP) {
                  var ITERATOR_NAME = CONSTRUCTOR_NAME + " Iterator";
                  var getInternalCollectionState = internalStateGetterFor(CONSTRUCTOR_NAME);
                  var getInternalIteratorState = internalStateGetterFor(ITERATOR_NAME);
                  defineIterator(Constructor, CONSTRUCTOR_NAME, function(iterated, kind) {
                    setInternalState(this, {
                      type: ITERATOR_NAME,
                      target: iterated,
                      state: getInternalCollectionState(iterated),
                      kind,
                      last: void 0
                    });
                  }, function() {
                    var state = getInternalIteratorState(this);
                    var kind = state.kind;
                    var entry = state.last;
                    while (entry && entry.removed)
                      entry = entry.previous;
                    if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {
                      state.target = void 0;
                      return {
                        value: void 0,
                        done: true
                      };
                    }
                    if (kind == "keys")
                      return {
                        value: entry.key,
                        done: false
                      };
                    if (kind == "values")
                      return {
                        value: entry.value,
                        done: false
                      };
                    return {
                      value: [
                        entry.key,
                        entry.value
                      ],
                      done: false
                    };
                  }, IS_MAP ? "entries" : "values", !IS_MAP, true);
                  setSpecies(CONSTRUCTOR_NAME);
                }
              };
            },
            /* 115 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var defineBuiltIn = __w_pdfjs_require__2(49);
              module2.exports = function(target, src, options) {
                for (var key in src)
                  defineBuiltIn(target, key, src[key], options);
                return target;
              };
            },
            /* 116 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              "use strict";
              var getBuiltIn = __w_pdfjs_require__2(25);
              var definePropertyModule = __w_pdfjs_require__2(46);
              var wellKnownSymbol = __w_pdfjs_require__2(35);
              var DESCRIPTORS = __w_pdfjs_require__2(9);
              var SPECIES = wellKnownSymbol("species");
              module2.exports = function(CONSTRUCTOR_NAME) {
                var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
                var defineProperty = definePropertyModule.f;
                if (DESCRIPTORS && Constructor && !Constructor[SPECIES]) {
                  defineProperty(Constructor, SPECIES, {
                    configurable: true,
                    get: function() {
                      return this;
                    }
                  });
                }
              };
            },
            /* 117 */
            /***/
            (__unused_webpack_module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              __w_pdfjs_require__2(118);
            },
            /* 118 */
            /***/
            (__unused_webpack_module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              "use strict";
              var collection = __w_pdfjs_require__2(97);
              var collectionStrong = __w_pdfjs_require__2(114);
              collection("Set", function(init) {
                return function Set2() {
                  return init(this, arguments.length ? arguments[0] : void 0);
                };
              }, collectionStrong);
            },
            /* 119 */
            /***/
            (__unused_webpack_module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var IS_PURE = __w_pdfjs_require__2(37);
              var $ = __w_pdfjs_require__2(6);
              var global2 = __w_pdfjs_require__2(7);
              var getBuiltin = __w_pdfjs_require__2(25);
              var uncurryThis = __w_pdfjs_require__2(17);
              var fails = __w_pdfjs_require__2(10);
              var uid = __w_pdfjs_require__2(42);
              var isCallable = __w_pdfjs_require__2(23);
              var isConstructor = __w_pdfjs_require__2(120);
              var isObject = __w_pdfjs_require__2(22);
              var isSymbol = __w_pdfjs_require__2(24);
              var iterate = __w_pdfjs_require__2(105);
              var anObject = __w_pdfjs_require__2(48);
              var classof = __w_pdfjs_require__2(80);
              var hasOwn = __w_pdfjs_require__2(40);
              var createProperty = __w_pdfjs_require__2(101);
              var createNonEnumerableProperty = __w_pdfjs_require__2(45);
              var lengthOfArrayLike = __w_pdfjs_require__2(65);
              var validateArgumentsLength = __w_pdfjs_require__2(121);
              var getRegExpFlags = __w_pdfjs_require__2(122);
              var ERROR_STACK_INSTALLABLE = __w_pdfjs_require__2(124);
              var V8 = __w_pdfjs_require__2(29);
              var IS_BROWSER = __w_pdfjs_require__2(125);
              var IS_DENO = __w_pdfjs_require__2(126);
              var IS_NODE = __w_pdfjs_require__2(127);
              var Object2 = global2.Object;
              var Date2 = global2.Date;
              var Error2 = global2.Error;
              var EvalError = global2.EvalError;
              var RangeError2 = global2.RangeError;
              var ReferenceError = global2.ReferenceError;
              var SyntaxError = global2.SyntaxError;
              var TypeError2 = global2.TypeError;
              var URIError = global2.URIError;
              var PerformanceMark = global2.PerformanceMark;
              var WebAssembly = global2.WebAssembly;
              var CompileError = WebAssembly && WebAssembly.CompileError || Error2;
              var LinkError = WebAssembly && WebAssembly.LinkError || Error2;
              var RuntimeError = WebAssembly && WebAssembly.RuntimeError || Error2;
              var DOMException = getBuiltin("DOMException");
              var Set2 = getBuiltin("Set");
              var Map2 = getBuiltin("Map");
              var MapPrototype = Map2.prototype;
              var mapHas = uncurryThis(MapPrototype.has);
              var mapGet = uncurryThis(MapPrototype.get);
              var mapSet = uncurryThis(MapPrototype.set);
              var setAdd = uncurryThis(Set2.prototype.add);
              var objectKeys = getBuiltin("Object", "keys");
              var push = uncurryThis([].push);
              var booleanValueOf = uncurryThis(true.valueOf);
              var numberValueOf = uncurryThis(1 .valueOf);
              var stringValueOf = uncurryThis("".valueOf);
              var getTime = uncurryThis(Date2.prototype.getTime);
              var PERFORMANCE_MARK = uid("structuredClone");
              var DATA_CLONE_ERROR = "DataCloneError";
              var TRANSFERRING = "Transferring";
              var checkBasicSemantic = function(structuredCloneImplementation) {
                return !fails(function() {
                  var set1 = new global2.Set([7]);
                  var set2 = structuredCloneImplementation(set1);
                  var number = structuredCloneImplementation(Object2(7));
                  return set2 == set1 || !set2.has(7) || typeof number != "object" || number != 7;
                }) && structuredCloneImplementation;
              };
              var checkErrorsCloning = function(structuredCloneImplementation, $Error) {
                return !fails(function() {
                  var error = new $Error();
                  var test = structuredCloneImplementation({
                    a: error,
                    b: error
                  });
                  return !(test && test.a === test.b && test.a instanceof $Error && test.a.stack === error.stack);
                });
              };
              var checkNewErrorsCloningSemantic = function(structuredCloneImplementation) {
                return !fails(function() {
                  var test = structuredCloneImplementation(new global2.AggregateError([1], PERFORMANCE_MARK, { cause: 3 }));
                  return test.name != "AggregateError" || test.errors[0] != 1 || test.message != PERFORMANCE_MARK || test.cause != 3;
                });
              };
              var nativeStructuredClone = global2.structuredClone;
              var FORCED_REPLACEMENT = IS_PURE || !checkErrorsCloning(nativeStructuredClone, Error2) || !checkErrorsCloning(nativeStructuredClone, DOMException) || !checkNewErrorsCloningSemantic(nativeStructuredClone);
              var structuredCloneFromMark = !nativeStructuredClone && checkBasicSemantic(function(value) {
                return new PerformanceMark(PERFORMANCE_MARK, { detail: value }).detail;
              });
              var nativeRestrictedStructuredClone = checkBasicSemantic(nativeStructuredClone) || structuredCloneFromMark;
              var throwUncloneable = function(type) {
                throw new DOMException("Uncloneable type: " + type, DATA_CLONE_ERROR);
              };
              var throwUnpolyfillable = function(type, kind) {
                throw new DOMException((kind || "Cloning") + " of " + type + " cannot be properly polyfilled in this engine", DATA_CLONE_ERROR);
              };
              var structuredCloneInternal = function(value, map) {
                if (isSymbol(value))
                  throwUncloneable("Symbol");
                if (!isObject(value))
                  return value;
                if (map) {
                  if (mapHas(map, value))
                    return mapGet(map, value);
                } else
                  map = new Map2();
                var type = classof(value);
                var deep = false;
                var C, name, cloned, dataTransfer, i, length, keys, key, source, target;
                switch (type) {
                  case "Array":
                    cloned = [];
                    deep = true;
                    break;
                  case "Object":
                    cloned = {};
                    deep = true;
                    break;
                  case "Map":
                    cloned = new Map2();
                    deep = true;
                    break;
                  case "Set":
                    cloned = new Set2();
                    deep = true;
                    break;
                  case "RegExp":
                    cloned = new RegExp(value.source, getRegExpFlags(value));
                    break;
                  case "Error":
                    name = value.name;
                    switch (name) {
                      case "AggregateError":
                        cloned = getBuiltin("AggregateError")([]);
                        break;
                      case "EvalError":
                        cloned = EvalError();
                        break;
                      case "RangeError":
                        cloned = RangeError2();
                        break;
                      case "ReferenceError":
                        cloned = ReferenceError();
                        break;
                      case "SyntaxError":
                        cloned = SyntaxError();
                        break;
                      case "TypeError":
                        cloned = TypeError2();
                        break;
                      case "URIError":
                        cloned = URIError();
                        break;
                      case "CompileError":
                        cloned = CompileError();
                        break;
                      case "LinkError":
                        cloned = LinkError();
                        break;
                      case "RuntimeError":
                        cloned = RuntimeError();
                        break;
                      default:
                        cloned = Error2();
                    }
                    deep = true;
                    break;
                  case "DOMException":
                    cloned = new DOMException(value.message, value.name);
                    deep = true;
                    break;
                  case "DataView":
                  case "Int8Array":
                  case "Uint8Array":
                  case "Uint8ClampedArray":
                  case "Int16Array":
                  case "Uint16Array":
                  case "Int32Array":
                  case "Uint32Array":
                  case "Float32Array":
                  case "Float64Array":
                  case "BigInt64Array":
                  case "BigUint64Array":
                    C = global2[type];
                    if (!isObject(C))
                      throwUnpolyfillable(type);
                    cloned = new C(structuredCloneInternal(value.buffer, map), value.byteOffset, type === "DataView" ? value.byteLength : value.length);
                    break;
                  case "DOMQuad":
                    try {
                      cloned = new DOMQuad(structuredCloneInternal(value.p1, map), structuredCloneInternal(value.p2, map), structuredCloneInternal(value.p3, map), structuredCloneInternal(value.p4, map));
                    } catch (error) {
                      if (nativeRestrictedStructuredClone) {
                        cloned = nativeRestrictedStructuredClone(value);
                      } else
                        throwUnpolyfillable(type);
                    }
                    break;
                  case "FileList":
                    C = global2.DataTransfer;
                    if (isConstructor(C)) {
                      dataTransfer = new C();
                      for (i = 0, length = lengthOfArrayLike(value); i < length; i++) {
                        dataTransfer.items.add(structuredCloneInternal(value[i], map));
                      }
                      cloned = dataTransfer.files;
                    } else if (nativeRestrictedStructuredClone) {
                      cloned = nativeRestrictedStructuredClone(value);
                    } else
                      throwUnpolyfillable(type);
                    break;
                  case "ImageData":
                    try {
                      cloned = new ImageData(structuredCloneInternal(value.data, map), value.width, value.height, { colorSpace: value.colorSpace });
                    } catch (error) {
                      if (nativeRestrictedStructuredClone) {
                        cloned = nativeRestrictedStructuredClone(value);
                      } else
                        throwUnpolyfillable(type);
                    }
                    break;
                  default:
                    if (nativeRestrictedStructuredClone) {
                      cloned = nativeRestrictedStructuredClone(value);
                    } else
                      switch (type) {
                        case "BigInt":
                          cloned = Object2(value.valueOf());
                          break;
                        case "Boolean":
                          cloned = Object2(booleanValueOf(value));
                          break;
                        case "Number":
                          cloned = Object2(numberValueOf(value));
                          break;
                        case "String":
                          cloned = Object2(stringValueOf(value));
                          break;
                        case "Date":
                          cloned = new Date2(getTime(value));
                          break;
                        case "ArrayBuffer":
                          C = global2.DataView;
                          if (!C && typeof value.slice != "function")
                            throwUnpolyfillable(type);
                          try {
                            if (typeof value.slice == "function") {
                              cloned = value.slice(0);
                            } else {
                              length = value.byteLength;
                              cloned = new ArrayBuffer(length);
                              source = new C(value);
                              target = new C(cloned);
                              for (i = 0; i < length; i++) {
                                target.setUint8(i, source.getUint8(i));
                              }
                            }
                          } catch (error) {
                            throw new DOMException("ArrayBuffer is detached", DATA_CLONE_ERROR);
                          }
                          break;
                        case "SharedArrayBuffer":
                          cloned = value;
                          break;
                        case "Blob":
                          try {
                            cloned = value.slice(0, value.size, value.type);
                          } catch (error) {
                            throwUnpolyfillable(type);
                          }
                          break;
                        case "DOMPoint":
                        case "DOMPointReadOnly":
                          C = global2[type];
                          try {
                            cloned = C.fromPoint ? C.fromPoint(value) : new C(value.x, value.y, value.z, value.w);
                          } catch (error) {
                            throwUnpolyfillable(type);
                          }
                          break;
                        case "DOMRect":
                        case "DOMRectReadOnly":
                          C = global2[type];
                          try {
                            cloned = C.fromRect ? C.fromRect(value) : new C(value.x, value.y, value.width, value.height);
                          } catch (error) {
                            throwUnpolyfillable(type);
                          }
                          break;
                        case "DOMMatrix":
                        case "DOMMatrixReadOnly":
                          C = global2[type];
                          try {
                            cloned = C.fromMatrix ? C.fromMatrix(value) : new C(value);
                          } catch (error) {
                            throwUnpolyfillable(type);
                          }
                          break;
                        case "AudioData":
                        case "VideoFrame":
                          if (!isCallable(value.clone))
                            throwUnpolyfillable(type);
                          try {
                            cloned = value.clone();
                          } catch (error) {
                            throwUncloneable(type);
                          }
                          break;
                        case "File":
                          try {
                            cloned = new File([value], value.name, value);
                          } catch (error) {
                            throwUnpolyfillable(type);
                          }
                          break;
                        case "CryptoKey":
                        case "GPUCompilationMessage":
                        case "GPUCompilationInfo":
                        case "ImageBitmap":
                        case "RTCCertificate":
                        case "WebAssembly.Module":
                          throwUnpolyfillable(type);
                        default:
                          throwUncloneable(type);
                      }
                }
                mapSet(map, value, cloned);
                if (deep)
                  switch (type) {
                    case "Array":
                    case "Object":
                      keys = objectKeys(value);
                      for (i = 0, length = lengthOfArrayLike(keys); i < length; i++) {
                        key = keys[i];
                        createProperty(cloned, key, structuredCloneInternal(value[key], map));
                      }
                      break;
                    case "Map":
                      value.forEach(function(v, k) {
                        mapSet(cloned, structuredCloneInternal(k, map), structuredCloneInternal(v, map));
                      });
                      break;
                    case "Set":
                      value.forEach(function(v) {
                        setAdd(cloned, structuredCloneInternal(v, map));
                      });
                      break;
                    case "Error":
                      createNonEnumerableProperty(cloned, "message", structuredCloneInternal(value.message, map));
                      if (hasOwn(value, "cause")) {
                        createNonEnumerableProperty(cloned, "cause", structuredCloneInternal(value.cause, map));
                      }
                      if (name == "AggregateError") {
                        cloned.errors = structuredCloneInternal(value.errors, map);
                      }
                    case "DOMException":
                      if (ERROR_STACK_INSTALLABLE) {
                        createNonEnumerableProperty(cloned, "stack", structuredCloneInternal(value.stack, map));
                      }
                  }
                return cloned;
              };
              var PROPER_TRANSFER = nativeStructuredClone && !fails(function() {
                if (IS_DENO && V8 > 92 || IS_NODE && V8 > 94 || IS_BROWSER && V8 > 97)
                  return false;
                var buffer = new ArrayBuffer(8);
                var clone = nativeStructuredClone(buffer, { transfer: [buffer] });
                return buffer.byteLength != 0 || clone.byteLength != 8;
              });
              var tryToTransfer = function(rawTransfer, map) {
                if (!isObject(rawTransfer))
                  throw TypeError2("Transfer option cannot be converted to a sequence");
                var transfer = [];
                iterate(rawTransfer, function(value2) {
                  push(transfer, anObject(value2));
                });
                var i = 0;
                var length = lengthOfArrayLike(transfer);
                var value, type, C, transferredArray, transferred, canvas, context;
                if (PROPER_TRANSFER) {
                  transferredArray = nativeStructuredClone(transfer, { transfer });
                  while (i < length)
                    mapSet(map, transfer[i], transferredArray[i++]);
                } else
                  while (i < length) {
                    value = transfer[i++];
                    if (mapHas(map, value))
                      throw new DOMException("Duplicate transferable", DATA_CLONE_ERROR);
                    type = classof(value);
                    switch (type) {
                      case "ImageBitmap":
                        C = global2.OffscreenCanvas;
                        if (!isConstructor(C))
                          throwUnpolyfillable(type, TRANSFERRING);
                        try {
                          canvas = new C(value.width, value.height);
                          context = canvas.getContext("bitmaprenderer");
                          context.transferFromImageBitmap(value);
                          transferred = canvas.transferToImageBitmap();
                        } catch (error) {
                        }
                        break;
                      case "AudioData":
                      case "VideoFrame":
                        if (!isCallable(value.clone) || !isCallable(value.close))
                          throwUnpolyfillable(type, TRANSFERRING);
                        try {
                          transferred = value.clone();
                          value.close();
                        } catch (error) {
                        }
                        break;
                      case "ArrayBuffer":
                      case "MessagePort":
                      case "OffscreenCanvas":
                      case "ReadableStream":
                      case "TransformStream":
                      case "WritableStream":
                        throwUnpolyfillable(type, TRANSFERRING);
                    }
                    if (transferred === void 0)
                      throw new DOMException("This object cannot be transferred: " + type, DATA_CLONE_ERROR);
                    mapSet(map, value, transferred);
                  }
              };
              $({
                global: true,
                enumerable: true,
                sham: !PROPER_TRANSFER,
                forced: FORCED_REPLACEMENT
              }, {
                structuredClone: function structuredClone2(value) {
                  var options = validateArgumentsLength(arguments.length, 1) > 1 && arguments[1] != null ? anObject(arguments[1]) : void 0;
                  var transfer = options ? options.transfer : void 0;
                  var map;
                  if (transfer !== void 0) {
                    map = new Map2();
                    tryToTransfer(transfer, map);
                  }
                  return structuredCloneInternal(value, map);
                }
              });
            },
            /* 120 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var uncurryThis = __w_pdfjs_require__2(17);
              var fails = __w_pdfjs_require__2(10);
              var isCallable = __w_pdfjs_require__2(23);
              var classof = __w_pdfjs_require__2(80);
              var getBuiltIn = __w_pdfjs_require__2(25);
              var inspectSource = __w_pdfjs_require__2(52);
              var noop = function() {
              };
              var empty = [];
              var construct = getBuiltIn("Reflect", "construct");
              var constructorRegExp = /^\s*(?:class|function)\b/;
              var exec = uncurryThis(constructorRegExp.exec);
              var INCORRECT_TO_STRING = !constructorRegExp.exec(noop);
              var isConstructorModern = function isConstructor(argument) {
                if (!isCallable(argument))
                  return false;
                try {
                  construct(noop, empty, argument);
                  return true;
                } catch (error) {
                  return false;
                }
              };
              var isConstructorLegacy = function isConstructor(argument) {
                if (!isCallable(argument))
                  return false;
                switch (classof(argument)) {
                  case "AsyncFunction":
                  case "GeneratorFunction":
                  case "AsyncGeneratorFunction":
                    return false;
                }
                try {
                  return INCORRECT_TO_STRING || !!exec(constructorRegExp, inspectSource(argument));
                } catch (error) {
                  return true;
                }
              };
              isConstructorLegacy.sham = true;
              module2.exports = !construct || fails(function() {
                var called;
                return isConstructorModern(isConstructorModern.call) || !isConstructorModern(Object) || !isConstructorModern(function() {
                  called = true;
                }) || called;
              }) ? isConstructorLegacy : isConstructorModern;
            },
            /* 121 */
            /***/
            (module2) => {
              var $TypeError = TypeError;
              module2.exports = function(passed, required) {
                if (passed < required)
                  throw $TypeError("Not enough arguments");
                return passed;
              };
            },
            /* 122 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var call = __w_pdfjs_require__2(11);
              var hasOwn = __w_pdfjs_require__2(40);
              var isPrototypeOf = __w_pdfjs_require__2(26);
              var regExpFlags = __w_pdfjs_require__2(123);
              var RegExpPrototype = RegExp.prototype;
              module2.exports = function(R) {
                var flags = R.flags;
                return flags === void 0 && !("flags" in RegExpPrototype) && !hasOwn(R, "flags") && isPrototypeOf(RegExpPrototype, R) ? call(regExpFlags, R) : flags;
              };
            },
            /* 123 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              "use strict";
              var anObject = __w_pdfjs_require__2(48);
              module2.exports = function() {
                var that = anObject(this);
                var result = "";
                if (that.hasIndices)
                  result += "d";
                if (that.global)
                  result += "g";
                if (that.ignoreCase)
                  result += "i";
                if (that.multiline)
                  result += "m";
                if (that.dotAll)
                  result += "s";
                if (that.unicode)
                  result += "u";
                if (that.unicodeSets)
                  result += "v";
                if (that.sticky)
                  result += "y";
                return result;
              };
            },
            /* 124 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var fails = __w_pdfjs_require__2(10);
              var createPropertyDescriptor = __w_pdfjs_require__2(14);
              module2.exports = !fails(function() {
                var error = Error("a");
                if (!("stack" in error))
                  return true;
                Object.defineProperty(error, "stack", createPropertyDescriptor(1, 7));
                return error.stack !== 7;
              });
            },
            /* 125 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var IS_DENO = __w_pdfjs_require__2(126);
              var IS_NODE = __w_pdfjs_require__2(127);
              module2.exports = !IS_DENO && !IS_NODE && typeof window == "object" && typeof document == "object";
            },
            /* 126 */
            /***/
            (module2) => {
              module2.exports = typeof Deno == "object" && Deno && typeof Deno.version == "object";
            },
            /* 127 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var classof = __w_pdfjs_require__2(18);
              var global2 = __w_pdfjs_require__2(7);
              module2.exports = classof(global2.process) == "process";
            },
            /* 128 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var global2 = __w_pdfjs_require__2(7);
              module2.exports = global2;
            },
            /* 129 */
            /***/
            (__unused_webpack_module, exports, __w_pdfjs_require__) => {
              "use strict";
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              exports.build = exports.RenderTask = exports.PDFWorkerUtil = exports.PDFWorker = exports.PDFPageProxy = exports.PDFDocumentProxy = exports.PDFDocumentLoadingTask = exports.PDFDataRangeTransport = exports.LoopbackPort = exports.DefaultStandardFontDataFactory = exports.DefaultCanvasFactory = exports.DefaultCMapReaderFactory = void 0;
              exports.getDocument = getDocument;
              exports.setPDFNetworkStreamFactory = setPDFNetworkStreamFactory;
              exports.version = void 0;
              var _util = __w_pdfjs_require__(1);
              var _annotation_storage = __w_pdfjs_require__(130);
              var _display_utils = __w_pdfjs_require__(133);
              var _font_loader = __w_pdfjs_require__(136);
              var _canvas = __w_pdfjs_require__(137);
              var _worker_options = __w_pdfjs_require__(140);
              var _is_node = __w_pdfjs_require__(3);
              var _message_handler = __w_pdfjs_require__(141);
              var _metadata = __w_pdfjs_require__(142);
              var _optional_content_config = __w_pdfjs_require__(143);
              var _transport_stream = __w_pdfjs_require__(144);
              var _xfa_text = __w_pdfjs_require__(145);
              function _classPrivateMethodInitSpec(obj, privateSet) {
                _checkPrivateRedeclaration(obj, privateSet);
                privateSet.add(obj);
              }
              function _classPrivateMethodGet(receiver, privateSet, fn) {
                if (!privateSet.has(receiver)) {
                  throw new TypeError("attempted to get private field on non-instance");
                }
                return fn;
              }
              function _classPrivateFieldInitSpec(obj, privateMap, value) {
                _checkPrivateRedeclaration(obj, privateMap);
                privateMap.set(obj, value);
              }
              function _checkPrivateRedeclaration(obj, privateCollection) {
                if (privateCollection.has(obj)) {
                  throw new TypeError("Cannot initialize the same private elements twice on an object");
                }
              }
              function _classPrivateFieldSet(receiver, privateMap, value) {
                var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set");
                _classApplyDescriptorSet(receiver, descriptor, value);
                return value;
              }
              function _classPrivateFieldGet(receiver, privateMap) {
                var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get");
                return _classApplyDescriptorGet(receiver, descriptor);
              }
              function _classExtractFieldDescriptor(receiver, privateMap, action) {
                if (!privateMap.has(receiver)) {
                  throw new TypeError("attempted to " + action + " private field on non-instance");
                }
                return privateMap.get(receiver);
              }
              function _classStaticPrivateFieldSpecSet(receiver, classConstructor, descriptor, value) {
                _classCheckPrivateStaticAccess(receiver, classConstructor);
                _classCheckPrivateStaticFieldDescriptor(descriptor, "set");
                _classApplyDescriptorSet(receiver, descriptor, value);
                return value;
              }
              function _classApplyDescriptorSet(receiver, descriptor, value) {
                if (descriptor.set) {
                  descriptor.set.call(receiver, value);
                } else {
                  if (!descriptor.writable) {
                    throw new TypeError("attempted to set read only private field");
                  }
                  descriptor.value = value;
                }
              }
              function _classStaticPrivateFieldSpecGet(receiver, classConstructor, descriptor) {
                _classCheckPrivateStaticAccess(receiver, classConstructor);
                _classCheckPrivateStaticFieldDescriptor(descriptor, "get");
                return _classApplyDescriptorGet(receiver, descriptor);
              }
              function _classCheckPrivateStaticFieldDescriptor(descriptor, action) {
                if (descriptor === void 0) {
                  throw new TypeError("attempted to " + action + " private static field before its declaration");
                }
              }
              function _classCheckPrivateStaticAccess(receiver, classConstructor) {
                if (receiver !== classConstructor) {
                  throw new TypeError("Private static access of wrong provenance");
                }
              }
              function _classApplyDescriptorGet(receiver, descriptor) {
                if (descriptor.get) {
                  return descriptor.get.call(receiver);
                }
                return descriptor.value;
              }
              const DEFAULT_RANGE_CHUNK_SIZE = 65536;
              const RENDERING_CANCELLED_TIMEOUT = 100;
              let DefaultCanvasFactory = _display_utils.DOMCanvasFactory;
              exports.DefaultCanvasFactory = DefaultCanvasFactory;
              let DefaultCMapReaderFactory = _display_utils.DOMCMapReaderFactory;
              exports.DefaultCMapReaderFactory = DefaultCMapReaderFactory;
              let DefaultStandardFontDataFactory = _display_utils.DOMStandardFontDataFactory;
              exports.DefaultStandardFontDataFactory = DefaultStandardFontDataFactory;
              if (_is_node.isNodeJS) {
                const {
                  NodeCanvasFactory,
                  NodeCMapReaderFactory,
                  NodeStandardFontDataFactory
                } = __w_pdfjs_require__(146);
                exports.DefaultCanvasFactory = DefaultCanvasFactory = NodeCanvasFactory;
                exports.DefaultCMapReaderFactory = DefaultCMapReaderFactory = NodeCMapReaderFactory;
                exports.DefaultStandardFontDataFactory = DefaultStandardFontDataFactory = NodeStandardFontDataFactory;
              }
              let createPDFNetworkStream;
              function setPDFNetworkStreamFactory(pdfNetworkStreamFactory) {
                createPDFNetworkStream = pdfNetworkStreamFactory;
              }
              function getDocument(src) {
                const task = new PDFDocumentLoadingTask();
                let source;
                if (typeof src === "string" || src instanceof URL) {
                  source = {
                    url: src
                  };
                } else if ((0, _util.isArrayBuffer)(src)) {
                  source = {
                    data: src
                  };
                } else if (src instanceof PDFDataRangeTransport) {
                  source = {
                    range: src
                  };
                } else {
                  if (typeof src !== "object") {
                    throw new Error("Invalid parameter in getDocument, need either string, URL, TypedArray, or parameter object.");
                  }
                  if (!src.url && !src.data && !src.range) {
                    throw new Error("Invalid parameter object: need either .data, .range or .url");
                  }
                  source = src;
                }
                const params = /* @__PURE__ */ Object.create(null);
                let rangeTransport = null, worker2 = null;
                for (const key in source) {
                  const value = source[key];
                  switch (key) {
                    case "url":
                      if (typeof window !== "undefined") {
                        try {
                          params[key] = new URL(value, window.location).href;
                          continue;
                        } catch (ex) {
                          (0, _util.warn)(`Cannot create valid URL: "${ex}".`);
                        }
                      } else if (typeof value === "string" || value instanceof URL) {
                        params[key] = value.toString();
                        continue;
                      }
                      throw new Error("Invalid PDF url data: either string or URL-object is expected in the url property.");
                    case "range":
                      rangeTransport = value;
                      continue;
                    case "worker":
                      worker2 = value;
                      continue;
                    case "data":
                      if (_is_node.isNodeJS && typeof Buffer !== "undefined" && value instanceof Buffer) {
                        params[key] = new Uint8Array(value);
                      } else if (value instanceof Uint8Array) {
                        break;
                      } else if (typeof value === "string") {
                        params[key] = (0, _util.stringToBytes)(value);
                      } else if (typeof value === "object" && value !== null && !isNaN(value.length)) {
                        params[key] = new Uint8Array(value);
                      } else if ((0, _util.isArrayBuffer)(value)) {
                        params[key] = new Uint8Array(value);
                      } else {
                        throw new Error("Invalid PDF binary data: either TypedArray, string, or array-like object is expected in the data property.");
                      }
                      continue;
                  }
                  params[key] = value;
                }
                params.CMapReaderFactory = params.CMapReaderFactory || DefaultCMapReaderFactory;
                params.StandardFontDataFactory = params.StandardFontDataFactory || DefaultStandardFontDataFactory;
                params.ignoreErrors = params.stopAtErrors !== true;
                params.fontExtraProperties = params.fontExtraProperties === true;
                params.pdfBug = params.pdfBug === true;
                params.enableXfa = params.enableXfa === true;
                if (!Number.isInteger(params.rangeChunkSize) || params.rangeChunkSize < 1) {
                  params.rangeChunkSize = DEFAULT_RANGE_CHUNK_SIZE;
                }
                if (typeof params.docBaseUrl !== "string" || (0, _display_utils.isDataScheme)(params.docBaseUrl)) {
                  params.docBaseUrl = null;
                }
                if (!Number.isInteger(params.maxImageSize) || params.maxImageSize < -1) {
                  params.maxImageSize = -1;
                }
                if (typeof params.cMapUrl !== "string") {
                  params.cMapUrl = null;
                }
                if (typeof params.standardFontDataUrl !== "string") {
                  params.standardFontDataUrl = null;
                }
                if (typeof params.useWorkerFetch !== "boolean") {
                  params.useWorkerFetch = params.CMapReaderFactory === _display_utils.DOMCMapReaderFactory && params.StandardFontDataFactory === _display_utils.DOMStandardFontDataFactory;
                }
                if (typeof params.isEvalSupported !== "boolean") {
                  params.isEvalSupported = true;
                }
                if (typeof params.disableFontFace !== "boolean") {
                  params.disableFontFace = _is_node.isNodeJS;
                }
                if (typeof params.useSystemFonts !== "boolean") {
                  params.useSystemFonts = !_is_node.isNodeJS && !params.disableFontFace;
                }
                if (typeof params.ownerDocument !== "object" || params.ownerDocument === null) {
                  params.ownerDocument = globalThis.document;
                }
                if (typeof params.disableRange !== "boolean") {
                  params.disableRange = false;
                }
                if (typeof params.disableStream !== "boolean") {
                  params.disableStream = false;
                }
                if (typeof params.disableAutoFetch !== "boolean") {
                  params.disableAutoFetch = false;
                }
                (0, _util.setVerbosityLevel)(params.verbosity);
                if (!worker2) {
                  const workerParams = {
                    verbosity: params.verbosity,
                    port: _worker_options.GlobalWorkerOptions.workerPort
                  };
                  worker2 = workerParams.port ? PDFWorker.fromPort(workerParams) : new PDFWorker(workerParams);
                  task._worker = worker2;
                }
                const docId = task.docId;
                worker2.promise.then(function() {
                  if (task.destroyed) {
                    throw new Error("Loading aborted");
                  }
                  const workerIdPromise = _fetchDocument(worker2, params, rangeTransport, docId);
                  const networkStreamPromise = new Promise(function(resolve) {
                    let networkStream;
                    if (rangeTransport) {
                      networkStream = new _transport_stream.PDFDataTransportStream({
                        length: params.length,
                        initialData: params.initialData,
                        progressiveDone: params.progressiveDone,
                        contentDispositionFilename: params.contentDispositionFilename,
                        disableRange: params.disableRange,
                        disableStream: params.disableStream
                      }, rangeTransport);
                    } else if (!params.data) {
                      networkStream = createPDFNetworkStream({
                        url: params.url,
                        length: params.length,
                        httpHeaders: params.httpHeaders,
                        withCredentials: params.withCredentials,
                        rangeChunkSize: params.rangeChunkSize,
                        disableRange: params.disableRange,
                        disableStream: params.disableStream
                      });
                    }
                    resolve(networkStream);
                  });
                  return Promise.all([workerIdPromise, networkStreamPromise]).then(function(_ref) {
                    let [workerId, networkStream] = _ref;
                    if (task.destroyed) {
                      throw new Error("Loading aborted");
                    }
                    const messageHandler = new _message_handler.MessageHandler(docId, workerId, worker2.port);
                    const transport = new WorkerTransport(messageHandler, task, networkStream, params);
                    task._transport = transport;
                    messageHandler.send("Ready", null);
                  });
                }).catch(task._capability.reject);
                return task;
              }
              async function _fetchDocument(worker2, source, pdfDataRangeTransport, docId) {
                if (worker2.destroyed) {
                  throw new Error("Worker was destroyed");
                }
                if (pdfDataRangeTransport) {
                  source.length = pdfDataRangeTransport.length;
                  source.initialData = pdfDataRangeTransport.initialData;
                  source.progressiveDone = pdfDataRangeTransport.progressiveDone;
                  source.contentDispositionFilename = pdfDataRangeTransport.contentDispositionFilename;
                }
                const workerId = await worker2.messageHandler.sendWithPromise("GetDocRequest", {
                  docId,
                  apiVersion: "2.16.105",
                  source: {
                    data: source.data,
                    url: source.url,
                    password: source.password,
                    disableAutoFetch: source.disableAutoFetch,
                    rangeChunkSize: source.rangeChunkSize,
                    length: source.length
                  },
                  maxImageSize: source.maxImageSize,
                  disableFontFace: source.disableFontFace,
                  docBaseUrl: source.docBaseUrl,
                  ignoreErrors: source.ignoreErrors,
                  isEvalSupported: source.isEvalSupported,
                  fontExtraProperties: source.fontExtraProperties,
                  enableXfa: source.enableXfa,
                  useSystemFonts: source.useSystemFonts,
                  cMapUrl: source.useWorkerFetch ? source.cMapUrl : null,
                  standardFontDataUrl: source.useWorkerFetch ? source.standardFontDataUrl : null
                });
                if (source.data) {
                  source.data = null;
                }
                if (worker2.destroyed) {
                  throw new Error("Worker was destroyed");
                }
                return workerId;
              }
              class PDFDocumentLoadingTask {
                constructor() {
                  var _PDFDocumentLoadingTa, _PDFDocumentLoadingTa2;
                  this._capability = (0, _util.createPromiseCapability)();
                  this._transport = null;
                  this._worker = null;
                  this.docId = `d${_classStaticPrivateFieldSpecSet(PDFDocumentLoadingTask, PDFDocumentLoadingTask, _docId, (_PDFDocumentLoadingTa = _classStaticPrivateFieldSpecGet(PDFDocumentLoadingTask, PDFDocumentLoadingTask, _docId), _PDFDocumentLoadingTa2 = _PDFDocumentLoadingTa++, _PDFDocumentLoadingTa)), _PDFDocumentLoadingTa2}`;
                  this.destroyed = false;
                  this.onPassword = null;
                  this.onProgress = null;
                  this.onUnsupportedFeature = null;
                }
                get promise() {
                  return this._capability.promise;
                }
                async destroy() {
                  var _this$_transport;
                  this.destroyed = true;
                  await ((_this$_transport = this._transport) === null || _this$_transport === void 0 ? void 0 : _this$_transport.destroy());
                  this._transport = null;
                  if (this._worker) {
                    this._worker.destroy();
                    this._worker = null;
                  }
                }
              }
              exports.PDFDocumentLoadingTask = PDFDocumentLoadingTask;
              var _docId = {
                writable: true,
                value: 0
              };
              class PDFDataRangeTransport {
                constructor(length, initialData) {
                  let progressiveDone = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                  let contentDispositionFilename = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
                  this.length = length;
                  this.initialData = initialData;
                  this.progressiveDone = progressiveDone;
                  this.contentDispositionFilename = contentDispositionFilename;
                  this._rangeListeners = [];
                  this._progressListeners = [];
                  this._progressiveReadListeners = [];
                  this._progressiveDoneListeners = [];
                  this._readyCapability = (0, _util.createPromiseCapability)();
                }
                addRangeListener(listener) {
                  this._rangeListeners.push(listener);
                }
                addProgressListener(listener) {
                  this._progressListeners.push(listener);
                }
                addProgressiveReadListener(listener) {
                  this._progressiveReadListeners.push(listener);
                }
                addProgressiveDoneListener(listener) {
                  this._progressiveDoneListeners.push(listener);
                }
                onDataRange(begin, chunk) {
                  for (const listener of this._rangeListeners) {
                    listener(begin, chunk);
                  }
                }
                onDataProgress(loaded, total) {
                  this._readyCapability.promise.then(() => {
                    for (const listener of this._progressListeners) {
                      listener(loaded, total);
                    }
                  });
                }
                onDataProgressiveRead(chunk) {
                  this._readyCapability.promise.then(() => {
                    for (const listener of this._progressiveReadListeners) {
                      listener(chunk);
                    }
                  });
                }
                onDataProgressiveDone() {
                  this._readyCapability.promise.then(() => {
                    for (const listener of this._progressiveDoneListeners) {
                      listener();
                    }
                  });
                }
                transportReady() {
                  this._readyCapability.resolve();
                }
                requestDataRange(begin, end) {
                  (0, _util.unreachable)("Abstract method PDFDataRangeTransport.requestDataRange");
                }
                abort() {
                }
              }
              exports.PDFDataRangeTransport = PDFDataRangeTransport;
              class PDFDocumentProxy {
                constructor(pdfInfo, transport) {
                  this._pdfInfo = pdfInfo;
                  this._transport = transport;
                  Object.defineProperty(this, "fingerprint", {
                    get() {
                      (0, _display_utils.deprecated)("`PDFDocumentProxy.fingerprint`, please use `PDFDocumentProxy.fingerprints` instead.");
                      return this.fingerprints[0];
                    }
                  });
                  Object.defineProperty(this, "getStats", {
                    value: async () => {
                      (0, _display_utils.deprecated)("`PDFDocumentProxy.getStats`, please use the `PDFDocumentProxy.stats`-getter instead.");
                      return this.stats || {
                        streamTypes: {},
                        fontTypes: {}
                      };
                    }
                  });
                }
                get annotationStorage() {
                  return this._transport.annotationStorage;
                }
                get numPages() {
                  return this._pdfInfo.numPages;
                }
                get fingerprints() {
                  return this._pdfInfo.fingerprints;
                }
                get stats() {
                  return this._transport.stats;
                }
                get isPureXfa() {
                  return !!this._transport._htmlForXfa;
                }
                get allXfaHtml() {
                  return this._transport._htmlForXfa;
                }
                getPage(pageNumber) {
                  return this._transport.getPage(pageNumber);
                }
                getPageIndex(ref) {
                  return this._transport.getPageIndex(ref);
                }
                getDestinations() {
                  return this._transport.getDestinations();
                }
                getDestination(id) {
                  return this._transport.getDestination(id);
                }
                getPageLabels() {
                  return this._transport.getPageLabels();
                }
                getPageLayout() {
                  return this._transport.getPageLayout();
                }
                getPageMode() {
                  return this._transport.getPageMode();
                }
                getViewerPreferences() {
                  return this._transport.getViewerPreferences();
                }
                getOpenAction() {
                  return this._transport.getOpenAction();
                }
                getAttachments() {
                  return this._transport.getAttachments();
                }
                getJavaScript() {
                  return this._transport.getJavaScript();
                }
                getJSActions() {
                  return this._transport.getDocJSActions();
                }
                getOutline() {
                  return this._transport.getOutline();
                }
                getOptionalContentConfig() {
                  return this._transport.getOptionalContentConfig();
                }
                getPermissions() {
                  return this._transport.getPermissions();
                }
                getMetadata() {
                  return this._transport.getMetadata();
                }
                getMarkInfo() {
                  return this._transport.getMarkInfo();
                }
                getData() {
                  return this._transport.getData();
                }
                getDownloadInfo() {
                  return this._transport.downloadInfoCapability.promise;
                }
                cleanup() {
                  let keepLoadedFonts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
                  return this._transport.startCleanup(keepLoadedFonts || this.isPureXfa);
                }
                destroy() {
                  return this.loadingTask.destroy();
                }
                get loadingParams() {
                  return this._transport.loadingParams;
                }
                get loadingTask() {
                  return this._transport.loadingTask;
                }
                saveDocument() {
                  if (this._transport.annotationStorage.size <= 0) {
                    (0, _display_utils.deprecated)("saveDocument called while `annotationStorage` is empty, please use the getData-method instead.");
                  }
                  return this._transport.saveDocument();
                }
                getFieldObjects() {
                  return this._transport.getFieldObjects();
                }
                hasJSActions() {
                  return this._transport.hasJSActions();
                }
                getCalculationOrderIds() {
                  return this._transport.getCalculationOrderIds();
                }
              }
              exports.PDFDocumentProxy = PDFDocumentProxy;
              class PDFPageProxy {
                constructor(pageIndex, pageInfo, transport, ownerDocument) {
                  let pdfBug = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
                  this._pageIndex = pageIndex;
                  this._pageInfo = pageInfo;
                  this._ownerDocument = ownerDocument;
                  this._transport = transport;
                  this._stats = pdfBug ? new _display_utils.StatTimer() : null;
                  this._pdfBug = pdfBug;
                  this.commonObjs = transport.commonObjs;
                  this.objs = new PDFObjects();
                  this._bitmaps = /* @__PURE__ */ new Set();
                  this.cleanupAfterRender = false;
                  this.pendingCleanup = false;
                  this._intentStates = /* @__PURE__ */ new Map();
                  this._annotationPromises = /* @__PURE__ */ new Map();
                  this.destroyed = false;
                }
                get pageNumber() {
                  return this._pageIndex + 1;
                }
                get rotate() {
                  return this._pageInfo.rotate;
                }
                get ref() {
                  return this._pageInfo.ref;
                }
                get userUnit() {
                  return this._pageInfo.userUnit;
                }
                get view() {
                  return this._pageInfo.view;
                }
                getViewport() {
                  let {
                    scale,
                    rotation = this.rotate,
                    offsetX = 0,
                    offsetY = 0,
                    dontFlip = false
                  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                  return new _display_utils.PageViewport({
                    viewBox: this.view,
                    scale,
                    rotation,
                    offsetX,
                    offsetY,
                    dontFlip
                  });
                }
                getAnnotations() {
                  let {
                    intent = "display"
                  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                  const intentArgs = this._transport.getRenderingIntent(intent);
                  let promise = this._annotationPromises.get(intentArgs.cacheKey);
                  if (!promise) {
                    promise = this._transport.getAnnotations(this._pageIndex, intentArgs.renderingIntent);
                    this._annotationPromises.set(intentArgs.cacheKey, promise);
                    promise = promise.then((annotations) => {
                      for (const annotation of annotations) {
                        if (annotation.titleObj !== void 0) {
                          Object.defineProperty(annotation, "title", {
                            get() {
                              (0, _display_utils.deprecated)("`title`-property on annotation, please use `titleObj` instead.");
                              return annotation.titleObj.str;
                            }
                          });
                        }
                        if (annotation.contentsObj !== void 0) {
                          Object.defineProperty(annotation, "contents", {
                            get() {
                              (0, _display_utils.deprecated)("`contents`-property on annotation, please use `contentsObj` instead.");
                              return annotation.contentsObj.str;
                            }
                          });
                        }
                      }
                      return annotations;
                    });
                  }
                  return promise;
                }
                getJSActions() {
                  return this._jsActionsPromise || (this._jsActionsPromise = this._transport.getPageJSActions(this._pageIndex));
                }
                async getXfa() {
                  var _this$_transport$_htm;
                  return ((_this$_transport$_htm = this._transport._htmlForXfa) === null || _this$_transport$_htm === void 0 ? void 0 : _this$_transport$_htm.children[this._pageIndex]) || null;
                }
                render(_ref2) {
                  var _arguments$, _arguments$2, _intentState;
                  let {
                    canvasContext,
                    viewport,
                    intent = "display",
                    annotationMode = _util.AnnotationMode.ENABLE,
                    transform = null,
                    imageLayer = null,
                    canvasFactory = null,
                    background = null,
                    optionalContentConfigPromise = null,
                    annotationCanvasMap = null,
                    pageColors = null,
                    printAnnotationStorage = null
                  } = _ref2;
                  if (((_arguments$ = arguments[0]) === null || _arguments$ === void 0 ? void 0 : _arguments$.renderInteractiveForms) !== void 0) {
                    (0, _display_utils.deprecated)("render no longer accepts the `renderInteractiveForms`-option, please use the `annotationMode`-option instead.");
                    if (arguments[0].renderInteractiveForms === true && annotationMode === _util.AnnotationMode.ENABLE) {
                      annotationMode = _util.AnnotationMode.ENABLE_FORMS;
                    }
                  }
                  if (((_arguments$2 = arguments[0]) === null || _arguments$2 === void 0 ? void 0 : _arguments$2.includeAnnotationStorage) !== void 0) {
                    (0, _display_utils.deprecated)("render no longer accepts the `includeAnnotationStorage`-option, please use the `annotationMode`-option instead.");
                    if (arguments[0].includeAnnotationStorage === true && annotationMode === _util.AnnotationMode.ENABLE) {
                      annotationMode = _util.AnnotationMode.ENABLE_STORAGE;
                    }
                  }
                  if (this._stats) {
                    this._stats.time("Overall");
                  }
                  const intentArgs = this._transport.getRenderingIntent(intent, annotationMode, printAnnotationStorage);
                  this.pendingCleanup = false;
                  if (!optionalContentConfigPromise) {
                    optionalContentConfigPromise = this._transport.getOptionalContentConfig();
                  }
                  let intentState = this._intentStates.get(intentArgs.cacheKey);
                  if (!intentState) {
                    intentState = /* @__PURE__ */ Object.create(null);
                    this._intentStates.set(intentArgs.cacheKey, intentState);
                  }
                  if (intentState.streamReaderCancelTimeout) {
                    clearTimeout(intentState.streamReaderCancelTimeout);
                    intentState.streamReaderCancelTimeout = null;
                  }
                  const canvasFactoryInstance = canvasFactory || new DefaultCanvasFactory({
                    ownerDocument: this._ownerDocument
                  });
                  const intentPrint = !!(intentArgs.renderingIntent & _util.RenderingIntentFlag.PRINT);
                  if (!intentState.displayReadyCapability) {
                    intentState.displayReadyCapability = (0, _util.createPromiseCapability)();
                    intentState.operatorList = {
                      fnArray: [],
                      argsArray: [],
                      lastChunk: false,
                      separateAnnots: null
                    };
                    if (this._stats) {
                      this._stats.time("Page Request");
                    }
                    this._pumpOperatorList(intentArgs);
                  }
                  const complete = (error) => {
                    intentState.renderTasks.delete(internalRenderTask);
                    if (this.cleanupAfterRender || intentPrint) {
                      this.pendingCleanup = true;
                    }
                    this._tryCleanup();
                    if (error) {
                      internalRenderTask.capability.reject(error);
                      this._abortOperatorList({
                        intentState,
                        reason: error instanceof Error ? error : new Error(error)
                      });
                    } else {
                      internalRenderTask.capability.resolve();
                    }
                    if (this._stats) {
                      this._stats.timeEnd("Rendering");
                      this._stats.timeEnd("Overall");
                    }
                  };
                  const internalRenderTask = new InternalRenderTask({
                    callback: complete,
                    params: {
                      canvasContext,
                      viewport,
                      transform,
                      imageLayer,
                      background
                    },
                    objs: this.objs,
                    commonObjs: this.commonObjs,
                    annotationCanvasMap,
                    operatorList: intentState.operatorList,
                    pageIndex: this._pageIndex,
                    canvasFactory: canvasFactoryInstance,
                    useRequestAnimationFrame: !intentPrint,
                    pdfBug: this._pdfBug,
                    pageColors
                  });
                  ((_intentState = intentState).renderTasks || (_intentState.renderTasks = /* @__PURE__ */ new Set())).add(internalRenderTask);
                  const renderTask = internalRenderTask.task;
                  Promise.all([intentState.displayReadyCapability.promise, optionalContentConfigPromise]).then((_ref3) => {
                    let [transparency, optionalContentConfig] = _ref3;
                    if (this.pendingCleanup) {
                      complete();
                      return;
                    }
                    if (this._stats) {
                      this._stats.time("Rendering");
                    }
                    internalRenderTask.initializeGraphics({
                      transparency,
                      optionalContentConfig
                    });
                    internalRenderTask.operatorListChanged();
                  }).catch(complete);
                  return renderTask;
                }
                getOperatorList() {
                  let {
                    intent = "display",
                    annotationMode = _util.AnnotationMode.ENABLE,
                    printAnnotationStorage = null
                  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                  function operatorListChanged() {
                    if (intentState.operatorList.lastChunk) {
                      intentState.opListReadCapability.resolve(intentState.operatorList);
                      intentState.renderTasks.delete(opListTask);
                    }
                  }
                  const intentArgs = this._transport.getRenderingIntent(intent, annotationMode, printAnnotationStorage, true);
                  let intentState = this._intentStates.get(intentArgs.cacheKey);
                  if (!intentState) {
                    intentState = /* @__PURE__ */ Object.create(null);
                    this._intentStates.set(intentArgs.cacheKey, intentState);
                  }
                  let opListTask;
                  if (!intentState.opListReadCapability) {
                    var _intentState2;
                    opListTask = /* @__PURE__ */ Object.create(null);
                    opListTask.operatorListChanged = operatorListChanged;
                    intentState.opListReadCapability = (0, _util.createPromiseCapability)();
                    ((_intentState2 = intentState).renderTasks || (_intentState2.renderTasks = /* @__PURE__ */ new Set())).add(opListTask);
                    intentState.operatorList = {
                      fnArray: [],
                      argsArray: [],
                      lastChunk: false,
                      separateAnnots: null
                    };
                    if (this._stats) {
                      this._stats.time("Page Request");
                    }
                    this._pumpOperatorList(intentArgs);
                  }
                  return intentState.opListReadCapability.promise;
                }
                streamTextContent() {
                  let {
                    disableCombineTextItems = false,
                    includeMarkedContent = false
                  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                  const TEXT_CONTENT_CHUNK_SIZE = 100;
                  return this._transport.messageHandler.sendWithStream("GetTextContent", {
                    pageIndex: this._pageIndex,
                    combineTextItems: disableCombineTextItems !== true,
                    includeMarkedContent: includeMarkedContent === true
                  }, {
                    highWaterMark: TEXT_CONTENT_CHUNK_SIZE,
                    size(textContent) {
                      return textContent.items.length;
                    }
                  });
                }
                getTextContent() {
                  let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                  if (this._transport._htmlForXfa) {
                    return this.getXfa().then((xfa) => {
                      return _xfa_text.XfaText.textContent(xfa);
                    });
                  }
                  const readableStream = this.streamTextContent(params);
                  return new Promise(function(resolve, reject) {
                    function pump() {
                      reader.read().then(function(_ref4) {
                        let {
                          value,
                          done
                        } = _ref4;
                        if (done) {
                          resolve(textContent);
                          return;
                        }
                        Object.assign(textContent.styles, value.styles);
                        textContent.items.push(...value.items);
                        pump();
                      }, reject);
                    }
                    const reader = readableStream.getReader();
                    const textContent = {
                      items: [],
                      styles: /* @__PURE__ */ Object.create(null)
                    };
                    pump();
                  });
                }
                getStructTree() {
                  return this._structTreePromise || (this._structTreePromise = this._transport.getStructTree(this._pageIndex));
                }
                _destroy() {
                  this.destroyed = true;
                  const waitOn = [];
                  for (const intentState of this._intentStates.values()) {
                    this._abortOperatorList({
                      intentState,
                      reason: new Error("Page was destroyed."),
                      force: true
                    });
                    if (intentState.opListReadCapability) {
                      continue;
                    }
                    for (const internalRenderTask of intentState.renderTasks) {
                      waitOn.push(internalRenderTask.completed);
                      internalRenderTask.cancel();
                    }
                  }
                  this.objs.clear();
                  for (const bitmap of this._bitmaps) {
                    bitmap.close();
                  }
                  this._bitmaps.clear();
                  this._annotationPromises.clear();
                  this._jsActionsPromise = null;
                  this._structTreePromise = null;
                  this.pendingCleanup = false;
                  return Promise.all(waitOn);
                }
                cleanup() {
                  let resetStats = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
                  this.pendingCleanup = true;
                  return this._tryCleanup(resetStats);
                }
                _tryCleanup() {
                  let resetStats = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
                  if (!this.pendingCleanup) {
                    return false;
                  }
                  for (const {
                    renderTasks,
                    operatorList
                  } of this._intentStates.values()) {
                    if (renderTasks.size > 0 || !operatorList.lastChunk) {
                      return false;
                    }
                  }
                  this._intentStates.clear();
                  this.objs.clear();
                  this._annotationPromises.clear();
                  this._jsActionsPromise = null;
                  this._structTreePromise = null;
                  if (resetStats && this._stats) {
                    this._stats = new _display_utils.StatTimer();
                  }
                  for (const bitmap of this._bitmaps) {
                    bitmap.close();
                  }
                  this._bitmaps.clear();
                  this.pendingCleanup = false;
                  return true;
                }
                _startRenderPage(transparency, cacheKey) {
                  const intentState = this._intentStates.get(cacheKey);
                  if (!intentState) {
                    return;
                  }
                  if (this._stats) {
                    this._stats.timeEnd("Page Request");
                  }
                  if (intentState.displayReadyCapability) {
                    intentState.displayReadyCapability.resolve(transparency);
                  }
                }
                _renderPageChunk(operatorListChunk, intentState) {
                  for (let i = 0, ii = operatorListChunk.length; i < ii; i++) {
                    intentState.operatorList.fnArray.push(operatorListChunk.fnArray[i]);
                    intentState.operatorList.argsArray.push(operatorListChunk.argsArray[i]);
                  }
                  intentState.operatorList.lastChunk = operatorListChunk.lastChunk;
                  intentState.operatorList.separateAnnots = operatorListChunk.separateAnnots;
                  for (const internalRenderTask of intentState.renderTasks) {
                    internalRenderTask.operatorListChanged();
                  }
                  if (operatorListChunk.lastChunk) {
                    this._tryCleanup();
                  }
                }
                _pumpOperatorList(_ref5) {
                  let {
                    renderingIntent,
                    cacheKey,
                    annotationStorageMap
                  } = _ref5;
                  const readableStream = this._transport.messageHandler.sendWithStream("GetOperatorList", {
                    pageIndex: this._pageIndex,
                    intent: renderingIntent,
                    cacheKey,
                    annotationStorage: annotationStorageMap
                  });
                  const reader = readableStream.getReader();
                  const intentState = this._intentStates.get(cacheKey);
                  intentState.streamReader = reader;
                  const pump = () => {
                    reader.read().then((_ref6) => {
                      let {
                        value,
                        done
                      } = _ref6;
                      if (done) {
                        intentState.streamReader = null;
                        return;
                      }
                      if (this._transport.destroyed) {
                        return;
                      }
                      this._renderPageChunk(value, intentState);
                      pump();
                    }, (reason) => {
                      intentState.streamReader = null;
                      if (this._transport.destroyed) {
                        return;
                      }
                      if (intentState.operatorList) {
                        intentState.operatorList.lastChunk = true;
                        for (const internalRenderTask of intentState.renderTasks) {
                          internalRenderTask.operatorListChanged();
                        }
                        this._tryCleanup();
                      }
                      if (intentState.displayReadyCapability) {
                        intentState.displayReadyCapability.reject(reason);
                      } else if (intentState.opListReadCapability) {
                        intentState.opListReadCapability.reject(reason);
                      } else {
                        throw reason;
                      }
                    });
                  };
                  pump();
                }
                _abortOperatorList(_ref7) {
                  let {
                    intentState,
                    reason,
                    force = false
                  } = _ref7;
                  if (!intentState.streamReader) {
                    return;
                  }
                  if (!force) {
                    if (intentState.renderTasks.size > 0) {
                      return;
                    }
                    if (reason instanceof _display_utils.RenderingCancelledException) {
                      intentState.streamReaderCancelTimeout = setTimeout(() => {
                        this._abortOperatorList({
                          intentState,
                          reason,
                          force: true
                        });
                        intentState.streamReaderCancelTimeout = null;
                      }, RENDERING_CANCELLED_TIMEOUT);
                      return;
                    }
                  }
                  intentState.streamReader.cancel(new _util.AbortException(reason.message)).catch(() => {
                  });
                  intentState.streamReader = null;
                  if (this._transport.destroyed) {
                    return;
                  }
                  for (const [curCacheKey, curIntentState] of this._intentStates) {
                    if (curIntentState === intentState) {
                      this._intentStates.delete(curCacheKey);
                      break;
                    }
                  }
                  this.cleanup();
                }
                get stats() {
                  return this._stats;
                }
              }
              exports.PDFPageProxy = PDFPageProxy;
              class LoopbackPort {
                constructor() {
                  this._listeners = [];
                  this._deferred = Promise.resolve();
                }
                postMessage(obj, transfers) {
                  const event = {
                    data: structuredClone(obj, transfers)
                  };
                  this._deferred.then(() => {
                    for (const listener of this._listeners) {
                      listener.call(this, event);
                    }
                  });
                }
                addEventListener(name, listener) {
                  this._listeners.push(listener);
                }
                removeEventListener(name, listener) {
                  const i = this._listeners.indexOf(listener);
                  this._listeners.splice(i, 1);
                }
                terminate() {
                  this._listeners.length = 0;
                }
              }
              exports.LoopbackPort = LoopbackPort;
              const PDFWorkerUtil = {
                isWorkerDisabled: false,
                fallbackWorkerSrc: null,
                fakeWorkerId: 0
              };
              exports.PDFWorkerUtil = PDFWorkerUtil;
              {
                if (_is_node.isNodeJS && typeof __require === "function") {
                  PDFWorkerUtil.isWorkerDisabled = true;
                  PDFWorkerUtil.fallbackWorkerSrc = "./pdf.worker.js";
                } else if (typeof document === "object") {
                  var _document, _document$currentScri;
                  const pdfjsFilePath = (_document = document) === null || _document === void 0 ? void 0 : (_document$currentScri = _document.currentScript) === null || _document$currentScri === void 0 ? void 0 : _document$currentScri.src;
                  if (pdfjsFilePath) {
                    PDFWorkerUtil.fallbackWorkerSrc = pdfjsFilePath.replace(/(\.(?:min\.)?js)(\?.*)?$/i, ".worker$1$2");
                  }
                }
                PDFWorkerUtil.isSameOrigin = function(baseUrl, otherUrl) {
                  let base;
                  try {
                    base = new URL(baseUrl);
                    if (!base.origin || base.origin === "null") {
                      return false;
                    }
                  } catch (e) {
                    return false;
                  }
                  const other = new URL(otherUrl, base);
                  return base.origin === other.origin;
                };
                PDFWorkerUtil.createCDNWrapper = function(url) {
                  const wrapper = `importScripts("${url}");`;
                  return URL.createObjectURL(new Blob([wrapper]));
                };
              }
              class PDFWorker {
                constructor() {
                  let {
                    name = null,
                    port = null,
                    verbosity = (0, _util.getVerbosityLevel)()
                  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                  if (port && _classStaticPrivateFieldSpecGet(PDFWorker, PDFWorker, _workerPorts).has(port)) {
                    throw new Error("Cannot use more than one PDFWorker per port.");
                  }
                  this.name = name;
                  this.destroyed = false;
                  this.verbosity = verbosity;
                  this._readyCapability = (0, _util.createPromiseCapability)();
                  this._port = null;
                  this._webWorker = null;
                  this._messageHandler = null;
                  if (port) {
                    _classStaticPrivateFieldSpecGet(PDFWorker, PDFWorker, _workerPorts).set(port, this);
                    this._initializeFromPort(port);
                    return;
                  }
                  this._initialize();
                }
                get promise() {
                  return this._readyCapability.promise;
                }
                get port() {
                  return this._port;
                }
                get messageHandler() {
                  return this._messageHandler;
                }
                _initializeFromPort(port) {
                  this._port = port;
                  this._messageHandler = new _message_handler.MessageHandler("main", "worker", port);
                  this._messageHandler.on("ready", function() {
                  });
                  this._readyCapability.resolve();
                }
                _initialize() {
                  if (!PDFWorkerUtil.isWorkerDisabled && !PDFWorker._mainThreadWorkerMessageHandler) {
                    let {
                      workerSrc
                    } = PDFWorker;
                    try {
                      if (!PDFWorkerUtil.isSameOrigin(window.location.href, workerSrc)) {
                        workerSrc = PDFWorkerUtil.createCDNWrapper(new URL(workerSrc, window.location).href);
                      }
                      const worker2 = new Worker(workerSrc);
                      const messageHandler = new _message_handler.MessageHandler("main", "worker", worker2);
                      const terminateEarly = () => {
                        worker2.removeEventListener("error", onWorkerError);
                        messageHandler.destroy();
                        worker2.terminate();
                        if (this.destroyed) {
                          this._readyCapability.reject(new Error("Worker was destroyed"));
                        } else {
                          this._setupFakeWorker();
                        }
                      };
                      const onWorkerError = () => {
                        if (!this._webWorker) {
                          terminateEarly();
                        }
                      };
                      worker2.addEventListener("error", onWorkerError);
                      messageHandler.on("test", (data) => {
                        worker2.removeEventListener("error", onWorkerError);
                        if (this.destroyed) {
                          terminateEarly();
                          return;
                        }
                        if (data) {
                          this._messageHandler = messageHandler;
                          this._port = worker2;
                          this._webWorker = worker2;
                          this._readyCapability.resolve();
                          messageHandler.send("configure", {
                            verbosity: this.verbosity
                          });
                        } else {
                          this._setupFakeWorker();
                          messageHandler.destroy();
                          worker2.terminate();
                        }
                      });
                      messageHandler.on("ready", (data) => {
                        worker2.removeEventListener("error", onWorkerError);
                        if (this.destroyed) {
                          terminateEarly();
                          return;
                        }
                        try {
                          sendTest();
                        } catch (e) {
                          this._setupFakeWorker();
                        }
                      });
                      const sendTest = () => {
                        const testObj = new Uint8Array();
                        messageHandler.send("test", testObj, [testObj.buffer]);
                      };
                      sendTest();
                      return;
                    } catch (e) {
                      (0, _util.info)("The worker has been disabled.");
                    }
                  }
                  this._setupFakeWorker();
                }
                _setupFakeWorker() {
                  if (!PDFWorkerUtil.isWorkerDisabled) {
                    (0, _util.warn)("Setting up fake worker.");
                    PDFWorkerUtil.isWorkerDisabled = true;
                  }
                  PDFWorker._setupFakeWorkerGlobal.then((WorkerMessageHandler) => {
                    if (this.destroyed) {
                      this._readyCapability.reject(new Error("Worker was destroyed"));
                      return;
                    }
                    const port = new LoopbackPort();
                    this._port = port;
                    const id = `fake${PDFWorkerUtil.fakeWorkerId++}`;
                    const workerHandler = new _message_handler.MessageHandler(id + "_worker", id, port);
                    WorkerMessageHandler.setup(workerHandler, port);
                    const messageHandler = new _message_handler.MessageHandler(id, id + "_worker", port);
                    this._messageHandler = messageHandler;
                    this._readyCapability.resolve();
                    messageHandler.send("configure", {
                      verbosity: this.verbosity
                    });
                  }).catch((reason) => {
                    this._readyCapability.reject(new Error(`Setting up fake worker failed: "${reason.message}".`));
                  });
                }
                destroy() {
                  this.destroyed = true;
                  if (this._webWorker) {
                    this._webWorker.terminate();
                    this._webWorker = null;
                  }
                  _classStaticPrivateFieldSpecGet(PDFWorker, PDFWorker, _workerPorts).delete(this._port);
                  this._port = null;
                  if (this._messageHandler) {
                    this._messageHandler.destroy();
                    this._messageHandler = null;
                  }
                }
                static fromPort(params) {
                  if (!(params !== null && params !== void 0 && params.port)) {
                    throw new Error("PDFWorker.fromPort - invalid method signature.");
                  }
                  if (_classStaticPrivateFieldSpecGet(this, PDFWorker, _workerPorts).has(params.port)) {
                    return _classStaticPrivateFieldSpecGet(this, PDFWorker, _workerPorts).get(params.port);
                  }
                  return new PDFWorker(params);
                }
                static get workerSrc() {
                  if (_worker_options.GlobalWorkerOptions.workerSrc) {
                    return _worker_options.GlobalWorkerOptions.workerSrc;
                  }
                  if (PDFWorkerUtil.fallbackWorkerSrc !== null) {
                    if (!_is_node.isNodeJS) {
                      (0, _display_utils.deprecated)('No "GlobalWorkerOptions.workerSrc" specified.');
                    }
                    return PDFWorkerUtil.fallbackWorkerSrc;
                  }
                  throw new Error('No "GlobalWorkerOptions.workerSrc" specified.');
                }
                static get _mainThreadWorkerMessageHandler() {
                  try {
                    var _globalThis$pdfjsWork;
                    return ((_globalThis$pdfjsWork = globalThis.pdfjsWorker) === null || _globalThis$pdfjsWork === void 0 ? void 0 : _globalThis$pdfjsWork.WorkerMessageHandler) || null;
                  } catch (ex) {
                    return null;
                  }
                }
                static get _setupFakeWorkerGlobal() {
                  const loader = async () => {
                    const mainWorkerMessageHandler = this._mainThreadWorkerMessageHandler;
                    if (mainWorkerMessageHandler) {
                      return mainWorkerMessageHandler;
                    }
                    if (_is_node.isNodeJS && typeof __require === "function") {
                      const worker = eval("require")(this.workerSrc);
                      return worker.WorkerMessageHandler;
                    }
                    await (0, _display_utils.loadScript)(this.workerSrc);
                    return window.pdfjsWorker.WorkerMessageHandler;
                  };
                  return (0, _util.shadow)(this, "_setupFakeWorkerGlobal", loader());
                }
              }
              exports.PDFWorker = PDFWorker;
              var _workerPorts = {
                writable: true,
                value: /* @__PURE__ */ new WeakMap()
              };
              {
                PDFWorker.getWorkerSrc = function() {
                  (0, _display_utils.deprecated)("`PDFWorker.getWorkerSrc()`, please use `PDFWorker.workerSrc` instead.");
                  return this.workerSrc;
                };
              }
              var _docStats = /* @__PURE__ */ new WeakMap();
              var _pageCache = /* @__PURE__ */ new WeakMap();
              var _pagePromises = /* @__PURE__ */ new WeakMap();
              var _metadataPromise = /* @__PURE__ */ new WeakMap();
              class WorkerTransport {
                constructor(messageHandler, loadingTask, networkStream, params) {
                  _classPrivateFieldInitSpec(this, _docStats, {
                    writable: true,
                    value: null
                  });
                  _classPrivateFieldInitSpec(this, _pageCache, {
                    writable: true,
                    value: /* @__PURE__ */ new Map()
                  });
                  _classPrivateFieldInitSpec(this, _pagePromises, {
                    writable: true,
                    value: /* @__PURE__ */ new Map()
                  });
                  _classPrivateFieldInitSpec(this, _metadataPromise, {
                    writable: true,
                    value: null
                  });
                  this.messageHandler = messageHandler;
                  this.loadingTask = loadingTask;
                  this.commonObjs = new PDFObjects();
                  this.fontLoader = new _font_loader.FontLoader({
                    docId: loadingTask.docId,
                    onUnsupportedFeature: this._onUnsupportedFeature.bind(this),
                    ownerDocument: params.ownerDocument,
                    styleElement: params.styleElement
                  });
                  this._params = params;
                  if (!params.useWorkerFetch) {
                    this.CMapReaderFactory = new params.CMapReaderFactory({
                      baseUrl: params.cMapUrl,
                      isCompressed: params.cMapPacked
                    });
                    this.StandardFontDataFactory = new params.StandardFontDataFactory({
                      baseUrl: params.standardFontDataUrl
                    });
                  }
                  this.destroyed = false;
                  this.destroyCapability = null;
                  this._passwordCapability = null;
                  this._networkStream = networkStream;
                  this._fullReader = null;
                  this._lastProgress = null;
                  this.downloadInfoCapability = (0, _util.createPromiseCapability)();
                  this.setupMessageHandler();
                }
                get annotationStorage() {
                  return (0, _util.shadow)(this, "annotationStorage", new _annotation_storage.AnnotationStorage());
                }
                get stats() {
                  return _classPrivateFieldGet(this, _docStats);
                }
                getRenderingIntent(intent) {
                  let annotationMode = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _util.AnnotationMode.ENABLE;
                  let printAnnotationStorage = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
                  let isOpList = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
                  let renderingIntent = _util.RenderingIntentFlag.DISPLAY;
                  let annotationMap = null;
                  switch (intent) {
                    case "any":
                      renderingIntent = _util.RenderingIntentFlag.ANY;
                      break;
                    case "display":
                      break;
                    case "print":
                      renderingIntent = _util.RenderingIntentFlag.PRINT;
                      break;
                    default:
                      (0, _util.warn)(`getRenderingIntent - invalid intent: ${intent}`);
                  }
                  switch (annotationMode) {
                    case _util.AnnotationMode.DISABLE:
                      renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_DISABLE;
                      break;
                    case _util.AnnotationMode.ENABLE:
                      break;
                    case _util.AnnotationMode.ENABLE_FORMS:
                      renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_FORMS;
                      break;
                    case _util.AnnotationMode.ENABLE_STORAGE:
                      renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_STORAGE;
                      const annotationStorage = renderingIntent & _util.RenderingIntentFlag.PRINT && printAnnotationStorage instanceof _annotation_storage.PrintAnnotationStorage ? printAnnotationStorage : this.annotationStorage;
                      annotationMap = annotationStorage.serializable;
                      break;
                    default:
                      (0, _util.warn)(`getRenderingIntent - invalid annotationMode: ${annotationMode}`);
                  }
                  if (isOpList) {
                    renderingIntent += _util.RenderingIntentFlag.OPLIST;
                  }
                  return {
                    renderingIntent,
                    cacheKey: `${renderingIntent}_${_annotation_storage.AnnotationStorage.getHash(annotationMap)}`,
                    annotationStorageMap: annotationMap
                  };
                }
                destroy() {
                  if (this.destroyCapability) {
                    return this.destroyCapability.promise;
                  }
                  this.destroyed = true;
                  this.destroyCapability = (0, _util.createPromiseCapability)();
                  if (this._passwordCapability) {
                    this._passwordCapability.reject(new Error("Worker was destroyed during onPassword callback"));
                  }
                  const waitOn = [];
                  for (const page of _classPrivateFieldGet(this, _pageCache).values()) {
                    waitOn.push(page._destroy());
                  }
                  _classPrivateFieldGet(this, _pageCache).clear();
                  _classPrivateFieldGet(this, _pagePromises).clear();
                  if (this.hasOwnProperty("annotationStorage")) {
                    this.annotationStorage.resetModified();
                  }
                  const terminated = this.messageHandler.sendWithPromise("Terminate", null);
                  waitOn.push(terminated);
                  Promise.all(waitOn).then(() => {
                    this.commonObjs.clear();
                    this.fontLoader.clear();
                    _classPrivateFieldSet(this, _metadataPromise, null);
                    this._getFieldObjectsPromise = null;
                    this._hasJSActionsPromise = null;
                    if (this._networkStream) {
                      this._networkStream.cancelAllRequests(new _util.AbortException("Worker was terminated."));
                    }
                    if (this.messageHandler) {
                      this.messageHandler.destroy();
                      this.messageHandler = null;
                    }
                    this.destroyCapability.resolve();
                  }, this.destroyCapability.reject);
                  return this.destroyCapability.promise;
                }
                setupMessageHandler() {
                  const {
                    messageHandler,
                    loadingTask
                  } = this;
                  messageHandler.on("GetReader", (data, sink) => {
                    (0, _util.assert)(this._networkStream, "GetReader - no `IPDFStream` instance available.");
                    this._fullReader = this._networkStream.getFullReader();
                    this._fullReader.onProgress = (evt) => {
                      this._lastProgress = {
                        loaded: evt.loaded,
                        total: evt.total
                      };
                    };
                    sink.onPull = () => {
                      this._fullReader.read().then(function(_ref8) {
                        let {
                          value,
                          done
                        } = _ref8;
                        if (done) {
                          sink.close();
                          return;
                        }
                        (0, _util.assert)((0, _util.isArrayBuffer)(value), "GetReader - expected an ArrayBuffer.");
                        sink.enqueue(new Uint8Array(value), 1, [value]);
                      }).catch((reason) => {
                        sink.error(reason);
                      });
                    };
                    sink.onCancel = (reason) => {
                      this._fullReader.cancel(reason);
                      sink.ready.catch((readyReason) => {
                        if (this.destroyed) {
                          return;
                        }
                        throw readyReason;
                      });
                    };
                  });
                  messageHandler.on("ReaderHeadersReady", (data) => {
                    const headersCapability = (0, _util.createPromiseCapability)();
                    const fullReader = this._fullReader;
                    fullReader.headersReady.then(() => {
                      if (!fullReader.isStreamingSupported || !fullReader.isRangeSupported) {
                        if (this._lastProgress) {
                          var _loadingTask$onProgre;
                          (_loadingTask$onProgre = loadingTask.onProgress) === null || _loadingTask$onProgre === void 0 ? void 0 : _loadingTask$onProgre.call(loadingTask, this._lastProgress);
                        }
                        fullReader.onProgress = (evt) => {
                          var _loadingTask$onProgre2;
                          (_loadingTask$onProgre2 = loadingTask.onProgress) === null || _loadingTask$onProgre2 === void 0 ? void 0 : _loadingTask$onProgre2.call(loadingTask, {
                            loaded: evt.loaded,
                            total: evt.total
                          });
                        };
                      }
                      headersCapability.resolve({
                        isStreamingSupported: fullReader.isStreamingSupported,
                        isRangeSupported: fullReader.isRangeSupported,
                        contentLength: fullReader.contentLength
                      });
                    }, headersCapability.reject);
                    return headersCapability.promise;
                  });
                  messageHandler.on("GetRangeReader", (data, sink) => {
                    (0, _util.assert)(this._networkStream, "GetRangeReader - no `IPDFStream` instance available.");
                    const rangeReader = this._networkStream.getRangeReader(data.begin, data.end);
                    if (!rangeReader) {
                      sink.close();
                      return;
                    }
                    sink.onPull = () => {
                      rangeReader.read().then(function(_ref9) {
                        let {
                          value,
                          done
                        } = _ref9;
                        if (done) {
                          sink.close();
                          return;
                        }
                        (0, _util.assert)((0, _util.isArrayBuffer)(value), "GetRangeReader - expected an ArrayBuffer.");
                        sink.enqueue(new Uint8Array(value), 1, [value]);
                      }).catch((reason) => {
                        sink.error(reason);
                      });
                    };
                    sink.onCancel = (reason) => {
                      rangeReader.cancel(reason);
                      sink.ready.catch((readyReason) => {
                        if (this.destroyed) {
                          return;
                        }
                        throw readyReason;
                      });
                    };
                  });
                  messageHandler.on("GetDoc", (_ref10) => {
                    let {
                      pdfInfo
                    } = _ref10;
                    this._numPages = pdfInfo.numPages;
                    this._htmlForXfa = pdfInfo.htmlForXfa;
                    delete pdfInfo.htmlForXfa;
                    loadingTask._capability.resolve(new PDFDocumentProxy(pdfInfo, this));
                  });
                  messageHandler.on("DocException", function(ex) {
                    let reason;
                    switch (ex.name) {
                      case "PasswordException":
                        reason = new _util.PasswordException(ex.message, ex.code);
                        break;
                      case "InvalidPDFException":
                        reason = new _util.InvalidPDFException(ex.message);
                        break;
                      case "MissingPDFException":
                        reason = new _util.MissingPDFException(ex.message);
                        break;
                      case "UnexpectedResponseException":
                        reason = new _util.UnexpectedResponseException(ex.message, ex.status);
                        break;
                      case "UnknownErrorException":
                        reason = new _util.UnknownErrorException(ex.message, ex.details);
                        break;
                      default:
                        (0, _util.unreachable)("DocException - expected a valid Error.");
                    }
                    loadingTask._capability.reject(reason);
                  });
                  messageHandler.on("PasswordRequest", (exception) => {
                    this._passwordCapability = (0, _util.createPromiseCapability)();
                    if (loadingTask.onPassword) {
                      const updatePassword = (password) => {
                        if (password instanceof Error) {
                          this._passwordCapability.reject(password);
                        } else {
                          this._passwordCapability.resolve({
                            password
                          });
                        }
                      };
                      try {
                        loadingTask.onPassword(updatePassword, exception.code);
                      } catch (ex) {
                        this._passwordCapability.reject(ex);
                      }
                    } else {
                      this._passwordCapability.reject(new _util.PasswordException(exception.message, exception.code));
                    }
                    return this._passwordCapability.promise;
                  });
                  messageHandler.on("DataLoaded", (data) => {
                    var _loadingTask$onProgre3;
                    (_loadingTask$onProgre3 = loadingTask.onProgress) === null || _loadingTask$onProgre3 === void 0 ? void 0 : _loadingTask$onProgre3.call(loadingTask, {
                      loaded: data.length,
                      total: data.length
                    });
                    this.downloadInfoCapability.resolve(data);
                  });
                  messageHandler.on("StartRenderPage", (data) => {
                    if (this.destroyed) {
                      return;
                    }
                    const page = _classPrivateFieldGet(this, _pageCache).get(data.pageIndex);
                    page._startRenderPage(data.transparency, data.cacheKey);
                  });
                  messageHandler.on("commonobj", (_ref11) => {
                    var _globalThis$FontInspe;
                    let [id, type, exportedData] = _ref11;
                    if (this.destroyed) {
                      return;
                    }
                    if (this.commonObjs.has(id)) {
                      return;
                    }
                    switch (type) {
                      case "Font":
                        const params = this._params;
                        if ("error" in exportedData) {
                          const exportedError = exportedData.error;
                          (0, _util.warn)(`Error during font loading: ${exportedError}`);
                          this.commonObjs.resolve(id, exportedError);
                          break;
                        }
                        let fontRegistry = null;
                        if (params.pdfBug && (_globalThis$FontInspe = globalThis.FontInspector) !== null && _globalThis$FontInspe !== void 0 && _globalThis$FontInspe.enabled) {
                          fontRegistry = {
                            registerFont(font2, url) {
                              globalThis.FontInspector.fontAdded(font2, url);
                            }
                          };
                        }
                        const font = new _font_loader.FontFaceObject(exportedData, {
                          isEvalSupported: params.isEvalSupported,
                          disableFontFace: params.disableFontFace,
                          ignoreErrors: params.ignoreErrors,
                          onUnsupportedFeature: this._onUnsupportedFeature.bind(this),
                          fontRegistry
                        });
                        this.fontLoader.bind(font).catch((reason) => {
                          return messageHandler.sendWithPromise("FontFallback", {
                            id
                          });
                        }).finally(() => {
                          if (!params.fontExtraProperties && font.data) {
                            font.data = null;
                          }
                          this.commonObjs.resolve(id, font);
                        });
                        break;
                      case "FontPath":
                      case "Image":
                        this.commonObjs.resolve(id, exportedData);
                        break;
                      default:
                        throw new Error(`Got unknown common object type ${type}`);
                    }
                  });
                  messageHandler.on("obj", (_ref12) => {
                    let [id, pageIndex, type, imageData] = _ref12;
                    if (this.destroyed) {
                      return;
                    }
                    const pageProxy = _classPrivateFieldGet(this, _pageCache).get(pageIndex);
                    if (pageProxy.objs.has(id)) {
                      return;
                    }
                    switch (type) {
                      case "Image":
                        pageProxy.objs.resolve(id, imageData);
                        const MAX_IMAGE_SIZE_TO_STORE = 8e6;
                        if (imageData) {
                          let length;
                          if (imageData.bitmap) {
                            const {
                              bitmap,
                              width,
                              height
                            } = imageData;
                            length = width * height * 4;
                            pageProxy._bitmaps.add(bitmap);
                          } else {
                            var _imageData$data;
                            length = ((_imageData$data = imageData.data) === null || _imageData$data === void 0 ? void 0 : _imageData$data.length) || 0;
                          }
                          if (length > MAX_IMAGE_SIZE_TO_STORE) {
                            pageProxy.cleanupAfterRender = true;
                          }
                        }
                        break;
                      case "Pattern":
                        pageProxy.objs.resolve(id, imageData);
                        break;
                      default:
                        throw new Error(`Got unknown object type ${type}`);
                    }
                  });
                  messageHandler.on("DocProgress", (data) => {
                    var _loadingTask$onProgre4;
                    if (this.destroyed) {
                      return;
                    }
                    (_loadingTask$onProgre4 = loadingTask.onProgress) === null || _loadingTask$onProgre4 === void 0 ? void 0 : _loadingTask$onProgre4.call(loadingTask, {
                      loaded: data.loaded,
                      total: data.total
                    });
                  });
                  messageHandler.on("DocStats", (data) => {
                    if (this.destroyed) {
                      return;
                    }
                    _classPrivateFieldSet(this, _docStats, Object.freeze({
                      streamTypes: Object.freeze(data.streamTypes),
                      fontTypes: Object.freeze(data.fontTypes)
                    }));
                  });
                  messageHandler.on("UnsupportedFeature", this._onUnsupportedFeature.bind(this));
                  messageHandler.on("FetchBuiltInCMap", (data) => {
                    if (this.destroyed) {
                      return Promise.reject(new Error("Worker was destroyed."));
                    }
                    if (!this.CMapReaderFactory) {
                      return Promise.reject(new Error("CMapReaderFactory not initialized, see the `useWorkerFetch` parameter."));
                    }
                    return this.CMapReaderFactory.fetch(data);
                  });
                  messageHandler.on("FetchStandardFontData", (data) => {
                    if (this.destroyed) {
                      return Promise.reject(new Error("Worker was destroyed."));
                    }
                    if (!this.StandardFontDataFactory) {
                      return Promise.reject(new Error("StandardFontDataFactory not initialized, see the `useWorkerFetch` parameter."));
                    }
                    return this.StandardFontDataFactory.fetch(data);
                  });
                }
                _onUnsupportedFeature(_ref13) {
                  var _this$loadingTask$onU, _this$loadingTask;
                  let {
                    featureId
                  } = _ref13;
                  if (this.destroyed) {
                    return;
                  }
                  (_this$loadingTask$onU = (_this$loadingTask = this.loadingTask).onUnsupportedFeature) === null || _this$loadingTask$onU === void 0 ? void 0 : _this$loadingTask$onU.call(_this$loadingTask, featureId);
                }
                getData() {
                  return this.messageHandler.sendWithPromise("GetData", null);
                }
                getPage(pageNumber) {
                  if (!Number.isInteger(pageNumber) || pageNumber <= 0 || pageNumber > this._numPages) {
                    return Promise.reject(new Error("Invalid page request."));
                  }
                  const pageIndex = pageNumber - 1, cachedPromise = _classPrivateFieldGet(this, _pagePromises).get(pageIndex);
                  if (cachedPromise) {
                    return cachedPromise;
                  }
                  const promise = this.messageHandler.sendWithPromise("GetPage", {
                    pageIndex
                  }).then((pageInfo) => {
                    if (this.destroyed) {
                      throw new Error("Transport destroyed");
                    }
                    const page = new PDFPageProxy(pageIndex, pageInfo, this, this._params.ownerDocument, this._params.pdfBug);
                    _classPrivateFieldGet(this, _pageCache).set(pageIndex, page);
                    return page;
                  });
                  _classPrivateFieldGet(this, _pagePromises).set(pageIndex, promise);
                  return promise;
                }
                getPageIndex(ref) {
                  if (typeof ref !== "object" || ref === null || !Number.isInteger(ref.num) || ref.num < 0 || !Number.isInteger(ref.gen) || ref.gen < 0) {
                    return Promise.reject(new Error("Invalid pageIndex request."));
                  }
                  return this.messageHandler.sendWithPromise("GetPageIndex", {
                    num: ref.num,
                    gen: ref.gen
                  });
                }
                getAnnotations(pageIndex, intent) {
                  return this.messageHandler.sendWithPromise("GetAnnotations", {
                    pageIndex,
                    intent
                  });
                }
                saveDocument() {
                  var _this$_fullReader$fil, _this$_fullReader;
                  return this.messageHandler.sendWithPromise("SaveDocument", {
                    isPureXfa: !!this._htmlForXfa,
                    numPages: this._numPages,
                    annotationStorage: this.annotationStorage.serializable,
                    filename: (_this$_fullReader$fil = (_this$_fullReader = this._fullReader) === null || _this$_fullReader === void 0 ? void 0 : _this$_fullReader.filename) !== null && _this$_fullReader$fil !== void 0 ? _this$_fullReader$fil : null
                  }).finally(() => {
                    this.annotationStorage.resetModified();
                  });
                }
                getFieldObjects() {
                  return this._getFieldObjectsPromise || (this._getFieldObjectsPromise = this.messageHandler.sendWithPromise("GetFieldObjects", null));
                }
                hasJSActions() {
                  return this._hasJSActionsPromise || (this._hasJSActionsPromise = this.messageHandler.sendWithPromise("HasJSActions", null));
                }
                getCalculationOrderIds() {
                  return this.messageHandler.sendWithPromise("GetCalculationOrderIds", null);
                }
                getDestinations() {
                  return this.messageHandler.sendWithPromise("GetDestinations", null);
                }
                getDestination(id) {
                  if (typeof id !== "string") {
                    return Promise.reject(new Error("Invalid destination request."));
                  }
                  return this.messageHandler.sendWithPromise("GetDestination", {
                    id
                  });
                }
                getPageLabels() {
                  return this.messageHandler.sendWithPromise("GetPageLabels", null);
                }
                getPageLayout() {
                  return this.messageHandler.sendWithPromise("GetPageLayout", null);
                }
                getPageMode() {
                  return this.messageHandler.sendWithPromise("GetPageMode", null);
                }
                getViewerPreferences() {
                  return this.messageHandler.sendWithPromise("GetViewerPreferences", null);
                }
                getOpenAction() {
                  return this.messageHandler.sendWithPromise("GetOpenAction", null);
                }
                getAttachments() {
                  return this.messageHandler.sendWithPromise("GetAttachments", null);
                }
                getJavaScript() {
                  return this.messageHandler.sendWithPromise("GetJavaScript", null);
                }
                getDocJSActions() {
                  return this.messageHandler.sendWithPromise("GetDocJSActions", null);
                }
                getPageJSActions(pageIndex) {
                  return this.messageHandler.sendWithPromise("GetPageJSActions", {
                    pageIndex
                  });
                }
                getStructTree(pageIndex) {
                  return this.messageHandler.sendWithPromise("GetStructTree", {
                    pageIndex
                  });
                }
                getOutline() {
                  return this.messageHandler.sendWithPromise("GetOutline", null);
                }
                getOptionalContentConfig() {
                  return this.messageHandler.sendWithPromise("GetOptionalContentConfig", null).then((results) => {
                    return new _optional_content_config.OptionalContentConfig(results);
                  });
                }
                getPermissions() {
                  return this.messageHandler.sendWithPromise("GetPermissions", null);
                }
                getMetadata() {
                  return _classPrivateFieldGet(this, _metadataPromise) || _classPrivateFieldSet(this, _metadataPromise, this.messageHandler.sendWithPromise("GetMetadata", null).then((results) => {
                    var _this$_fullReader$fil2, _this$_fullReader2, _this$_fullReader$con, _this$_fullReader3;
                    return {
                      info: results[0],
                      metadata: results[1] ? new _metadata.Metadata(results[1]) : null,
                      contentDispositionFilename: (_this$_fullReader$fil2 = (_this$_fullReader2 = this._fullReader) === null || _this$_fullReader2 === void 0 ? void 0 : _this$_fullReader2.filename) !== null && _this$_fullReader$fil2 !== void 0 ? _this$_fullReader$fil2 : null,
                      contentLength: (_this$_fullReader$con = (_this$_fullReader3 = this._fullReader) === null || _this$_fullReader3 === void 0 ? void 0 : _this$_fullReader3.contentLength) !== null && _this$_fullReader$con !== void 0 ? _this$_fullReader$con : null
                    };
                  }));
                }
                getMarkInfo() {
                  return this.messageHandler.sendWithPromise("GetMarkInfo", null);
                }
                async startCleanup() {
                  let keepLoadedFonts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
                  await this.messageHandler.sendWithPromise("Cleanup", null);
                  if (this.destroyed) {
                    return;
                  }
                  for (const page of _classPrivateFieldGet(this, _pageCache).values()) {
                    const cleanupSuccessful = page.cleanup();
                    if (!cleanupSuccessful) {
                      throw new Error(`startCleanup: Page ${page.pageNumber} is currently rendering.`);
                    }
                  }
                  this.commonObjs.clear();
                  if (!keepLoadedFonts) {
                    this.fontLoader.clear();
                  }
                  _classPrivateFieldSet(this, _metadataPromise, null);
                  this._getFieldObjectsPromise = null;
                  this._hasJSActionsPromise = null;
                }
                get loadingParams() {
                  const params = this._params;
                  return (0, _util.shadow)(this, "loadingParams", {
                    disableAutoFetch: params.disableAutoFetch,
                    enableXfa: params.enableXfa
                  });
                }
              }
              var _objs = /* @__PURE__ */ new WeakMap();
              var _ensureObj = /* @__PURE__ */ new WeakSet();
              class PDFObjects {
                constructor() {
                  _classPrivateMethodInitSpec(this, _ensureObj);
                  _classPrivateFieldInitSpec(this, _objs, {
                    writable: true,
                    value: /* @__PURE__ */ Object.create(null)
                  });
                }
                get(objId) {
                  let callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
                  if (callback) {
                    const obj2 = _classPrivateMethodGet(this, _ensureObj, _ensureObj2).call(this, objId);
                    obj2.capability.promise.then(() => callback(obj2.data));
                    return null;
                  }
                  const obj = _classPrivateFieldGet(this, _objs)[objId];
                  if (!(obj !== null && obj !== void 0 && obj.capability.settled)) {
                    throw new Error(`Requesting object that isn't resolved yet ${objId}.`);
                  }
                  return obj.data;
                }
                has(objId) {
                  const obj = _classPrivateFieldGet(this, _objs)[objId];
                  return (obj === null || obj === void 0 ? void 0 : obj.capability.settled) || false;
                }
                resolve(objId) {
                  let data = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
                  const obj = _classPrivateMethodGet(this, _ensureObj, _ensureObj2).call(this, objId);
                  obj.data = data;
                  obj.capability.resolve();
                }
                clear() {
                  _classPrivateFieldSet(this, _objs, /* @__PURE__ */ Object.create(null));
                }
              }
              function _ensureObj2(objId) {
                const obj = _classPrivateFieldGet(this, _objs)[objId];
                if (obj) {
                  return obj;
                }
                return _classPrivateFieldGet(this, _objs)[objId] = {
                  capability: (0, _util.createPromiseCapability)(),
                  data: null
                };
              }
              var _internalRenderTask = /* @__PURE__ */ new WeakMap();
              class RenderTask {
                constructor(internalRenderTask) {
                  _classPrivateFieldInitSpec(this, _internalRenderTask, {
                    writable: true,
                    value: null
                  });
                  _classPrivateFieldSet(this, _internalRenderTask, internalRenderTask);
                  this.onContinue = null;
                }
                get promise() {
                  return _classPrivateFieldGet(this, _internalRenderTask).capability.promise;
                }
                cancel() {
                  _classPrivateFieldGet(this, _internalRenderTask).cancel();
                }
                get separateAnnots() {
                  const {
                    separateAnnots
                  } = _classPrivateFieldGet(this, _internalRenderTask).operatorList;
                  if (!separateAnnots) {
                    return false;
                  }
                  const {
                    annotationCanvasMap
                  } = _classPrivateFieldGet(this, _internalRenderTask);
                  return separateAnnots.form || separateAnnots.canvas && (annotationCanvasMap === null || annotationCanvasMap === void 0 ? void 0 : annotationCanvasMap.size) > 0;
                }
              }
              exports.RenderTask = RenderTask;
              class InternalRenderTask {
                constructor(_ref14) {
                  let {
                    callback,
                    params,
                    objs,
                    commonObjs,
                    annotationCanvasMap,
                    operatorList,
                    pageIndex,
                    canvasFactory,
                    useRequestAnimationFrame = false,
                    pdfBug = false,
                    pageColors = null
                  } = _ref14;
                  this.callback = callback;
                  this.params = params;
                  this.objs = objs;
                  this.commonObjs = commonObjs;
                  this.annotationCanvasMap = annotationCanvasMap;
                  this.operatorListIdx = null;
                  this.operatorList = operatorList;
                  this._pageIndex = pageIndex;
                  this.canvasFactory = canvasFactory;
                  this._pdfBug = pdfBug;
                  this.pageColors = pageColors;
                  this.running = false;
                  this.graphicsReadyCallback = null;
                  this.graphicsReady = false;
                  this._useRequestAnimationFrame = useRequestAnimationFrame === true && typeof window !== "undefined";
                  this.cancelled = false;
                  this.capability = (0, _util.createPromiseCapability)();
                  this.task = new RenderTask(this);
                  this._cancelBound = this.cancel.bind(this);
                  this._continueBound = this._continue.bind(this);
                  this._scheduleNextBound = this._scheduleNext.bind(this);
                  this._nextBound = this._next.bind(this);
                  this._canvas = params.canvasContext.canvas;
                }
                get completed() {
                  return this.capability.promise.catch(function() {
                  });
                }
                initializeGraphics(_ref15) {
                  var _globalThis$StepperMa;
                  let {
                    transparency = false,
                    optionalContentConfig
                  } = _ref15;
                  if (this.cancelled) {
                    return;
                  }
                  if (this._canvas) {
                    if (_classStaticPrivateFieldSpecGet(InternalRenderTask, InternalRenderTask, _canvasInUse).has(this._canvas)) {
                      throw new Error("Cannot use the same canvas during multiple render() operations. Use different canvas or ensure previous operations were cancelled or completed.");
                    }
                    _classStaticPrivateFieldSpecGet(InternalRenderTask, InternalRenderTask, _canvasInUse).add(this._canvas);
                  }
                  if (this._pdfBug && (_globalThis$StepperMa = globalThis.StepperManager) !== null && _globalThis$StepperMa !== void 0 && _globalThis$StepperMa.enabled) {
                    this.stepper = globalThis.StepperManager.create(this._pageIndex);
                    this.stepper.init(this.operatorList);
                    this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint();
                  }
                  const {
                    canvasContext,
                    viewport,
                    transform,
                    imageLayer,
                    background
                  } = this.params;
                  this.gfx = new _canvas.CanvasGraphics(canvasContext, this.commonObjs, this.objs, this.canvasFactory, imageLayer, optionalContentConfig, this.annotationCanvasMap, this.pageColors);
                  this.gfx.beginDrawing({
                    transform,
                    viewport,
                    transparency,
                    background
                  });
                  this.operatorListIdx = 0;
                  this.graphicsReady = true;
                  if (this.graphicsReadyCallback) {
                    this.graphicsReadyCallback();
                  }
                }
                cancel() {
                  let error = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
                  this.running = false;
                  this.cancelled = true;
                  if (this.gfx) {
                    this.gfx.endDrawing();
                  }
                  if (this._canvas) {
                    _classStaticPrivateFieldSpecGet(InternalRenderTask, InternalRenderTask, _canvasInUse).delete(this._canvas);
                  }
                  this.callback(error || new _display_utils.RenderingCancelledException(`Rendering cancelled, page ${this._pageIndex + 1}`, "canvas"));
                }
                operatorListChanged() {
                  if (!this.graphicsReady) {
                    if (!this.graphicsReadyCallback) {
                      this.graphicsReadyCallback = this._continueBound;
                    }
                    return;
                  }
                  if (this.stepper) {
                    this.stepper.updateOperatorList(this.operatorList);
                  }
                  if (this.running) {
                    return;
                  }
                  this._continue();
                }
                _continue() {
                  this.running = true;
                  if (this.cancelled) {
                    return;
                  }
                  if (this.task.onContinue) {
                    this.task.onContinue(this._scheduleNextBound);
                  } else {
                    this._scheduleNext();
                  }
                }
                _scheduleNext() {
                  if (this._useRequestAnimationFrame) {
                    window.requestAnimationFrame(() => {
                      this._nextBound().catch(this._cancelBound);
                    });
                  } else {
                    Promise.resolve().then(this._nextBound).catch(this._cancelBound);
                  }
                }
                async _next() {
                  if (this.cancelled) {
                    return;
                  }
                  this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper);
                  if (this.operatorListIdx === this.operatorList.argsArray.length) {
                    this.running = false;
                    if (this.operatorList.lastChunk) {
                      this.gfx.endDrawing();
                      if (this._canvas) {
                        _classStaticPrivateFieldSpecGet(InternalRenderTask, InternalRenderTask, _canvasInUse).delete(this._canvas);
                      }
                      this.callback();
                    }
                  }
                }
              }
              var _canvasInUse = {
                writable: true,
                value: /* @__PURE__ */ new WeakSet()
              };
              const version = "2.16.105";
              exports.version = version;
              const build = "172ccdbe5";
              exports.build = build;
            },
            /* 130 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.PrintAnnotationStorage = exports2.AnnotationStorage = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              var _editor = __w_pdfjs_require__2(131);
              var _murmurhash = __w_pdfjs_require__2(135);
              function _classPrivateFieldInitSpec2(obj, privateMap, value) {
                _checkPrivateRedeclaration2(obj, privateMap);
                privateMap.set(obj, value);
              }
              function _classPrivateFieldGet2(receiver, privateMap) {
                var descriptor = _classExtractFieldDescriptor2(receiver, privateMap, "get");
                return _classApplyDescriptorGet2(receiver, descriptor);
              }
              function _classApplyDescriptorGet2(receiver, descriptor) {
                if (descriptor.get) {
                  return descriptor.get.call(receiver);
                }
                return descriptor.value;
              }
              function _classPrivateFieldSet2(receiver, privateMap, value) {
                var descriptor = _classExtractFieldDescriptor2(receiver, privateMap, "set");
                _classApplyDescriptorSet2(receiver, descriptor, value);
                return value;
              }
              function _classExtractFieldDescriptor2(receiver, privateMap, action) {
                if (!privateMap.has(receiver)) {
                  throw new TypeError("attempted to " + action + " private field on non-instance");
                }
                return privateMap.get(receiver);
              }
              function _classApplyDescriptorSet2(receiver, descriptor, value) {
                if (descriptor.set) {
                  descriptor.set.call(receiver, value);
                } else {
                  if (!descriptor.writable) {
                    throw new TypeError("attempted to set read only private field");
                  }
                  descriptor.value = value;
                }
              }
              function _classPrivateMethodInitSpec2(obj, privateSet) {
                _checkPrivateRedeclaration2(obj, privateSet);
                privateSet.add(obj);
              }
              function _checkPrivateRedeclaration2(obj, privateCollection) {
                if (privateCollection.has(obj)) {
                  throw new TypeError("Cannot initialize the same private elements twice on an object");
                }
              }
              function _classPrivateMethodGet2(receiver, privateSet, fn) {
                if (!privateSet.has(receiver)) {
                  throw new TypeError("attempted to get private field on non-instance");
                }
                return fn;
              }
              var _setModified = /* @__PURE__ */ new WeakSet();
              class AnnotationStorage {
                constructor() {
                  _classPrivateMethodInitSpec2(this, _setModified);
                  this._storage = /* @__PURE__ */ new Map();
                  this._modified = false;
                  this.onSetModified = null;
                  this.onResetModified = null;
                  this.onAnnotationEditor = null;
                }
                getValue(key, defaultValue) {
                  const value = this._storage.get(key);
                  if (value === void 0) {
                    return defaultValue;
                  }
                  return Object.assign(defaultValue, value);
                }
                getRawValue(key) {
                  return this._storage.get(key);
                }
                remove(key) {
                  this._storage.delete(key);
                  if (this._storage.size === 0) {
                    this.resetModified();
                  }
                  if (typeof this.onAnnotationEditor === "function") {
                    for (const value of this._storage.values()) {
                      if (value instanceof _editor.AnnotationEditor) {
                        return;
                      }
                    }
                    this.onAnnotationEditor(null);
                  }
                }
                setValue(key, value) {
                  const obj = this._storage.get(key);
                  let modified = false;
                  if (obj !== void 0) {
                    for (const [entry, val] of Object.entries(value)) {
                      if (obj[entry] !== val) {
                        modified = true;
                        obj[entry] = val;
                      }
                    }
                  } else {
                    modified = true;
                    this._storage.set(key, value);
                  }
                  if (modified) {
                    _classPrivateMethodGet2(this, _setModified, _setModified2).call(this);
                  }
                  if (value instanceof _editor.AnnotationEditor && typeof this.onAnnotationEditor === "function") {
                    this.onAnnotationEditor(value.constructor._type);
                  }
                }
                has(key) {
                  return this._storage.has(key);
                }
                getAll() {
                  return this._storage.size > 0 ? (0, _util2.objectFromMap)(this._storage) : null;
                }
                get size() {
                  return this._storage.size;
                }
                resetModified() {
                  if (this._modified) {
                    this._modified = false;
                    if (typeof this.onResetModified === "function") {
                      this.onResetModified();
                    }
                  }
                }
                get print() {
                  return new PrintAnnotationStorage(this);
                }
                get serializable() {
                  if (this._storage.size === 0) {
                    return null;
                  }
                  const clone = /* @__PURE__ */ new Map();
                  for (const [key, val] of this._storage) {
                    const serialized = val instanceof _editor.AnnotationEditor ? val.serialize() : val;
                    if (serialized) {
                      clone.set(key, serialized);
                    }
                  }
                  return clone;
                }
                static getHash(map) {
                  if (!map) {
                    return "";
                  }
                  const hash = new _murmurhash.MurmurHash3_64();
                  for (const [key, val] of map) {
                    hash.update(`${key}:${JSON.stringify(val)}`);
                  }
                  return hash.hexdigest();
                }
              }
              exports2.AnnotationStorage = AnnotationStorage;
              function _setModified2() {
                if (!this._modified) {
                  this._modified = true;
                  if (typeof this.onSetModified === "function") {
                    this.onSetModified();
                  }
                }
              }
              var _serializable = /* @__PURE__ */ new WeakMap();
              class PrintAnnotationStorage extends AnnotationStorage {
                constructor(parent) {
                  super();
                  _classPrivateFieldInitSpec2(this, _serializable, {
                    writable: true,
                    value: null
                  });
                  _classPrivateFieldSet2(this, _serializable, structuredClone(parent.serializable));
                }
                get print() {
                  (0, _util2.unreachable)("Should not call PrintAnnotationStorage.print");
                }
                get serializable() {
                  return _classPrivateFieldGet2(this, _serializable);
                }
              }
              exports2.PrintAnnotationStorage = PrintAnnotationStorage;
            },
            /* 131 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.AnnotationEditor = void 0;
              var _tools = __w_pdfjs_require__2(132);
              var _util2 = __w_pdfjs_require__2(1);
              function _defineProperty(obj, key, value) {
                if (key in obj) {
                  Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
                } else {
                  obj[key] = value;
                }
                return obj;
              }
              function _classPrivateFieldInitSpec2(obj, privateMap, value) {
                _checkPrivateRedeclaration2(obj, privateMap);
                privateMap.set(obj, value);
              }
              function _checkPrivateRedeclaration2(obj, privateCollection) {
                if (privateCollection.has(obj)) {
                  throw new TypeError("Cannot initialize the same private elements twice on an object");
                }
              }
              function _classPrivateFieldSet2(receiver, privateMap, value) {
                var descriptor = _classExtractFieldDescriptor2(receiver, privateMap, "set");
                _classApplyDescriptorSet2(receiver, descriptor, value);
                return value;
              }
              function _classApplyDescriptorSet2(receiver, descriptor, value) {
                if (descriptor.set) {
                  descriptor.set.call(receiver, value);
                } else {
                  if (!descriptor.writable) {
                    throw new TypeError("attempted to set read only private field");
                  }
                  descriptor.value = value;
                }
              }
              function _classPrivateFieldGet2(receiver, privateMap) {
                var descriptor = _classExtractFieldDescriptor2(receiver, privateMap, "get");
                return _classApplyDescriptorGet2(receiver, descriptor);
              }
              function _classExtractFieldDescriptor2(receiver, privateMap, action) {
                if (!privateMap.has(receiver)) {
                  throw new TypeError("attempted to " + action + " private field on non-instance");
                }
                return privateMap.get(receiver);
              }
              function _classApplyDescriptorGet2(receiver, descriptor) {
                if (descriptor.get) {
                  return descriptor.get.call(receiver);
                }
                return descriptor.value;
              }
              var _boundFocusin = /* @__PURE__ */ new WeakMap();
              var _boundFocusout = /* @__PURE__ */ new WeakMap();
              var _hasBeenSelected = /* @__PURE__ */ new WeakMap();
              var _isEditing = /* @__PURE__ */ new WeakMap();
              var _isInEditMode = /* @__PURE__ */ new WeakMap();
              var _zIndex = /* @__PURE__ */ new WeakMap();
              class AnnotationEditor {
                constructor(parameters) {
                  _classPrivateFieldInitSpec2(this, _boundFocusin, {
                    writable: true,
                    value: this.focusin.bind(this)
                  });
                  _classPrivateFieldInitSpec2(this, _boundFocusout, {
                    writable: true,
                    value: this.focusout.bind(this)
                  });
                  _classPrivateFieldInitSpec2(this, _hasBeenSelected, {
                    writable: true,
                    value: false
                  });
                  _classPrivateFieldInitSpec2(this, _isEditing, {
                    writable: true,
                    value: false
                  });
                  _classPrivateFieldInitSpec2(this, _isInEditMode, {
                    writable: true,
                    value: false
                  });
                  _classPrivateFieldInitSpec2(this, _zIndex, {
                    writable: true,
                    value: AnnotationEditor._zIndex++
                  });
                  if (this.constructor === AnnotationEditor) {
                    (0, _util2.unreachable)("Cannot initialize AnnotationEditor.");
                  }
                  this.parent = parameters.parent;
                  this.id = parameters.id;
                  this.width = this.height = null;
                  this.pageIndex = parameters.parent.pageIndex;
                  this.name = parameters.name;
                  this.div = null;
                  const [width, height] = this.parent.viewportBaseDimensions;
                  this.x = parameters.x / width;
                  this.y = parameters.y / height;
                  this.rotation = this.parent.viewport.rotation;
                  this.isAttachedToDOM = false;
                }
                static get _defaultLineColor() {
                  return (0, _util2.shadow)(this, "_defaultLineColor", this._colorManager.getHexCode("CanvasText"));
                }
                setInBackground() {
                  this.div.style.zIndex = 0;
                }
                setInForeground() {
                  this.div.style.zIndex = _classPrivateFieldGet2(this, _zIndex);
                }
                focusin(event) {
                  if (!_classPrivateFieldGet2(this, _hasBeenSelected)) {
                    this.parent.setSelected(this);
                  } else {
                    _classPrivateFieldSet2(this, _hasBeenSelected, false);
                  }
                }
                focusout(event) {
                  if (!this.isAttachedToDOM) {
                    return;
                  }
                  const target = event.relatedTarget;
                  if (target !== null && target !== void 0 && target.closest(`#${this.id}`)) {
                    return;
                  }
                  event.preventDefault();
                  if (!this.parent.isMultipleSelection) {
                    this.commitOrRemove();
                  }
                }
                commitOrRemove() {
                  if (this.isEmpty()) {
                    this.remove();
                  } else {
                    this.commit();
                  }
                }
                commit() {
                  this.parent.addToAnnotationStorage(this);
                }
                dragstart(event) {
                  const rect = this.parent.div.getBoundingClientRect();
                  this.startX = event.clientX - rect.x;
                  this.startY = event.clientY - rect.y;
                  event.dataTransfer.setData("text/plain", this.id);
                  event.dataTransfer.effectAllowed = "move";
                }
                setAt(x, y, tx, ty) {
                  const [width, height] = this.parent.viewportBaseDimensions;
                  [tx, ty] = this.screenToPageTranslation(tx, ty);
                  this.x = (x + tx) / width;
                  this.y = (y + ty) / height;
                  this.div.style.left = `${100 * this.x}%`;
                  this.div.style.top = `${100 * this.y}%`;
                }
                translate(x, y) {
                  const [width, height] = this.parent.viewportBaseDimensions;
                  [x, y] = this.screenToPageTranslation(x, y);
                  this.x += x / width;
                  this.y += y / height;
                  this.div.style.left = `${100 * this.x}%`;
                  this.div.style.top = `${100 * this.y}%`;
                }
                screenToPageTranslation(x, y) {
                  const {
                    rotation
                  } = this.parent.viewport;
                  switch (rotation) {
                    case 90:
                      return [y, -x];
                    case 180:
                      return [-x, -y];
                    case 270:
                      return [-y, x];
                    default:
                      return [x, y];
                  }
                }
                setDims(width, height) {
                  const [parentWidth, parentHeight] = this.parent.viewportBaseDimensions;
                  this.div.style.width = `${100 * width / parentWidth}%`;
                  this.div.style.height = `${100 * height / parentHeight}%`;
                }
                getInitialTranslation() {
                  return [0, 0];
                }
                render() {
                  this.div = document.createElement("div");
                  this.div.setAttribute("data-editor-rotation", (360 - this.rotation) % 360);
                  this.div.className = this.name;
                  this.div.setAttribute("id", this.id);
                  this.div.setAttribute("tabIndex", 0);
                  this.setInForeground();
                  this.div.addEventListener("focusin", _classPrivateFieldGet2(this, _boundFocusin));
                  this.div.addEventListener("focusout", _classPrivateFieldGet2(this, _boundFocusout));
                  const [tx, ty] = this.getInitialTranslation();
                  this.translate(tx, ty);
                  (0, _tools.bindEvents)(this, this.div, ["dragstart", "pointerdown"]);
                  return this.div;
                }
                pointerdown(event) {
                  const isMac = _tools.KeyboardManager.platform.isMac;
                  if (event.button !== 0 || event.ctrlKey && isMac) {
                    event.preventDefault();
                    return;
                  }
                  if (event.ctrlKey && !isMac || event.shiftKey || event.metaKey && isMac) {
                    this.parent.toggleSelected(this);
                  } else {
                    this.parent.setSelected(this);
                  }
                  _classPrivateFieldSet2(this, _hasBeenSelected, true);
                }
                getRect(tx, ty) {
                  const [parentWidth, parentHeight] = this.parent.viewportBaseDimensions;
                  const [pageWidth, pageHeight] = this.parent.pageDimensions;
                  const shiftX = pageWidth * tx / parentWidth;
                  const shiftY = pageHeight * ty / parentHeight;
                  const x = this.x * pageWidth;
                  const y = this.y * pageHeight;
                  const width = this.width * pageWidth;
                  const height = this.height * pageHeight;
                  switch (this.rotation) {
                    case 0:
                      return [x + shiftX, pageHeight - y - shiftY - height, x + shiftX + width, pageHeight - y - shiftY];
                    case 90:
                      return [x + shiftY, pageHeight - y + shiftX, x + shiftY + height, pageHeight - y + shiftX + width];
                    case 180:
                      return [x - shiftX - width, pageHeight - y + shiftY, x - shiftX, pageHeight - y + shiftY + height];
                    case 270:
                      return [x - shiftY - height, pageHeight - y - shiftX - width, x - shiftY, pageHeight - y - shiftX];
                    default:
                      throw new Error("Invalid rotation");
                  }
                }
                getRectInCurrentCoords(rect, pageHeight) {
                  const [x1, y1, x2, y2] = rect;
                  const width = x2 - x1;
                  const height = y2 - y1;
                  switch (this.rotation) {
                    case 0:
                      return [x1, pageHeight - y2, width, height];
                    case 90:
                      return [x1, pageHeight - y1, height, width];
                    case 180:
                      return [x2, pageHeight - y1, width, height];
                    case 270:
                      return [x2, pageHeight - y2, height, width];
                    default:
                      throw new Error("Invalid rotation");
                  }
                }
                onceAdded() {
                }
                isEmpty() {
                  return false;
                }
                enableEditMode() {
                  _classPrivateFieldSet2(this, _isInEditMode, true);
                }
                disableEditMode() {
                  _classPrivateFieldSet2(this, _isInEditMode, false);
                }
                isInEditMode() {
                  return _classPrivateFieldGet2(this, _isInEditMode);
                }
                shouldGetKeyboardEvents() {
                  return false;
                }
                needsToBeRebuilt() {
                  return this.div && !this.isAttachedToDOM;
                }
                rebuild() {
                  var _this$div;
                  (_this$div = this.div) === null || _this$div === void 0 ? void 0 : _this$div.addEventListener("focusin", _classPrivateFieldGet2(this, _boundFocusin));
                }
                serialize() {
                  (0, _util2.unreachable)("An editor must be serializable");
                }
                static deserialize(data, parent) {
                  const editor = new this.prototype.constructor({
                    parent,
                    id: parent.getNextId()
                  });
                  editor.rotation = data.rotation;
                  const [pageWidth, pageHeight] = parent.pageDimensions;
                  const [x, y, width, height] = editor.getRectInCurrentCoords(data.rect, pageHeight);
                  editor.x = x / pageWidth;
                  editor.y = y / pageHeight;
                  editor.width = width / pageWidth;
                  editor.height = height / pageHeight;
                  return editor;
                }
                remove() {
                  this.div.removeEventListener("focusin", _classPrivateFieldGet2(this, _boundFocusin));
                  this.div.removeEventListener("focusout", _classPrivateFieldGet2(this, _boundFocusout));
                  if (!this.isEmpty()) {
                    this.commit();
                  }
                  this.parent.remove(this);
                }
                select() {
                  var _this$div2;
                  (_this$div2 = this.div) === null || _this$div2 === void 0 ? void 0 : _this$div2.classList.add("selectedEditor");
                }
                unselect() {
                  var _this$div3;
                  (_this$div3 = this.div) === null || _this$div3 === void 0 ? void 0 : _this$div3.classList.remove("selectedEditor");
                }
                updateParams(type, value) {
                }
                disableEditing() {
                }
                enableEditing() {
                }
                get propertiesToUpdate() {
                  return {};
                }
                get contentDiv() {
                  return this.div;
                }
                get isEditing() {
                  return _classPrivateFieldGet2(this, _isEditing);
                }
                set isEditing(value) {
                  _classPrivateFieldSet2(this, _isEditing, value);
                  if (value) {
                    this.parent.setSelected(this);
                    this.parent.setActiveEditor(this);
                  } else {
                    this.parent.setActiveEditor(null);
                  }
                }
              }
              exports2.AnnotationEditor = AnnotationEditor;
              _defineProperty(AnnotationEditor, "_colorManager", new _tools.ColorManager());
              _defineProperty(AnnotationEditor, "_zIndex", 1);
            },
            /* 132 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.KeyboardManager = exports2.CommandManager = exports2.ColorManager = exports2.AnnotationEditorUIManager = void 0;
              exports2.bindEvents = bindEvents;
              exports2.opacityToHex = opacityToHex;
              var _util2 = __w_pdfjs_require__2(1);
              var _display_utils2 = __w_pdfjs_require__2(133);
              function _defineProperty(obj, key, value) {
                if (key in obj) {
                  Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
                } else {
                  obj[key] = value;
                }
                return obj;
              }
              function _classPrivateMethodInitSpec2(obj, privateSet) {
                _checkPrivateRedeclaration2(obj, privateSet);
                privateSet.add(obj);
              }
              function _classPrivateMethodGet2(receiver, privateSet, fn) {
                if (!privateSet.has(receiver)) {
                  throw new TypeError("attempted to get private field on non-instance");
                }
                return fn;
              }
              function _classPrivateFieldInitSpec2(obj, privateMap, value) {
                _checkPrivateRedeclaration2(obj, privateMap);
                privateMap.set(obj, value);
              }
              function _checkPrivateRedeclaration2(obj, privateCollection) {
                if (privateCollection.has(obj)) {
                  throw new TypeError("Cannot initialize the same private elements twice on an object");
                }
              }
              function _classPrivateFieldSet2(receiver, privateMap, value) {
                var descriptor = _classExtractFieldDescriptor2(receiver, privateMap, "set");
                _classApplyDescriptorSet2(receiver, descriptor, value);
                return value;
              }
              function _classApplyDescriptorSet2(receiver, descriptor, value) {
                if (descriptor.set) {
                  descriptor.set.call(receiver, value);
                } else {
                  if (!descriptor.writable) {
                    throw new TypeError("attempted to set read only private field");
                  }
                  descriptor.value = value;
                }
              }
              function _classPrivateFieldGet2(receiver, privateMap) {
                var descriptor = _classExtractFieldDescriptor2(receiver, privateMap, "get");
                return _classApplyDescriptorGet2(receiver, descriptor);
              }
              function _classExtractFieldDescriptor2(receiver, privateMap, action) {
                if (!privateMap.has(receiver)) {
                  throw new TypeError("attempted to " + action + " private field on non-instance");
                }
                return privateMap.get(receiver);
              }
              function _classApplyDescriptorGet2(receiver, descriptor) {
                if (descriptor.get) {
                  return descriptor.get.call(receiver);
                }
                return descriptor.value;
              }
              function bindEvents(obj, element, names) {
                for (const name of names) {
                  element.addEventListener(name, obj[name].bind(obj));
                }
              }
              function opacityToHex(opacity) {
                return Math.round(Math.min(255, Math.max(1, 255 * opacity))).toString(16).padStart(2, "0");
              }
              var _id = /* @__PURE__ */ new WeakMap();
              class IdManager {
                constructor() {
                  _classPrivateFieldInitSpec2(this, _id, {
                    writable: true,
                    value: 0
                  });
                }
                getId() {
                  var _this$id, _this$id2;
                  return `${_util2.AnnotationEditorPrefix}${_classPrivateFieldSet2(this, _id, (_this$id = _classPrivateFieldGet2(this, _id), _this$id2 = _this$id++, _this$id)), _this$id2}`;
                }
              }
              var _commands = /* @__PURE__ */ new WeakMap();
              var _locked = /* @__PURE__ */ new WeakMap();
              var _maxSize = /* @__PURE__ */ new WeakMap();
              var _position = /* @__PURE__ */ new WeakMap();
              class CommandManager {
                constructor() {
                  let maxSize = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 128;
                  _classPrivateFieldInitSpec2(this, _commands, {
                    writable: true,
                    value: []
                  });
                  _classPrivateFieldInitSpec2(this, _locked, {
                    writable: true,
                    value: false
                  });
                  _classPrivateFieldInitSpec2(this, _maxSize, {
                    writable: true,
                    value: void 0
                  });
                  _classPrivateFieldInitSpec2(this, _position, {
                    writable: true,
                    value: -1
                  });
                  _classPrivateFieldSet2(this, _maxSize, maxSize);
                }
                add(_ref) {
                  let {
                    cmd,
                    undo,
                    mustExec,
                    type = NaN,
                    overwriteIfSameType = false,
                    keepUndo = false
                  } = _ref;
                  if (mustExec) {
                    cmd();
                  }
                  if (_classPrivateFieldGet2(this, _locked)) {
                    return;
                  }
                  const save = {
                    cmd,
                    undo,
                    type
                  };
                  if (_classPrivateFieldGet2(this, _position) === -1) {
                    if (_classPrivateFieldGet2(this, _commands).length > 0) {
                      _classPrivateFieldGet2(this, _commands).length = 0;
                    }
                    _classPrivateFieldSet2(this, _position, 0);
                    _classPrivateFieldGet2(this, _commands).push(save);
                    return;
                  }
                  if (overwriteIfSameType && _classPrivateFieldGet2(this, _commands)[_classPrivateFieldGet2(this, _position)].type === type) {
                    if (keepUndo) {
                      save.undo = _classPrivateFieldGet2(this, _commands)[_classPrivateFieldGet2(this, _position)].undo;
                    }
                    _classPrivateFieldGet2(this, _commands)[_classPrivateFieldGet2(this, _position)] = save;
                    return;
                  }
                  const next = _classPrivateFieldGet2(this, _position) + 1;
                  if (next === _classPrivateFieldGet2(this, _maxSize)) {
                    _classPrivateFieldGet2(this, _commands).splice(0, 1);
                  } else {
                    _classPrivateFieldSet2(this, _position, next);
                    if (next < _classPrivateFieldGet2(this, _commands).length) {
                      _classPrivateFieldGet2(this, _commands).splice(next);
                    }
                  }
                  _classPrivateFieldGet2(this, _commands).push(save);
                }
                undo() {
                  if (_classPrivateFieldGet2(this, _position) === -1) {
                    return;
                  }
                  _classPrivateFieldSet2(this, _locked, true);
                  _classPrivateFieldGet2(this, _commands)[_classPrivateFieldGet2(this, _position)].undo();
                  _classPrivateFieldSet2(this, _locked, false);
                  _classPrivateFieldSet2(this, _position, _classPrivateFieldGet2(this, _position) - 1);
                }
                redo() {
                  if (_classPrivateFieldGet2(this, _position) < _classPrivateFieldGet2(this, _commands).length - 1) {
                    _classPrivateFieldSet2(this, _position, _classPrivateFieldGet2(this, _position) + 1);
                    _classPrivateFieldSet2(this, _locked, true);
                    _classPrivateFieldGet2(this, _commands)[_classPrivateFieldGet2(this, _position)].cmd();
                    _classPrivateFieldSet2(this, _locked, false);
                  }
                }
                hasSomethingToUndo() {
                  return _classPrivateFieldGet2(this, _position) !== -1;
                }
                hasSomethingToRedo() {
                  return _classPrivateFieldGet2(this, _position) < _classPrivateFieldGet2(this, _commands).length - 1;
                }
                destroy() {
                  _classPrivateFieldSet2(this, _commands, null);
                }
              }
              exports2.CommandManager = CommandManager;
              var _serialize = /* @__PURE__ */ new WeakSet();
              class KeyboardManager {
                constructor(callbacks) {
                  _classPrivateMethodInitSpec2(this, _serialize);
                  this.buffer = [];
                  this.callbacks = /* @__PURE__ */ new Map();
                  this.allKeys = /* @__PURE__ */ new Set();
                  const isMac = KeyboardManager.platform.isMac;
                  for (const [keys, callback] of callbacks) {
                    for (const key of keys) {
                      const isMacKey = key.startsWith("mac+");
                      if (isMac && isMacKey) {
                        this.callbacks.set(key.slice(4), callback);
                        this.allKeys.add(key.split("+").at(-1));
                      } else if (!isMac && !isMacKey) {
                        this.callbacks.set(key, callback);
                        this.allKeys.add(key.split("+").at(-1));
                      }
                    }
                  }
                }
                static get platform() {
                  const platform = typeof navigator !== "undefined" ? navigator.platform : "";
                  return (0, _util2.shadow)(this, "platform", {
                    isWin: platform.includes("Win"),
                    isMac: platform.includes("Mac")
                  });
                }
                exec(self2, event) {
                  if (!this.allKeys.has(event.key)) {
                    return;
                  }
                  const callback = this.callbacks.get(_classPrivateMethodGet2(this, _serialize, _serialize2).call(this, event));
                  if (!callback) {
                    return;
                  }
                  callback.bind(self2)();
                  event.stopPropagation();
                  event.preventDefault();
                }
              }
              exports2.KeyboardManager = KeyboardManager;
              function _serialize2(event) {
                if (event.altKey) {
                  this.buffer.push("alt");
                }
                if (event.ctrlKey) {
                  this.buffer.push("ctrl");
                }
                if (event.metaKey) {
                  this.buffer.push("meta");
                }
                if (event.shiftKey) {
                  this.buffer.push("shift");
                }
                this.buffer.push(event.key);
                const str = this.buffer.join("+");
                this.buffer.length = 0;
                return str;
              }
              var _elements = /* @__PURE__ */ new WeakMap();
              class ClipboardManager {
                constructor() {
                  _classPrivateFieldInitSpec2(this, _elements, {
                    writable: true,
                    value: null
                  });
                }
                copy(element) {
                  if (!element) {
                    return;
                  }
                  if (Array.isArray(element)) {
                    _classPrivateFieldSet2(this, _elements, element.map((el) => el.serialize()));
                  } else {
                    _classPrivateFieldSet2(this, _elements, [element.serialize()]);
                  }
                  _classPrivateFieldSet2(this, _elements, _classPrivateFieldGet2(this, _elements).filter((el) => !!el));
                  if (_classPrivateFieldGet2(this, _elements).length === 0) {
                    _classPrivateFieldSet2(this, _elements, null);
                  }
                }
                paste() {
                  return _classPrivateFieldGet2(this, _elements);
                }
                isEmpty() {
                  return _classPrivateFieldGet2(this, _elements) === null;
                }
                destroy() {
                  _classPrivateFieldSet2(this, _elements, null);
                }
              }
              class ColorManager {
                get _colors() {
                  const colors = /* @__PURE__ */ new Map([["CanvasText", null], ["Canvas", null]]);
                  (0, _display_utils2.getColorValues)(colors);
                  return (0, _util2.shadow)(this, "_colors", colors);
                }
                convert(color) {
                  const rgb = (0, _display_utils2.getRGB)(color);
                  if (!window.matchMedia("(forced-colors: active)").matches) {
                    return rgb;
                  }
                  for (const [name, RGB] of this._colors) {
                    if (RGB.every((x, i) => x === rgb[i])) {
                      return ColorManager._colorsMapping.get(name);
                    }
                  }
                  return rgb;
                }
                getHexCode(name) {
                  const rgb = this._colors.get(name);
                  if (!rgb) {
                    return name;
                  }
                  return _util2.Util.makeHexColor(...rgb);
                }
              }
              exports2.ColorManager = ColorManager;
              _defineProperty(ColorManager, "_colorsMapping", /* @__PURE__ */ new Map([["CanvasText", [0, 0, 0]], ["Canvas", [255, 255, 255]]]));
              var _activeEditor = /* @__PURE__ */ new WeakMap();
              var _allEditors = /* @__PURE__ */ new WeakMap();
              var _allLayers = /* @__PURE__ */ new WeakMap();
              var _clipboardManager = /* @__PURE__ */ new WeakMap();
              var _commandManager = /* @__PURE__ */ new WeakMap();
              var _currentPageIndex = /* @__PURE__ */ new WeakMap();
              var _editorTypes = /* @__PURE__ */ new WeakMap();
              var _eventBus = /* @__PURE__ */ new WeakMap();
              var _idManager = /* @__PURE__ */ new WeakMap();
              var _isEnabled = /* @__PURE__ */ new WeakMap();
              var _mode = /* @__PURE__ */ new WeakMap();
              var _selectedEditors = /* @__PURE__ */ new WeakMap();
              var _boundKeydown = /* @__PURE__ */ new WeakMap();
              var _boundOnEditingAction = /* @__PURE__ */ new WeakMap();
              var _boundOnPageChanging = /* @__PURE__ */ new WeakMap();
              var _previousStates = /* @__PURE__ */ new WeakMap();
              var _container = /* @__PURE__ */ new WeakMap();
              var _addKeyboardManager = /* @__PURE__ */ new WeakSet();
              var _removeKeyboardManager = /* @__PURE__ */ new WeakSet();
              var _dispatchUpdateStates = /* @__PURE__ */ new WeakSet();
              var _dispatchUpdateUI = /* @__PURE__ */ new WeakSet();
              var _enableAll = /* @__PURE__ */ new WeakSet();
              var _disableAll = /* @__PURE__ */ new WeakSet();
              var _addEditorToLayer = /* @__PURE__ */ new WeakSet();
              var _isEmpty = /* @__PURE__ */ new WeakSet();
              var _selectEditors = /* @__PURE__ */ new WeakSet();
              class AnnotationEditorUIManager {
                constructor(container, eventBus) {
                  _classPrivateMethodInitSpec2(this, _selectEditors);
                  _classPrivateMethodInitSpec2(this, _isEmpty);
                  _classPrivateMethodInitSpec2(this, _addEditorToLayer);
                  _classPrivateMethodInitSpec2(this, _disableAll);
                  _classPrivateMethodInitSpec2(this, _enableAll);
                  _classPrivateMethodInitSpec2(this, _dispatchUpdateUI);
                  _classPrivateMethodInitSpec2(this, _dispatchUpdateStates);
                  _classPrivateMethodInitSpec2(this, _removeKeyboardManager);
                  _classPrivateMethodInitSpec2(this, _addKeyboardManager);
                  _classPrivateFieldInitSpec2(this, _activeEditor, {
                    writable: true,
                    value: null
                  });
                  _classPrivateFieldInitSpec2(this, _allEditors, {
                    writable: true,
                    value: /* @__PURE__ */ new Map()
                  });
                  _classPrivateFieldInitSpec2(this, _allLayers, {
                    writable: true,
                    value: /* @__PURE__ */ new Map()
                  });
                  _classPrivateFieldInitSpec2(this, _clipboardManager, {
                    writable: true,
                    value: new ClipboardManager()
                  });
                  _classPrivateFieldInitSpec2(this, _commandManager, {
                    writable: true,
                    value: new CommandManager()
                  });
                  _classPrivateFieldInitSpec2(this, _currentPageIndex, {
                    writable: true,
                    value: 0
                  });
                  _classPrivateFieldInitSpec2(this, _editorTypes, {
                    writable: true,
                    value: null
                  });
                  _classPrivateFieldInitSpec2(this, _eventBus, {
                    writable: true,
                    value: null
                  });
                  _classPrivateFieldInitSpec2(this, _idManager, {
                    writable: true,
                    value: new IdManager()
                  });
                  _classPrivateFieldInitSpec2(this, _isEnabled, {
                    writable: true,
                    value: false
                  });
                  _classPrivateFieldInitSpec2(this, _mode, {
                    writable: true,
                    value: _util2.AnnotationEditorType.NONE
                  });
                  _classPrivateFieldInitSpec2(this, _selectedEditors, {
                    writable: true,
                    value: /* @__PURE__ */ new Set()
                  });
                  _classPrivateFieldInitSpec2(this, _boundKeydown, {
                    writable: true,
                    value: this.keydown.bind(this)
                  });
                  _classPrivateFieldInitSpec2(this, _boundOnEditingAction, {
                    writable: true,
                    value: this.onEditingAction.bind(this)
                  });
                  _classPrivateFieldInitSpec2(this, _boundOnPageChanging, {
                    writable: true,
                    value: this.onPageChanging.bind(this)
                  });
                  _classPrivateFieldInitSpec2(this, _previousStates, {
                    writable: true,
                    value: {
                      isEditing: false,
                      isEmpty: true,
                      hasEmptyClipboard: true,
                      hasSomethingToUndo: false,
                      hasSomethingToRedo: false,
                      hasSelectedEditor: false
                    }
                  });
                  _classPrivateFieldInitSpec2(this, _container, {
                    writable: true,
                    value: null
                  });
                  _classPrivateFieldSet2(this, _container, container);
                  _classPrivateFieldSet2(this, _eventBus, eventBus);
                  _classPrivateFieldGet2(this, _eventBus)._on("editingaction", _classPrivateFieldGet2(this, _boundOnEditingAction));
                  _classPrivateFieldGet2(this, _eventBus)._on("pagechanging", _classPrivateFieldGet2(this, _boundOnPageChanging));
                }
                destroy() {
                  _classPrivateMethodGet2(this, _removeKeyboardManager, _removeKeyboardManager2).call(this);
                  _classPrivateFieldGet2(this, _eventBus)._off("editingaction", _classPrivateFieldGet2(this, _boundOnEditingAction));
                  _classPrivateFieldGet2(this, _eventBus)._off("pagechanging", _classPrivateFieldGet2(this, _boundOnPageChanging));
                  for (const layer of _classPrivateFieldGet2(this, _allLayers).values()) {
                    layer.destroy();
                  }
                  _classPrivateFieldGet2(this, _allLayers).clear();
                  _classPrivateFieldGet2(this, _allEditors).clear();
                  _classPrivateFieldSet2(this, _activeEditor, null);
                  _classPrivateFieldGet2(this, _selectedEditors).clear();
                  _classPrivateFieldGet2(this, _clipboardManager).destroy();
                  _classPrivateFieldGet2(this, _commandManager).destroy();
                }
                onPageChanging(_ref2) {
                  let {
                    pageNumber
                  } = _ref2;
                  _classPrivateFieldSet2(this, _currentPageIndex, pageNumber - 1);
                }
                focusMainContainer() {
                  _classPrivateFieldGet2(this, _container).focus();
                }
                keydown(event) {
                  var _this$getActive;
                  if (!((_this$getActive = this.getActive()) !== null && _this$getActive !== void 0 && _this$getActive.shouldGetKeyboardEvents())) {
                    AnnotationEditorUIManager._keyboardManager.exec(this, event);
                  }
                }
                onEditingAction(details) {
                  if (["undo", "redo", "cut", "copy", "paste", "delete", "selectAll"].includes(details.name)) {
                    this[details.name]();
                  }
                }
                setEditingState(isEditing) {
                  if (isEditing) {
                    _classPrivateMethodGet2(this, _addKeyboardManager, _addKeyboardManager2).call(this);
                    _classPrivateMethodGet2(this, _dispatchUpdateStates, _dispatchUpdateStates2).call(this, {
                      isEditing: _classPrivateFieldGet2(this, _mode) !== _util2.AnnotationEditorType.NONE,
                      isEmpty: _classPrivateMethodGet2(this, _isEmpty, _isEmpty2).call(this),
                      hasSomethingToUndo: _classPrivateFieldGet2(this, _commandManager).hasSomethingToUndo(),
                      hasSomethingToRedo: _classPrivateFieldGet2(this, _commandManager).hasSomethingToRedo(),
                      hasSelectedEditor: false,
                      hasEmptyClipboard: _classPrivateFieldGet2(this, _clipboardManager).isEmpty()
                    });
                  } else {
                    _classPrivateMethodGet2(this, _removeKeyboardManager, _removeKeyboardManager2).call(this);
                    _classPrivateMethodGet2(this, _dispatchUpdateStates, _dispatchUpdateStates2).call(this, {
                      isEditing: false
                    });
                  }
                }
                registerEditorTypes(types) {
                  _classPrivateFieldSet2(this, _editorTypes, types);
                  for (const editorType of _classPrivateFieldGet2(this, _editorTypes)) {
                    _classPrivateMethodGet2(this, _dispatchUpdateUI, _dispatchUpdateUI2).call(this, editorType.defaultPropertiesToUpdate);
                  }
                }
                getId() {
                  return _classPrivateFieldGet2(this, _idManager).getId();
                }
                addLayer(layer) {
                  _classPrivateFieldGet2(this, _allLayers).set(layer.pageIndex, layer);
                  if (_classPrivateFieldGet2(this, _isEnabled)) {
                    layer.enable();
                  } else {
                    layer.disable();
                  }
                }
                removeLayer(layer) {
                  _classPrivateFieldGet2(this, _allLayers).delete(layer.pageIndex);
                }
                updateMode(mode) {
                  _classPrivateFieldSet2(this, _mode, mode);
                  if (mode === _util2.AnnotationEditorType.NONE) {
                    this.setEditingState(false);
                    _classPrivateMethodGet2(this, _disableAll, _disableAll2).call(this);
                  } else {
                    this.setEditingState(true);
                    _classPrivateMethodGet2(this, _enableAll, _enableAll2).call(this);
                    for (const layer of _classPrivateFieldGet2(this, _allLayers).values()) {
                      layer.updateMode(mode);
                    }
                  }
                }
                updateToolbar(mode) {
                  if (mode === _classPrivateFieldGet2(this, _mode)) {
                    return;
                  }
                  _classPrivateFieldGet2(this, _eventBus).dispatch("switchannotationeditormode", {
                    source: this,
                    mode
                  });
                }
                updateParams(type, value) {
                  for (const editor of _classPrivateFieldGet2(this, _selectedEditors)) {
                    editor.updateParams(type, value);
                  }
                  for (const editorType of _classPrivateFieldGet2(this, _editorTypes)) {
                    editorType.updateDefaultParams(type, value);
                  }
                }
                getEditors(pageIndex) {
                  const editors = [];
                  for (const editor of _classPrivateFieldGet2(this, _allEditors).values()) {
                    if (editor.pageIndex === pageIndex) {
                      editors.push(editor);
                    }
                  }
                  return editors;
                }
                getEditor(id) {
                  return _classPrivateFieldGet2(this, _allEditors).get(id);
                }
                addEditor(editor) {
                  _classPrivateFieldGet2(this, _allEditors).set(editor.id, editor);
                }
                removeEditor(editor) {
                  _classPrivateFieldGet2(this, _allEditors).delete(editor.id);
                  this.unselect(editor);
                }
                setActiveEditor(editor) {
                  if (_classPrivateFieldGet2(this, _activeEditor) === editor) {
                    return;
                  }
                  _classPrivateFieldSet2(this, _activeEditor, editor);
                  if (editor) {
                    _classPrivateMethodGet2(this, _dispatchUpdateUI, _dispatchUpdateUI2).call(this, editor.propertiesToUpdate);
                  }
                }
                toggleSelected(editor) {
                  if (_classPrivateFieldGet2(this, _selectedEditors).has(editor)) {
                    _classPrivateFieldGet2(this, _selectedEditors).delete(editor);
                    editor.unselect();
                    _classPrivateMethodGet2(this, _dispatchUpdateStates, _dispatchUpdateStates2).call(this, {
                      hasSelectedEditor: this.hasSelection
                    });
                    return;
                  }
                  _classPrivateFieldGet2(this, _selectedEditors).add(editor);
                  editor.select();
                  _classPrivateMethodGet2(this, _dispatchUpdateUI, _dispatchUpdateUI2).call(this, editor.propertiesToUpdate);
                  _classPrivateMethodGet2(this, _dispatchUpdateStates, _dispatchUpdateStates2).call(this, {
                    hasSelectedEditor: true
                  });
                }
                setSelected(editor) {
                  for (const ed of _classPrivateFieldGet2(this, _selectedEditors)) {
                    if (ed !== editor) {
                      ed.unselect();
                    }
                  }
                  _classPrivateFieldGet2(this, _selectedEditors).clear();
                  _classPrivateFieldGet2(this, _selectedEditors).add(editor);
                  editor.select();
                  _classPrivateMethodGet2(this, _dispatchUpdateUI, _dispatchUpdateUI2).call(this, editor.propertiesToUpdate);
                  _classPrivateMethodGet2(this, _dispatchUpdateStates, _dispatchUpdateStates2).call(this, {
                    hasSelectedEditor: true
                  });
                }
                isSelected(editor) {
                  return _classPrivateFieldGet2(this, _selectedEditors).has(editor);
                }
                unselect(editor) {
                  editor.unselect();
                  _classPrivateFieldGet2(this, _selectedEditors).delete(editor);
                  _classPrivateMethodGet2(this, _dispatchUpdateStates, _dispatchUpdateStates2).call(this, {
                    hasSelectedEditor: this.hasSelection
                  });
                }
                get hasSelection() {
                  return _classPrivateFieldGet2(this, _selectedEditors).size !== 0;
                }
                undo() {
                  _classPrivateFieldGet2(this, _commandManager).undo();
                  _classPrivateMethodGet2(this, _dispatchUpdateStates, _dispatchUpdateStates2).call(this, {
                    hasSomethingToUndo: _classPrivateFieldGet2(this, _commandManager).hasSomethingToUndo(),
                    hasSomethingToRedo: true,
                    isEmpty: _classPrivateMethodGet2(this, _isEmpty, _isEmpty2).call(this)
                  });
                }
                redo() {
                  _classPrivateFieldGet2(this, _commandManager).redo();
                  _classPrivateMethodGet2(this, _dispatchUpdateStates, _dispatchUpdateStates2).call(this, {
                    hasSomethingToUndo: true,
                    hasSomethingToRedo: _classPrivateFieldGet2(this, _commandManager).hasSomethingToRedo(),
                    isEmpty: _classPrivateMethodGet2(this, _isEmpty, _isEmpty2).call(this)
                  });
                }
                addCommands(params) {
                  _classPrivateFieldGet2(this, _commandManager).add(params);
                  _classPrivateMethodGet2(this, _dispatchUpdateStates, _dispatchUpdateStates2).call(this, {
                    hasSomethingToUndo: true,
                    hasSomethingToRedo: false,
                    isEmpty: _classPrivateMethodGet2(this, _isEmpty, _isEmpty2).call(this)
                  });
                }
                delete() {
                  if (_classPrivateFieldGet2(this, _activeEditor)) {
                    _classPrivateFieldGet2(this, _activeEditor).commitOrRemove();
                  }
                  if (!this.hasSelection) {
                    return;
                  }
                  const editors = [..._classPrivateFieldGet2(this, _selectedEditors)];
                  const cmd = () => {
                    for (const editor of editors) {
                      editor.remove();
                    }
                  };
                  const undo = () => {
                    for (const editor of editors) {
                      _classPrivateMethodGet2(this, _addEditorToLayer, _addEditorToLayer2).call(this, editor);
                    }
                  };
                  this.addCommands({
                    cmd,
                    undo,
                    mustExec: true
                  });
                }
                copy() {
                  if (_classPrivateFieldGet2(this, _activeEditor)) {
                    _classPrivateFieldGet2(this, _activeEditor).commitOrRemove();
                  }
                  if (this.hasSelection) {
                    const editors = [];
                    for (const editor of _classPrivateFieldGet2(this, _selectedEditors)) {
                      if (!editor.isEmpty()) {
                        editors.push(editor);
                      }
                    }
                    if (editors.length === 0) {
                      return;
                    }
                    _classPrivateFieldGet2(this, _clipboardManager).copy(editors);
                    _classPrivateMethodGet2(this, _dispatchUpdateStates, _dispatchUpdateStates2).call(this, {
                      hasEmptyClipboard: false
                    });
                  }
                }
                cut() {
                  this.copy();
                  this.delete();
                }
                paste() {
                  if (_classPrivateFieldGet2(this, _clipboardManager).isEmpty()) {
                    return;
                  }
                  this.unselectAll();
                  const layer = _classPrivateFieldGet2(this, _allLayers).get(_classPrivateFieldGet2(this, _currentPageIndex));
                  const newEditors = _classPrivateFieldGet2(this, _clipboardManager).paste().map((data) => layer.deserialize(data));
                  const cmd = () => {
                    for (const editor of newEditors) {
                      _classPrivateMethodGet2(this, _addEditorToLayer, _addEditorToLayer2).call(this, editor);
                    }
                    _classPrivateMethodGet2(this, _selectEditors, _selectEditors2).call(this, newEditors);
                  };
                  const undo = () => {
                    for (const editor of newEditors) {
                      editor.remove();
                    }
                  };
                  this.addCommands({
                    cmd,
                    undo,
                    mustExec: true
                  });
                }
                selectAll() {
                  for (const editor of _classPrivateFieldGet2(this, _selectedEditors)) {
                    editor.commit();
                  }
                  _classPrivateMethodGet2(this, _selectEditors, _selectEditors2).call(this, _classPrivateFieldGet2(this, _allEditors).values());
                }
                unselectAll() {
                  if (_classPrivateFieldGet2(this, _activeEditor)) {
                    _classPrivateFieldGet2(this, _activeEditor).commitOrRemove();
                    return;
                  }
                  if (_classPrivateMethodGet2(this, _selectEditors, _selectEditors2).size === 0) {
                    return;
                  }
                  for (const editor of _classPrivateFieldGet2(this, _selectedEditors)) {
                    editor.unselect();
                  }
                  _classPrivateFieldGet2(this, _selectedEditors).clear();
                  _classPrivateMethodGet2(this, _dispatchUpdateStates, _dispatchUpdateStates2).call(this, {
                    hasSelectedEditor: false
                  });
                }
                isActive(editor) {
                  return _classPrivateFieldGet2(this, _activeEditor) === editor;
                }
                getActive() {
                  return _classPrivateFieldGet2(this, _activeEditor);
                }
                getMode() {
                  return _classPrivateFieldGet2(this, _mode);
                }
              }
              exports2.AnnotationEditorUIManager = AnnotationEditorUIManager;
              function _addKeyboardManager2() {
                _classPrivateFieldGet2(this, _container).addEventListener("keydown", _classPrivateFieldGet2(this, _boundKeydown));
              }
              function _removeKeyboardManager2() {
                _classPrivateFieldGet2(this, _container).removeEventListener("keydown", _classPrivateFieldGet2(this, _boundKeydown));
              }
              function _dispatchUpdateStates2(details) {
                const hasChanged = Object.entries(details).some((_ref3) => {
                  let [key, value] = _ref3;
                  return _classPrivateFieldGet2(this, _previousStates)[key] !== value;
                });
                if (hasChanged) {
                  _classPrivateFieldGet2(this, _eventBus).dispatch("annotationeditorstateschanged", {
                    source: this,
                    details: Object.assign(_classPrivateFieldGet2(this, _previousStates), details)
                  });
                }
              }
              function _dispatchUpdateUI2(details) {
                _classPrivateFieldGet2(this, _eventBus).dispatch("annotationeditorparamschanged", {
                  source: this,
                  details
                });
              }
              function _enableAll2() {
                if (!_classPrivateFieldGet2(this, _isEnabled)) {
                  _classPrivateFieldSet2(this, _isEnabled, true);
                  for (const layer of _classPrivateFieldGet2(this, _allLayers).values()) {
                    layer.enable();
                  }
                }
              }
              function _disableAll2() {
                this.unselectAll();
                if (_classPrivateFieldGet2(this, _isEnabled)) {
                  _classPrivateFieldSet2(this, _isEnabled, false);
                  for (const layer of _classPrivateFieldGet2(this, _allLayers).values()) {
                    layer.disable();
                  }
                }
              }
              function _addEditorToLayer2(editor) {
                const layer = _classPrivateFieldGet2(this, _allLayers).get(editor.pageIndex);
                if (layer) {
                  layer.addOrRebuild(editor);
                } else {
                  this.addEditor(editor);
                }
              }
              function _isEmpty2() {
                if (_classPrivateFieldGet2(this, _allEditors).size === 0) {
                  return true;
                }
                if (_classPrivateFieldGet2(this, _allEditors).size === 1) {
                  for (const editor of _classPrivateFieldGet2(this, _allEditors).values()) {
                    return editor.isEmpty();
                  }
                }
                return false;
              }
              function _selectEditors2(editors) {
                _classPrivateFieldGet2(this, _selectedEditors).clear();
                for (const editor of editors) {
                  if (editor.isEmpty()) {
                    continue;
                  }
                  _classPrivateFieldGet2(this, _selectedEditors).add(editor);
                  editor.select();
                }
                _classPrivateMethodGet2(this, _dispatchUpdateStates, _dispatchUpdateStates2).call(this, {
                  hasSelectedEditor: true
                });
              }
              _defineProperty(AnnotationEditorUIManager, "_keyboardManager", new KeyboardManager([[["ctrl+a", "mac+meta+a"], AnnotationEditorUIManager.prototype.selectAll], [["ctrl+c", "mac+meta+c"], AnnotationEditorUIManager.prototype.copy], [["ctrl+v", "mac+meta+v"], AnnotationEditorUIManager.prototype.paste], [["ctrl+x", "mac+meta+x"], AnnotationEditorUIManager.prototype.cut], [["ctrl+z", "mac+meta+z"], AnnotationEditorUIManager.prototype.undo], [["ctrl+y", "ctrl+shift+Z", "mac+meta+shift+Z"], AnnotationEditorUIManager.prototype.redo], [["Backspace", "alt+Backspace", "ctrl+Backspace", "shift+Backspace", "mac+Backspace", "mac+alt+Backspace", "mac+ctrl+Backspace", "Delete", "ctrl+Delete", "shift+Delete"], AnnotationEditorUIManager.prototype.delete], [["Escape", "mac+Escape"], AnnotationEditorUIManager.prototype.unselectAll]]));
            },
            /* 133 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.StatTimer = exports2.RenderingCancelledException = exports2.PixelsPerInch = exports2.PageViewport = exports2.PDFDateString = exports2.DOMStandardFontDataFactory = exports2.DOMSVGFactory = exports2.DOMCanvasFactory = exports2.DOMCMapReaderFactory = exports2.AnnotationPrefix = void 0;
              exports2.deprecated = deprecated;
              exports2.getColorValues = getColorValues;
              exports2.getCurrentTransform = getCurrentTransform;
              exports2.getCurrentTransformInverse = getCurrentTransformInverse;
              exports2.getFilenameFromUrl = getFilenameFromUrl;
              exports2.getPdfFilenameFromUrl = getPdfFilenameFromUrl;
              exports2.getRGB = getRGB;
              exports2.getXfaPageViewport = getXfaPageViewport;
              exports2.isDataScheme = isDataScheme;
              exports2.isPdfFile = isPdfFile;
              exports2.isValidFetchUrl = isValidFetchUrl;
              exports2.loadScript = loadScript;
              var _base_factory = __w_pdfjs_require__2(134);
              var _util2 = __w_pdfjs_require__2(1);
              function _defineProperty(obj, key, value) {
                if (key in obj) {
                  Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
                } else {
                  obj[key] = value;
                }
                return obj;
              }
              const SVG_NS = "http://www.w3.org/2000/svg";
              const AnnotationPrefix = "pdfjs_internal_id_";
              exports2.AnnotationPrefix = AnnotationPrefix;
              class PixelsPerInch {
              }
              exports2.PixelsPerInch = PixelsPerInch;
              _defineProperty(PixelsPerInch, "CSS", 96);
              _defineProperty(PixelsPerInch, "PDF", 72);
              _defineProperty(PixelsPerInch, "PDF_TO_CSS_UNITS", PixelsPerInch.CSS / PixelsPerInch.PDF);
              class DOMCanvasFactory extends _base_factory.BaseCanvasFactory {
                constructor() {
                  let {
                    ownerDocument = globalThis.document
                  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                  super();
                  this._document = ownerDocument;
                }
                _createCanvas(width, height) {
                  const canvas = this._document.createElement("canvas");
                  canvas.width = width;
                  canvas.height = height;
                  return canvas;
                }
              }
              exports2.DOMCanvasFactory = DOMCanvasFactory;
              async function fetchData(url) {
                let asTypedArray = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                if (isValidFetchUrl(url, document.baseURI)) {
                  const response = await fetch(url);
                  if (!response.ok) {
                    throw new Error(response.statusText);
                  }
                  return asTypedArray ? new Uint8Array(await response.arrayBuffer()) : (0, _util2.stringToBytes)(await response.text());
                }
                return new Promise((resolve, reject) => {
                  const request = new XMLHttpRequest();
                  request.open("GET", url, true);
                  if (asTypedArray) {
                    request.responseType = "arraybuffer";
                  }
                  request.onreadystatechange = () => {
                    if (request.readyState !== XMLHttpRequest.DONE) {
                      return;
                    }
                    if (request.status === 200 || request.status === 0) {
                      let data;
                      if (asTypedArray && request.response) {
                        data = new Uint8Array(request.response);
                      } else if (!asTypedArray && request.responseText) {
                        data = (0, _util2.stringToBytes)(request.responseText);
                      }
                      if (data) {
                        resolve(data);
                        return;
                      }
                    }
                    reject(new Error(request.statusText));
                  };
                  request.send(null);
                });
              }
              class DOMCMapReaderFactory extends _base_factory.BaseCMapReaderFactory {
                _fetchData(url, compressionType) {
                  return fetchData(url, this.isCompressed).then((data) => {
                    return {
                      cMapData: data,
                      compressionType
                    };
                  });
                }
              }
              exports2.DOMCMapReaderFactory = DOMCMapReaderFactory;
              class DOMStandardFontDataFactory extends _base_factory.BaseStandardFontDataFactory {
                _fetchData(url) {
                  return fetchData(url, true);
                }
              }
              exports2.DOMStandardFontDataFactory = DOMStandardFontDataFactory;
              class DOMSVGFactory extends _base_factory.BaseSVGFactory {
                _createSVG(type) {
                  return document.createElementNS(SVG_NS, type);
                }
              }
              exports2.DOMSVGFactory = DOMSVGFactory;
              class PageViewport {
                constructor(_ref) {
                  let {
                    viewBox,
                    scale,
                    rotation,
                    offsetX = 0,
                    offsetY = 0,
                    dontFlip = false
                  } = _ref;
                  this.viewBox = viewBox;
                  this.scale = scale;
                  this.rotation = rotation;
                  this.offsetX = offsetX;
                  this.offsetY = offsetY;
                  const centerX = (viewBox[2] + viewBox[0]) / 2;
                  const centerY = (viewBox[3] + viewBox[1]) / 2;
                  let rotateA, rotateB, rotateC, rotateD;
                  rotation %= 360;
                  if (rotation < 0) {
                    rotation += 360;
                  }
                  switch (rotation) {
                    case 180:
                      rotateA = -1;
                      rotateB = 0;
                      rotateC = 0;
                      rotateD = 1;
                      break;
                    case 90:
                      rotateA = 0;
                      rotateB = 1;
                      rotateC = 1;
                      rotateD = 0;
                      break;
                    case 270:
                      rotateA = 0;
                      rotateB = -1;
                      rotateC = -1;
                      rotateD = 0;
                      break;
                    case 0:
                      rotateA = 1;
                      rotateB = 0;
                      rotateC = 0;
                      rotateD = -1;
                      break;
                    default:
                      throw new Error("PageViewport: Invalid rotation, must be a multiple of 90 degrees.");
                  }
                  if (dontFlip) {
                    rotateC = -rotateC;
                    rotateD = -rotateD;
                  }
                  let offsetCanvasX, offsetCanvasY;
                  let width, height;
                  if (rotateA === 0) {
                    offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX;
                    offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY;
                    width = Math.abs(viewBox[3] - viewBox[1]) * scale;
                    height = Math.abs(viewBox[2] - viewBox[0]) * scale;
                  } else {
                    offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX;
                    offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY;
                    width = Math.abs(viewBox[2] - viewBox[0]) * scale;
                    height = Math.abs(viewBox[3] - viewBox[1]) * scale;
                  }
                  this.transform = [rotateA * scale, rotateB * scale, rotateC * scale, rotateD * scale, offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY, offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY];
                  this.width = width;
                  this.height = height;
                }
                clone() {
                  let {
                    scale = this.scale,
                    rotation = this.rotation,
                    offsetX = this.offsetX,
                    offsetY = this.offsetY,
                    dontFlip = false
                  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                  return new PageViewport({
                    viewBox: this.viewBox.slice(),
                    scale,
                    rotation,
                    offsetX,
                    offsetY,
                    dontFlip
                  });
                }
                convertToViewportPoint(x, y) {
                  return _util2.Util.applyTransform([x, y], this.transform);
                }
                convertToViewportRectangle(rect) {
                  const topLeft = _util2.Util.applyTransform([rect[0], rect[1]], this.transform);
                  const bottomRight = _util2.Util.applyTransform([rect[2], rect[3]], this.transform);
                  return [topLeft[0], topLeft[1], bottomRight[0], bottomRight[1]];
                }
                convertToPdfPoint(x, y) {
                  return _util2.Util.applyInverseTransform([x, y], this.transform);
                }
              }
              exports2.PageViewport = PageViewport;
              class RenderingCancelledException extends _util2.BaseException {
                constructor(msg, type) {
                  super(msg, "RenderingCancelledException");
                  this.type = type;
                }
              }
              exports2.RenderingCancelledException = RenderingCancelledException;
              function isDataScheme(url) {
                const ii = url.length;
                let i = 0;
                while (i < ii && url[i].trim() === "") {
                  i++;
                }
                return url.substring(i, i + 5).toLowerCase() === "data:";
              }
              function isPdfFile(filename) {
                return typeof filename === "string" && /\.pdf$/i.test(filename);
              }
              function getFilenameFromUrl(url) {
                const anchor = url.indexOf("#");
                const query = url.indexOf("?");
                const end = Math.min(anchor > 0 ? anchor : url.length, query > 0 ? query : url.length);
                return url.substring(url.lastIndexOf("/", end) + 1, end);
              }
              function getPdfFilenameFromUrl(url) {
                let defaultFilename = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "document.pdf";
                if (typeof url !== "string") {
                  return defaultFilename;
                }
                if (isDataScheme(url)) {
                  (0, _util2.warn)('getPdfFilenameFromUrl: ignore "data:"-URL for performance reasons.');
                  return defaultFilename;
                }
                const reURI = /^(?:(?:[^:]+:)?\/\/[^/]+)?([^?#]*)(\?[^#]*)?(#.*)?$/;
                const reFilename = /[^/?#=]+\.pdf\b(?!.*\.pdf\b)/i;
                const splitURI = reURI.exec(url);
                let suggestedFilename = reFilename.exec(splitURI[1]) || reFilename.exec(splitURI[2]) || reFilename.exec(splitURI[3]);
                if (suggestedFilename) {
                  suggestedFilename = suggestedFilename[0];
                  if (suggestedFilename.includes("%")) {
                    try {
                      suggestedFilename = reFilename.exec(decodeURIComponent(suggestedFilename))[0];
                    } catch (ex) {
                    }
                  }
                }
                return suggestedFilename || defaultFilename;
              }
              class StatTimer {
                constructor() {
                  this.started = /* @__PURE__ */ Object.create(null);
                  this.times = [];
                }
                time(name) {
                  if (name in this.started) {
                    (0, _util2.warn)(`Timer is already running for ${name}`);
                  }
                  this.started[name] = Date.now();
                }
                timeEnd(name) {
                  if (!(name in this.started)) {
                    (0, _util2.warn)(`Timer has not been started for ${name}`);
                  }
                  this.times.push({
                    name,
                    start: this.started[name],
                    end: Date.now()
                  });
                  delete this.started[name];
                }
                toString() {
                  const outBuf = [];
                  let longest = 0;
                  for (const time of this.times) {
                    const name = time.name;
                    if (name.length > longest) {
                      longest = name.length;
                    }
                  }
                  for (const time of this.times) {
                    const duration = time.end - time.start;
                    outBuf.push(`${time.name.padEnd(longest)} ${duration}ms
`);
                  }
                  return outBuf.join("");
                }
              }
              exports2.StatTimer = StatTimer;
              function isValidFetchUrl(url, baseUrl) {
                try {
                  const {
                    protocol
                  } = baseUrl ? new URL(url, baseUrl) : new URL(url);
                  return protocol === "http:" || protocol === "https:";
                } catch (ex) {
                  return false;
                }
              }
              function loadScript(src) {
                let removeScriptElement = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                return new Promise((resolve, reject) => {
                  const script = document.createElement("script");
                  script.src = src;
                  script.onload = function(evt) {
                    if (removeScriptElement) {
                      script.remove();
                    }
                    resolve(evt);
                  };
                  script.onerror = function() {
                    reject(new Error(`Cannot load script at: ${script.src}`));
                  };
                  (document.head || document.documentElement).append(script);
                });
              }
              function deprecated(details) {
                console.log("Deprecated API usage: " + details);
              }
              let pdfDateStringRegex;
              class PDFDateString {
                static toDateObject(input) {
                  if (!input || typeof input !== "string") {
                    return null;
                  }
                  if (!pdfDateStringRegex) {
                    pdfDateStringRegex = new RegExp("^D:(\\d{4})(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?([Z|+|-])?(\\d{2})?'?(\\d{2})?'?");
                  }
                  const matches = pdfDateStringRegex.exec(input);
                  if (!matches) {
                    return null;
                  }
                  const year = parseInt(matches[1], 10);
                  let month = parseInt(matches[2], 10);
                  month = month >= 1 && month <= 12 ? month - 1 : 0;
                  let day = parseInt(matches[3], 10);
                  day = day >= 1 && day <= 31 ? day : 1;
                  let hour = parseInt(matches[4], 10);
                  hour = hour >= 0 && hour <= 23 ? hour : 0;
                  let minute = parseInt(matches[5], 10);
                  minute = minute >= 0 && minute <= 59 ? minute : 0;
                  let second = parseInt(matches[6], 10);
                  second = second >= 0 && second <= 59 ? second : 0;
                  const universalTimeRelation = matches[7] || "Z";
                  let offsetHour = parseInt(matches[8], 10);
                  offsetHour = offsetHour >= 0 && offsetHour <= 23 ? offsetHour : 0;
                  let offsetMinute = parseInt(matches[9], 10) || 0;
                  offsetMinute = offsetMinute >= 0 && offsetMinute <= 59 ? offsetMinute : 0;
                  if (universalTimeRelation === "-") {
                    hour += offsetHour;
                    minute += offsetMinute;
                  } else if (universalTimeRelation === "+") {
                    hour -= offsetHour;
                    minute -= offsetMinute;
                  }
                  return new Date(Date.UTC(year, month, day, hour, minute, second));
                }
              }
              exports2.PDFDateString = PDFDateString;
              function getXfaPageViewport(xfaPage, _ref2) {
                let {
                  scale = 1,
                  rotation = 0
                } = _ref2;
                const {
                  width,
                  height
                } = xfaPage.attributes.style;
                const viewBox = [0, 0, parseInt(width), parseInt(height)];
                return new PageViewport({
                  viewBox,
                  scale,
                  rotation
                });
              }
              function getRGB(color) {
                if (color.startsWith("#")) {
                  const colorRGB = parseInt(color.slice(1), 16);
                  return [(colorRGB & 16711680) >> 16, (colorRGB & 65280) >> 8, colorRGB & 255];
                }
                if (color.startsWith("rgb(")) {
                  return color.slice(4, -1).split(",").map((x) => parseInt(x));
                }
                if (color.startsWith("rgba(")) {
                  return color.slice(5, -1).split(",").map((x) => parseInt(x)).slice(0, 3);
                }
                (0, _util2.warn)(`Not a valid color format: "${color}"`);
                return [0, 0, 0];
              }
              function getColorValues(colors) {
                const span = document.createElement("span");
                span.style.visibility = "hidden";
                document.body.append(span);
                for (const name of colors.keys()) {
                  span.style.color = name;
                  const computedColor = window.getComputedStyle(span).color;
                  colors.set(name, getRGB(computedColor));
                }
                span.remove();
              }
              function getCurrentTransform(ctx) {
                const {
                  a,
                  b,
                  c,
                  d,
                  e,
                  f
                } = ctx.getTransform();
                return [a, b, c, d, e, f];
              }
              function getCurrentTransformInverse(ctx) {
                const {
                  a,
                  b,
                  c,
                  d,
                  e,
                  f
                } = ctx.getTransform().invertSelf();
                return [a, b, c, d, e, f];
              }
            },
            /* 134 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.BaseStandardFontDataFactory = exports2.BaseSVGFactory = exports2.BaseCanvasFactory = exports2.BaseCMapReaderFactory = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              class BaseCanvasFactory {
                constructor() {
                  if (this.constructor === BaseCanvasFactory) {
                    (0, _util2.unreachable)("Cannot initialize BaseCanvasFactory.");
                  }
                }
                create(width, height) {
                  if (width <= 0 || height <= 0) {
                    throw new Error("Invalid canvas size");
                  }
                  const canvas = this._createCanvas(width, height);
                  return {
                    canvas,
                    context: canvas.getContext("2d")
                  };
                }
                reset(canvasAndContext, width, height) {
                  if (!canvasAndContext.canvas) {
                    throw new Error("Canvas is not specified");
                  }
                  if (width <= 0 || height <= 0) {
                    throw new Error("Invalid canvas size");
                  }
                  canvasAndContext.canvas.width = width;
                  canvasAndContext.canvas.height = height;
                }
                destroy(canvasAndContext) {
                  if (!canvasAndContext.canvas) {
                    throw new Error("Canvas is not specified");
                  }
                  canvasAndContext.canvas.width = 0;
                  canvasAndContext.canvas.height = 0;
                  canvasAndContext.canvas = null;
                  canvasAndContext.context = null;
                }
                _createCanvas(width, height) {
                  (0, _util2.unreachable)("Abstract method `_createCanvas` called.");
                }
              }
              exports2.BaseCanvasFactory = BaseCanvasFactory;
              class BaseCMapReaderFactory {
                constructor(_ref) {
                  let {
                    baseUrl = null,
                    isCompressed = false
                  } = _ref;
                  if (this.constructor === BaseCMapReaderFactory) {
                    (0, _util2.unreachable)("Cannot initialize BaseCMapReaderFactory.");
                  }
                  this.baseUrl = baseUrl;
                  this.isCompressed = isCompressed;
                }
                async fetch(_ref2) {
                  let {
                    name
                  } = _ref2;
                  if (!this.baseUrl) {
                    throw new Error('The CMap "baseUrl" parameter must be specified, ensure that the "cMapUrl" and "cMapPacked" API parameters are provided.');
                  }
                  if (!name) {
                    throw new Error("CMap name must be specified.");
                  }
                  const url = this.baseUrl + name + (this.isCompressed ? ".bcmap" : "");
                  const compressionType = this.isCompressed ? _util2.CMapCompressionType.BINARY : _util2.CMapCompressionType.NONE;
                  return this._fetchData(url, compressionType).catch((reason) => {
                    throw new Error(`Unable to load ${this.isCompressed ? "binary " : ""}CMap at: ${url}`);
                  });
                }
                _fetchData(url, compressionType) {
                  (0, _util2.unreachable)("Abstract method `_fetchData` called.");
                }
              }
              exports2.BaseCMapReaderFactory = BaseCMapReaderFactory;
              class BaseStandardFontDataFactory {
                constructor(_ref3) {
                  let {
                    baseUrl = null
                  } = _ref3;
                  if (this.constructor === BaseStandardFontDataFactory) {
                    (0, _util2.unreachable)("Cannot initialize BaseStandardFontDataFactory.");
                  }
                  this.baseUrl = baseUrl;
                }
                async fetch(_ref4) {
                  let {
                    filename
                  } = _ref4;
                  if (!this.baseUrl) {
                    throw new Error('The standard font "baseUrl" parameter must be specified, ensure that the "standardFontDataUrl" API parameter is provided.');
                  }
                  if (!filename) {
                    throw new Error("Font filename must be specified.");
                  }
                  const url = `${this.baseUrl}${filename}`;
                  return this._fetchData(url).catch((reason) => {
                    throw new Error(`Unable to load font data at: ${url}`);
                  });
                }
                _fetchData(url) {
                  (0, _util2.unreachable)("Abstract method `_fetchData` called.");
                }
              }
              exports2.BaseStandardFontDataFactory = BaseStandardFontDataFactory;
              class BaseSVGFactory {
                constructor() {
                  if (this.constructor === BaseSVGFactory) {
                    (0, _util2.unreachable)("Cannot initialize BaseSVGFactory.");
                  }
                }
                create(width, height) {
                  let skipDimensions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                  if (width <= 0 || height <= 0) {
                    throw new Error("Invalid SVG dimensions");
                  }
                  const svg = this._createSVG("svg:svg");
                  svg.setAttribute("version", "1.1");
                  if (!skipDimensions) {
                    svg.setAttribute("width", `${width}px`);
                    svg.setAttribute("height", `${height}px`);
                  }
                  svg.setAttribute("preserveAspectRatio", "none");
                  svg.setAttribute("viewBox", `0 0 ${width} ${height}`);
                  return svg;
                }
                createElement(type) {
                  if (typeof type !== "string") {
                    throw new Error("Invalid SVG element type");
                  }
                  return this._createSVG(type);
                }
                _createSVG(type) {
                  (0, _util2.unreachable)("Abstract method `_createSVG` called.");
                }
              }
              exports2.BaseSVGFactory = BaseSVGFactory;
            },
            /* 135 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.MurmurHash3_64 = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              const SEED = 3285377520;
              const MASK_HIGH = 4294901760;
              const MASK_LOW = 65535;
              class MurmurHash3_64 {
                constructor(seed) {
                  this.h1 = seed ? seed & 4294967295 : SEED;
                  this.h2 = seed ? seed & 4294967295 : SEED;
                }
                update(input) {
                  let data, length;
                  if (typeof input === "string") {
                    data = new Uint8Array(input.length * 2);
                    length = 0;
                    for (let i = 0, ii = input.length; i < ii; i++) {
                      const code = input.charCodeAt(i);
                      if (code <= 255) {
                        data[length++] = code;
                      } else {
                        data[length++] = code >>> 8;
                        data[length++] = code & 255;
                      }
                    }
                  } else if ((0, _util2.isArrayBuffer)(input)) {
                    data = input.slice();
                    length = data.byteLength;
                  } else {
                    throw new Error("Wrong data format in MurmurHash3_64_update. Input must be a string or array.");
                  }
                  const blockCounts = length >> 2;
                  const tailLength = length - blockCounts * 4;
                  const dataUint32 = new Uint32Array(data.buffer, 0, blockCounts);
                  let k1 = 0, k2 = 0;
                  let h1 = this.h1, h2 = this.h2;
                  const C1 = 3432918353, C2 = 461845907;
                  const C1_LOW = C1 & MASK_LOW, C2_LOW = C2 & MASK_LOW;
                  for (let i = 0; i < blockCounts; i++) {
                    if (i & 1) {
                      k1 = dataUint32[i];
                      k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;
                      k1 = k1 << 15 | k1 >>> 17;
                      k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;
                      h1 ^= k1;
                      h1 = h1 << 13 | h1 >>> 19;
                      h1 = h1 * 5 + 3864292196;
                    } else {
                      k2 = dataUint32[i];
                      k2 = k2 * C1 & MASK_HIGH | k2 * C1_LOW & MASK_LOW;
                      k2 = k2 << 15 | k2 >>> 17;
                      k2 = k2 * C2 & MASK_HIGH | k2 * C2_LOW & MASK_LOW;
                      h2 ^= k2;
                      h2 = h2 << 13 | h2 >>> 19;
                      h2 = h2 * 5 + 3864292196;
                    }
                  }
                  k1 = 0;
                  switch (tailLength) {
                    case 3:
                      k1 ^= data[blockCounts * 4 + 2] << 16;
                    case 2:
                      k1 ^= data[blockCounts * 4 + 1] << 8;
                    case 1:
                      k1 ^= data[blockCounts * 4];
                      k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;
                      k1 = k1 << 15 | k1 >>> 17;
                      k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;
                      if (blockCounts & 1) {
                        h1 ^= k1;
                      } else {
                        h2 ^= k1;
                      }
                  }
                  this.h1 = h1;
                  this.h2 = h2;
                }
                hexdigest() {
                  let h1 = this.h1, h2 = this.h2;
                  h1 ^= h2 >>> 1;
                  h1 = h1 * 3981806797 & MASK_HIGH | h1 * 36045 & MASK_LOW;
                  h2 = h2 * 4283543511 & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 2950163797 & MASK_HIGH) >>> 16;
                  h1 ^= h2 >>> 1;
                  h1 = h1 * 444984403 & MASK_HIGH | h1 * 60499 & MASK_LOW;
                  h2 = h2 * 3301882366 & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 3120437893 & MASK_HIGH) >>> 16;
                  h1 ^= h2 >>> 1;
                  const hex1 = (h1 >>> 0).toString(16), hex2 = (h2 >>> 0).toString(16);
                  return hex1.padStart(8, "0") + hex2.padStart(8, "0");
                }
              }
              exports2.MurmurHash3_64 = MurmurHash3_64;
            },
            /* 136 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.FontLoader = exports2.FontFaceObject = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              class BaseFontLoader {
                constructor(_ref) {
                  let {
                    docId,
                    onUnsupportedFeature,
                    ownerDocument = globalThis.document,
                    styleElement = null
                  } = _ref;
                  if (this.constructor === BaseFontLoader) {
                    (0, _util2.unreachable)("Cannot initialize BaseFontLoader.");
                  }
                  this.docId = docId;
                  this._onUnsupportedFeature = onUnsupportedFeature;
                  this._document = ownerDocument;
                  this.nativeFontFaces = [];
                  this.styleElement = null;
                }
                addNativeFontFace(nativeFontFace) {
                  this.nativeFontFaces.push(nativeFontFace);
                  this._document.fonts.add(nativeFontFace);
                }
                insertRule(rule) {
                  let styleElement = this.styleElement;
                  if (!styleElement) {
                    styleElement = this.styleElement = this._document.createElement("style");
                    styleElement.id = `PDFJS_FONT_STYLE_TAG_${this.docId}`;
                    this._document.documentElement.getElementsByTagName("head")[0].append(styleElement);
                  }
                  const styleSheet = styleElement.sheet;
                  styleSheet.insertRule(rule, styleSheet.cssRules.length);
                }
                clear() {
                  for (const nativeFontFace of this.nativeFontFaces) {
                    this._document.fonts.delete(nativeFontFace);
                  }
                  this.nativeFontFaces.length = 0;
                  if (this.styleElement) {
                    this.styleElement.remove();
                    this.styleElement = null;
                  }
                }
                async bind(font) {
                  if (font.attached || font.missingFile) {
                    return;
                  }
                  font.attached = true;
                  if (this.isFontLoadingAPISupported) {
                    const nativeFontFace = font.createNativeFontFace();
                    if (nativeFontFace) {
                      this.addNativeFontFace(nativeFontFace);
                      try {
                        await nativeFontFace.loaded;
                      } catch (ex) {
                        this._onUnsupportedFeature({
                          featureId: _util2.UNSUPPORTED_FEATURES.errorFontLoadNative
                        });
                        (0, _util2.warn)(`Failed to load font '${nativeFontFace.family}': '${ex}'.`);
                        font.disableFontFace = true;
                        throw ex;
                      }
                    }
                    return;
                  }
                  const rule = font.createFontFaceRule();
                  if (rule) {
                    this.insertRule(rule);
                    if (this.isSyncFontLoadingSupported) {
                      return;
                    }
                    await new Promise((resolve) => {
                      const request = this._queueLoadingCallback(resolve);
                      this._prepareFontLoadEvent([rule], [font], request);
                    });
                  }
                }
                _queueLoadingCallback(callback) {
                  (0, _util2.unreachable)("Abstract method `_queueLoadingCallback`.");
                }
                get isFontLoadingAPISupported() {
                  var _this$_document;
                  const hasFonts = !!((_this$_document = this._document) !== null && _this$_document !== void 0 && _this$_document.fonts);
                  return (0, _util2.shadow)(this, "isFontLoadingAPISupported", hasFonts);
                }
                get isSyncFontLoadingSupported() {
                  (0, _util2.unreachable)("Abstract method `isSyncFontLoadingSupported`.");
                }
                get _loadTestFont() {
                  (0, _util2.unreachable)("Abstract method `_loadTestFont`.");
                }
                _prepareFontLoadEvent(rules, fontsToLoad, request) {
                  (0, _util2.unreachable)("Abstract method `_prepareFontLoadEvent`.");
                }
              }
              let FontLoader;
              exports2.FontLoader = FontLoader;
              {
                exports2.FontLoader = FontLoader = class GenericFontLoader extends BaseFontLoader {
                  constructor(params) {
                    super(params);
                    this.loadingContext = {
                      requests: [],
                      nextRequestId: 0
                    };
                    this.loadTestFontId = 0;
                  }
                  get isSyncFontLoadingSupported() {
                    let supported = false;
                    if (typeof navigator === "undefined") {
                      supported = true;
                    } else {
                      const m = /Mozilla\/5.0.*?rv:(\d+).*? Gecko/.exec(navigator.userAgent);
                      if ((m === null || m === void 0 ? void 0 : m[1]) >= 14) {
                        supported = true;
                      }
                    }
                    return (0, _util2.shadow)(this, "isSyncFontLoadingSupported", supported);
                  }
                  _queueLoadingCallback(callback) {
                    function completeRequest() {
                      (0, _util2.assert)(!request.done, "completeRequest() cannot be called twice.");
                      request.done = true;
                      while (context.requests.length > 0 && context.requests[0].done) {
                        const otherRequest = context.requests.shift();
                        setTimeout(otherRequest.callback, 0);
                      }
                    }
                    const context = this.loadingContext;
                    const request = {
                      id: `pdfjs-font-loading-${context.nextRequestId++}`,
                      done: false,
                      complete: completeRequest,
                      callback
                    };
                    context.requests.push(request);
                    return request;
                  }
                  get _loadTestFont() {
                    const getLoadTestFont = function() {
                      return atob("T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQAFQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAAALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgAAAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACMAooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4DIP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAAAAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUAAQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgABAAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABYAAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAAAC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAAAAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQACAQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTjFQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==");
                    };
                    return (0, _util2.shadow)(this, "_loadTestFont", getLoadTestFont());
                  }
                  _prepareFontLoadEvent(rules, fonts, request) {
                    function int32(data2, offset) {
                      return data2.charCodeAt(offset) << 24 | data2.charCodeAt(offset + 1) << 16 | data2.charCodeAt(offset + 2) << 8 | data2.charCodeAt(offset + 3) & 255;
                    }
                    function spliceString(s, offset, remove, insert) {
                      const chunk1 = s.substring(0, offset);
                      const chunk2 = s.substring(offset + remove);
                      return chunk1 + insert + chunk2;
                    }
                    let i, ii;
                    const canvas = this._document.createElement("canvas");
                    canvas.width = 1;
                    canvas.height = 1;
                    const ctx = canvas.getContext("2d");
                    let called = 0;
                    function isFontReady(name, callback) {
                      called++;
                      if (called > 30) {
                        (0, _util2.warn)("Load test font never loaded.");
                        callback();
                        return;
                      }
                      ctx.font = "30px " + name;
                      ctx.fillText(".", 0, 20);
                      const imageData = ctx.getImageData(0, 0, 1, 1);
                      if (imageData.data[3] > 0) {
                        callback();
                        return;
                      }
                      setTimeout(isFontReady.bind(null, name, callback));
                    }
                    const loadTestFontId = `lt${Date.now()}${this.loadTestFontId++}`;
                    let data = this._loadTestFont;
                    const COMMENT_OFFSET = 976;
                    data = spliceString(data, COMMENT_OFFSET, loadTestFontId.length, loadTestFontId);
                    const CFF_CHECKSUM_OFFSET = 16;
                    const XXXX_VALUE = 1482184792;
                    let checksum = int32(data, CFF_CHECKSUM_OFFSET);
                    for (i = 0, ii = loadTestFontId.length - 3; i < ii; i += 4) {
                      checksum = checksum - XXXX_VALUE + int32(loadTestFontId, i) | 0;
                    }
                    if (i < loadTestFontId.length) {
                      checksum = checksum - XXXX_VALUE + int32(loadTestFontId + "XXX", i) | 0;
                    }
                    data = spliceString(data, CFF_CHECKSUM_OFFSET, 4, (0, _util2.string32)(checksum));
                    const url = `url(data:font/opentype;base64,${btoa(data)});`;
                    const rule = `@font-face {font-family:"${loadTestFontId}";src:${url}}`;
                    this.insertRule(rule);
                    const names = [];
                    for (const font of fonts) {
                      names.push(font.loadedName);
                    }
                    names.push(loadTestFontId);
                    const div = this._document.createElement("div");
                    div.style.visibility = "hidden";
                    div.style.width = div.style.height = "10px";
                    div.style.position = "absolute";
                    div.style.top = div.style.left = "0px";
                    for (const name of names) {
                      const span = this._document.createElement("span");
                      span.textContent = "Hi";
                      span.style.fontFamily = name;
                      div.append(span);
                    }
                    this._document.body.append(div);
                    isFontReady(loadTestFontId, () => {
                      div.remove();
                      request.complete();
                    });
                  }
                };
              }
              class FontFaceObject {
                constructor(translatedData, _ref2) {
                  let {
                    isEvalSupported = true,
                    disableFontFace = false,
                    ignoreErrors = false,
                    onUnsupportedFeature,
                    fontRegistry = null
                  } = _ref2;
                  this.compiledGlyphs = /* @__PURE__ */ Object.create(null);
                  for (const i in translatedData) {
                    this[i] = translatedData[i];
                  }
                  this.isEvalSupported = isEvalSupported !== false;
                  this.disableFontFace = disableFontFace === true;
                  this.ignoreErrors = ignoreErrors === true;
                  this._onUnsupportedFeature = onUnsupportedFeature;
                  this.fontRegistry = fontRegistry;
                }
                createNativeFontFace() {
                  if (!this.data || this.disableFontFace) {
                    return null;
                  }
                  let nativeFontFace;
                  if (!this.cssFontInfo) {
                    nativeFontFace = new FontFace(this.loadedName, this.data, {});
                  } else {
                    const css = {
                      weight: this.cssFontInfo.fontWeight
                    };
                    if (this.cssFontInfo.italicAngle) {
                      css.style = `oblique ${this.cssFontInfo.italicAngle}deg`;
                    }
                    nativeFontFace = new FontFace(this.cssFontInfo.fontFamily, this.data, css);
                  }
                  if (this.fontRegistry) {
                    this.fontRegistry.registerFont(this);
                  }
                  return nativeFontFace;
                }
                createFontFaceRule() {
                  if (!this.data || this.disableFontFace) {
                    return null;
                  }
                  const data = (0, _util2.bytesToString)(this.data);
                  const url = `url(data:${this.mimetype};base64,${btoa(data)});`;
                  let rule;
                  if (!this.cssFontInfo) {
                    rule = `@font-face {font-family:"${this.loadedName}";src:${url}}`;
                  } else {
                    let css = `font-weight: ${this.cssFontInfo.fontWeight};`;
                    if (this.cssFontInfo.italicAngle) {
                      css += `font-style: oblique ${this.cssFontInfo.italicAngle}deg;`;
                    }
                    rule = `@font-face {font-family:"${this.cssFontInfo.fontFamily}";${css}src:${url}}`;
                  }
                  if (this.fontRegistry) {
                    this.fontRegistry.registerFont(this, url);
                  }
                  return rule;
                }
                getPathGenerator(objs, character) {
                  if (this.compiledGlyphs[character] !== void 0) {
                    return this.compiledGlyphs[character];
                  }
                  let cmds;
                  try {
                    cmds = objs.get(this.loadedName + "_path_" + character);
                  } catch (ex) {
                    if (!this.ignoreErrors) {
                      throw ex;
                    }
                    this._onUnsupportedFeature({
                      featureId: _util2.UNSUPPORTED_FEATURES.errorFontGetPath
                    });
                    (0, _util2.warn)(`getPathGenerator - ignoring character: "${ex}".`);
                    return this.compiledGlyphs[character] = function(c, size) {
                    };
                  }
                  if (this.isEvalSupported && _util2.FeatureTest.isEvalSupported) {
                    const jsBuf = [];
                    for (const current of cmds) {
                      const args = current.args !== void 0 ? current.args.join(",") : "";
                      jsBuf.push("c.", current.cmd, "(", args, ");\n");
                    }
                    return this.compiledGlyphs[character] = new Function("c", "size", jsBuf.join(""));
                  }
                  return this.compiledGlyphs[character] = function(c, size) {
                    for (const current of cmds) {
                      if (current.cmd === "scale") {
                        current.args = [size, -size];
                      }
                      c[current.cmd].apply(c, current.args);
                    }
                  };
                }
              }
              exports2.FontFaceObject = FontFaceObject;
            },
            /* 137 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.CanvasGraphics = void 0;
              var _display_utils2 = __w_pdfjs_require__2(133);
              var _util2 = __w_pdfjs_require__2(1);
              var _pattern_helper = __w_pdfjs_require__2(138);
              var _image_utils = __w_pdfjs_require__2(139);
              var _is_node2 = __w_pdfjs_require__2(3);
              function _classPrivateMethodInitSpec2(obj, privateSet) {
                _checkPrivateRedeclaration2(obj, privateSet);
                privateSet.add(obj);
              }
              function _checkPrivateRedeclaration2(obj, privateCollection) {
                if (privateCollection.has(obj)) {
                  throw new TypeError("Cannot initialize the same private elements twice on an object");
                }
              }
              function _classPrivateMethodGet2(receiver, privateSet, fn) {
                if (!privateSet.has(receiver)) {
                  throw new TypeError("attempted to get private field on non-instance");
                }
                return fn;
              }
              const MIN_FONT_SIZE = 16;
              const MAX_FONT_SIZE = 100;
              const MAX_GROUP_SIZE = 4096;
              const EXECUTION_TIME = 15;
              const EXECUTION_STEPS = 10;
              const MAX_SIZE_TO_COMPILE = _is_node2.isNodeJS && typeof Path2D === "undefined" ? -1 : 1e3;
              const FULL_CHUNK_HEIGHT = 16;
              function mirrorContextOperations(ctx, destCtx) {
                if (ctx._removeMirroring) {
                  throw new Error("Context is already forwarding operations.");
                }
                ctx.__originalSave = ctx.save;
                ctx.__originalRestore = ctx.restore;
                ctx.__originalRotate = ctx.rotate;
                ctx.__originalScale = ctx.scale;
                ctx.__originalTranslate = ctx.translate;
                ctx.__originalTransform = ctx.transform;
                ctx.__originalSetTransform = ctx.setTransform;
                ctx.__originalResetTransform = ctx.resetTransform;
                ctx.__originalClip = ctx.clip;
                ctx.__originalMoveTo = ctx.moveTo;
                ctx.__originalLineTo = ctx.lineTo;
                ctx.__originalBezierCurveTo = ctx.bezierCurveTo;
                ctx.__originalRect = ctx.rect;
                ctx.__originalClosePath = ctx.closePath;
                ctx.__originalBeginPath = ctx.beginPath;
                ctx._removeMirroring = () => {
                  ctx.save = ctx.__originalSave;
                  ctx.restore = ctx.__originalRestore;
                  ctx.rotate = ctx.__originalRotate;
                  ctx.scale = ctx.__originalScale;
                  ctx.translate = ctx.__originalTranslate;
                  ctx.transform = ctx.__originalTransform;
                  ctx.setTransform = ctx.__originalSetTransform;
                  ctx.resetTransform = ctx.__originalResetTransform;
                  ctx.clip = ctx.__originalClip;
                  ctx.moveTo = ctx.__originalMoveTo;
                  ctx.lineTo = ctx.__originalLineTo;
                  ctx.bezierCurveTo = ctx.__originalBezierCurveTo;
                  ctx.rect = ctx.__originalRect;
                  ctx.closePath = ctx.__originalClosePath;
                  ctx.beginPath = ctx.__originalBeginPath;
                  delete ctx._removeMirroring;
                };
                ctx.save = function ctxSave() {
                  destCtx.save();
                  this.__originalSave();
                };
                ctx.restore = function ctxRestore() {
                  destCtx.restore();
                  this.__originalRestore();
                };
                ctx.translate = function ctxTranslate(x, y) {
                  destCtx.translate(x, y);
                  this.__originalTranslate(x, y);
                };
                ctx.scale = function ctxScale(x, y) {
                  destCtx.scale(x, y);
                  this.__originalScale(x, y);
                };
                ctx.transform = function ctxTransform(a, b, c, d, e, f) {
                  destCtx.transform(a, b, c, d, e, f);
                  this.__originalTransform(a, b, c, d, e, f);
                };
                ctx.setTransform = function ctxSetTransform(a, b, c, d, e, f) {
                  destCtx.setTransform(a, b, c, d, e, f);
                  this.__originalSetTransform(a, b, c, d, e, f);
                };
                ctx.resetTransform = function ctxResetTransform() {
                  destCtx.resetTransform();
                  this.__originalResetTransform();
                };
                ctx.rotate = function ctxRotate(angle) {
                  destCtx.rotate(angle);
                  this.__originalRotate(angle);
                };
                ctx.clip = function ctxRotate(rule) {
                  destCtx.clip(rule);
                  this.__originalClip(rule);
                };
                ctx.moveTo = function(x, y) {
                  destCtx.moveTo(x, y);
                  this.__originalMoveTo(x, y);
                };
                ctx.lineTo = function(x, y) {
                  destCtx.lineTo(x, y);
                  this.__originalLineTo(x, y);
                };
                ctx.bezierCurveTo = function(cp1x, cp1y, cp2x, cp2y, x, y) {
                  destCtx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
                  this.__originalBezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
                };
                ctx.rect = function(x, y, width, height) {
                  destCtx.rect(x, y, width, height);
                  this.__originalRect(x, y, width, height);
                };
                ctx.closePath = function() {
                  destCtx.closePath();
                  this.__originalClosePath();
                };
                ctx.beginPath = function() {
                  destCtx.beginPath();
                  this.__originalBeginPath();
                };
              }
              class CachedCanvases {
                constructor(canvasFactory) {
                  this.canvasFactory = canvasFactory;
                  this.cache = /* @__PURE__ */ Object.create(null);
                }
                getCanvas(id, width, height) {
                  let canvasEntry;
                  if (this.cache[id] !== void 0) {
                    canvasEntry = this.cache[id];
                    this.canvasFactory.reset(canvasEntry, width, height);
                  } else {
                    canvasEntry = this.canvasFactory.create(width, height);
                    this.cache[id] = canvasEntry;
                  }
                  return canvasEntry;
                }
                delete(id) {
                  delete this.cache[id];
                }
                clear() {
                  for (const id in this.cache) {
                    const canvasEntry = this.cache[id];
                    this.canvasFactory.destroy(canvasEntry);
                    delete this.cache[id];
                  }
                }
              }
              function drawImageAtIntegerCoords(ctx, srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH) {
                const [a, b, c, d, tx, ty] = (0, _display_utils2.getCurrentTransform)(ctx);
                if (b === 0 && c === 0) {
                  const tlX = destX * a + tx;
                  const rTlX = Math.round(tlX);
                  const tlY = destY * d + ty;
                  const rTlY = Math.round(tlY);
                  const brX = (destX + destW) * a + tx;
                  const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;
                  const brY = (destY + destH) * d + ty;
                  const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;
                  ctx.setTransform(Math.sign(a), 0, 0, Math.sign(d), rTlX, rTlY);
                  ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rWidth, rHeight);
                  ctx.setTransform(a, b, c, d, tx, ty);
                  return [rWidth, rHeight];
                }
                if (a === 0 && d === 0) {
                  const tlX = destY * c + tx;
                  const rTlX = Math.round(tlX);
                  const tlY = destX * b + ty;
                  const rTlY = Math.round(tlY);
                  const brX = (destY + destH) * c + tx;
                  const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;
                  const brY = (destX + destW) * b + ty;
                  const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;
                  ctx.setTransform(0, Math.sign(b), Math.sign(c), 0, rTlX, rTlY);
                  ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rHeight, rWidth);
                  ctx.setTransform(a, b, c, d, tx, ty);
                  return [rHeight, rWidth];
                }
                ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH);
                const scaleX = Math.hypot(a, b);
                const scaleY = Math.hypot(c, d);
                return [scaleX * destW, scaleY * destH];
              }
              function compileType3Glyph(imgData) {
                const {
                  width,
                  height
                } = imgData;
                if (width > MAX_SIZE_TO_COMPILE || height > MAX_SIZE_TO_COMPILE) {
                  return null;
                }
                const POINT_TO_PROCESS_LIMIT = 1e3;
                const POINT_TYPES = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]);
                const width1 = width + 1;
                let points = new Uint8Array(width1 * (height + 1));
                let i, j, j0;
                const lineSize = width + 7 & ~7;
                let data = new Uint8Array(lineSize * height), pos = 0;
                for (const elem of imgData.data) {
                  let mask = 128;
                  while (mask > 0) {
                    data[pos++] = elem & mask ? 0 : 255;
                    mask >>= 1;
                  }
                }
                let count = 0;
                pos = 0;
                if (data[pos] !== 0) {
                  points[0] = 1;
                  ++count;
                }
                for (j = 1; j < width; j++) {
                  if (data[pos] !== data[pos + 1]) {
                    points[j] = data[pos] ? 2 : 1;
                    ++count;
                  }
                  pos++;
                }
                if (data[pos] !== 0) {
                  points[j] = 2;
                  ++count;
                }
                for (i = 1; i < height; i++) {
                  pos = i * lineSize;
                  j0 = i * width1;
                  if (data[pos - lineSize] !== data[pos]) {
                    points[j0] = data[pos] ? 1 : 8;
                    ++count;
                  }
                  let sum = (data[pos] ? 4 : 0) + (data[pos - lineSize] ? 8 : 0);
                  for (j = 1; j < width; j++) {
                    sum = (sum >> 2) + (data[pos + 1] ? 4 : 0) + (data[pos - lineSize + 1] ? 8 : 0);
                    if (POINT_TYPES[sum]) {
                      points[j0 + j] = POINT_TYPES[sum];
                      ++count;
                    }
                    pos++;
                  }
                  if (data[pos - lineSize] !== data[pos]) {
                    points[j0 + j] = data[pos] ? 2 : 4;
                    ++count;
                  }
                  if (count > POINT_TO_PROCESS_LIMIT) {
                    return null;
                  }
                }
                pos = lineSize * (height - 1);
                j0 = i * width1;
                if (data[pos] !== 0) {
                  points[j0] = 8;
                  ++count;
                }
                for (j = 1; j < width; j++) {
                  if (data[pos] !== data[pos + 1]) {
                    points[j0 + j] = data[pos] ? 4 : 8;
                    ++count;
                  }
                  pos++;
                }
                if (data[pos] !== 0) {
                  points[j0 + j] = 4;
                  ++count;
                }
                if (count > POINT_TO_PROCESS_LIMIT) {
                  return null;
                }
                const steps = new Int32Array([0, width1, -1, 0, -width1, 0, 0, 0, 1]);
                const path = new Path2D();
                for (i = 0; count && i <= height; i++) {
                  let p = i * width1;
                  const end = p + width;
                  while (p < end && !points[p]) {
                    p++;
                  }
                  if (p === end) {
                    continue;
                  }
                  path.moveTo(p % width1, i);
                  const p0 = p;
                  let type = points[p];
                  do {
                    const step = steps[type];
                    do {
                      p += step;
                    } while (!points[p]);
                    const pp = points[p];
                    if (pp !== 5 && pp !== 10) {
                      type = pp;
                      points[p] = 0;
                    } else {
                      type = pp & 51 * type >> 4;
                      points[p] &= type >> 2 | type << 2;
                    }
                    path.lineTo(p % width1, p / width1 | 0);
                    if (!points[p]) {
                      --count;
                    }
                  } while (p0 !== p);
                  --i;
                }
                data = null;
                points = null;
                const drawOutline = function(c) {
                  c.save();
                  c.scale(1 / width, -1 / height);
                  c.translate(0, -height);
                  c.fill(path);
                  c.beginPath();
                  c.restore();
                };
                return drawOutline;
              }
              class CanvasExtraState {
                constructor(width, height) {
                  this.alphaIsShape = false;
                  this.fontSize = 0;
                  this.fontSizeScale = 1;
                  this.textMatrix = _util2.IDENTITY_MATRIX;
                  this.textMatrixScale = 1;
                  this.fontMatrix = _util2.FONT_IDENTITY_MATRIX;
                  this.leading = 0;
                  this.x = 0;
                  this.y = 0;
                  this.lineX = 0;
                  this.lineY = 0;
                  this.charSpacing = 0;
                  this.wordSpacing = 0;
                  this.textHScale = 1;
                  this.textRenderingMode = _util2.TextRenderingMode.FILL;
                  this.textRise = 0;
                  this.fillColor = "#000000";
                  this.strokeColor = "#000000";
                  this.patternFill = false;
                  this.fillAlpha = 1;
                  this.strokeAlpha = 1;
                  this.lineWidth = 1;
                  this.activeSMask = null;
                  this.transferMaps = null;
                  this.startNewPathAndClipBox([0, 0, width, height]);
                }
                clone() {
                  const clone = Object.create(this);
                  clone.clipBox = this.clipBox.slice();
                  return clone;
                }
                setCurrentPoint(x, y) {
                  this.x = x;
                  this.y = y;
                }
                updatePathMinMax(transform, x, y) {
                  [x, y] = _util2.Util.applyTransform([x, y], transform);
                  this.minX = Math.min(this.minX, x);
                  this.minY = Math.min(this.minY, y);
                  this.maxX = Math.max(this.maxX, x);
                  this.maxY = Math.max(this.maxY, y);
                }
                updateRectMinMax(transform, rect) {
                  const p1 = _util2.Util.applyTransform(rect, transform);
                  const p2 = _util2.Util.applyTransform(rect.slice(2), transform);
                  this.minX = Math.min(this.minX, p1[0], p2[0]);
                  this.minY = Math.min(this.minY, p1[1], p2[1]);
                  this.maxX = Math.max(this.maxX, p1[0], p2[0]);
                  this.maxY = Math.max(this.maxY, p1[1], p2[1]);
                }
                updateScalingPathMinMax(transform, minMax) {
                  _util2.Util.scaleMinMax(transform, minMax);
                  this.minX = Math.min(this.minX, minMax[0]);
                  this.maxX = Math.max(this.maxX, minMax[1]);
                  this.minY = Math.min(this.minY, minMax[2]);
                  this.maxY = Math.max(this.maxY, minMax[3]);
                }
                updateCurvePathMinMax(transform, x0, y0, x1, y1, x2, y2, x3, y3, minMax) {
                  const box = _util2.Util.bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3);
                  if (minMax) {
                    minMax[0] = Math.min(minMax[0], box[0], box[2]);
                    minMax[1] = Math.max(minMax[1], box[0], box[2]);
                    minMax[2] = Math.min(minMax[2], box[1], box[3]);
                    minMax[3] = Math.max(minMax[3], box[1], box[3]);
                    return;
                  }
                  this.updateRectMinMax(transform, box);
                }
                getPathBoundingBox() {
                  let pathType = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : _pattern_helper.PathType.FILL;
                  let transform = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
                  const box = [this.minX, this.minY, this.maxX, this.maxY];
                  if (pathType === _pattern_helper.PathType.STROKE) {
                    if (!transform) {
                      (0, _util2.unreachable)("Stroke bounding box must include transform.");
                    }
                    const scale = _util2.Util.singularValueDecompose2dScale(transform);
                    const xStrokePad = scale[0] * this.lineWidth / 2;
                    const yStrokePad = scale[1] * this.lineWidth / 2;
                    box[0] -= xStrokePad;
                    box[1] -= yStrokePad;
                    box[2] += xStrokePad;
                    box[3] += yStrokePad;
                  }
                  return box;
                }
                updateClipFromPath() {
                  const intersect = _util2.Util.intersect(this.clipBox, this.getPathBoundingBox());
                  this.startNewPathAndClipBox(intersect || [0, 0, 0, 0]);
                }
                isEmptyClip() {
                  return this.minX === Infinity;
                }
                startNewPathAndClipBox(box) {
                  this.clipBox = box;
                  this.minX = Infinity;
                  this.minY = Infinity;
                  this.maxX = 0;
                  this.maxY = 0;
                }
                getClippedPathBoundingBox() {
                  let pathType = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : _pattern_helper.PathType.FILL;
                  let transform = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
                  return _util2.Util.intersect(this.clipBox, this.getPathBoundingBox(pathType, transform));
                }
              }
              function putBinaryImageData(ctx, imgData) {
                let transferMaps = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
                if (typeof ImageData !== "undefined" && imgData instanceof ImageData) {
                  ctx.putImageData(imgData, 0, 0);
                  return;
                }
                const height = imgData.height, width = imgData.width;
                const partialChunkHeight = height % FULL_CHUNK_HEIGHT;
                const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
                const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
                const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
                let srcPos = 0, destPos;
                const src = imgData.data;
                const dest = chunkImgData.data;
                let i, j, thisChunkHeight, elemsInThisChunk;
                let transferMapRed, transferMapGreen, transferMapBlue, transferMapGray;
                if (transferMaps) {
                  switch (transferMaps.length) {
                    case 1:
                      transferMapRed = transferMaps[0];
                      transferMapGreen = transferMaps[0];
                      transferMapBlue = transferMaps[0];
                      transferMapGray = transferMaps[0];
                      break;
                    case 4:
                      transferMapRed = transferMaps[0];
                      transferMapGreen = transferMaps[1];
                      transferMapBlue = transferMaps[2];
                      transferMapGray = transferMaps[3];
                      break;
                  }
                }
                if (imgData.kind === _util2.ImageKind.GRAYSCALE_1BPP) {
                  const srcLength = src.byteLength;
                  const dest32 = new Uint32Array(dest.buffer, 0, dest.byteLength >> 2);
                  const dest32DataLength = dest32.length;
                  const fullSrcDiff = width + 7 >> 3;
                  let white = 4294967295;
                  let black = _util2.FeatureTest.isLittleEndian ? 4278190080 : 255;
                  if (transferMapGray) {
                    if (transferMapGray[0] === 255 && transferMapGray[255] === 0) {
                      [white, black] = [black, white];
                    }
                  }
                  for (i = 0; i < totalChunks; i++) {
                    thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
                    destPos = 0;
                    for (j = 0; j < thisChunkHeight; j++) {
                      const srcDiff = srcLength - srcPos;
                      let k = 0;
                      const kEnd = srcDiff > fullSrcDiff ? width : srcDiff * 8 - 7;
                      const kEndUnrolled = kEnd & ~7;
                      let mask = 0;
                      let srcByte = 0;
                      for (; k < kEndUnrolled; k += 8) {
                        srcByte = src[srcPos++];
                        dest32[destPos++] = srcByte & 128 ? white : black;
                        dest32[destPos++] = srcByte & 64 ? white : black;
                        dest32[destPos++] = srcByte & 32 ? white : black;
                        dest32[destPos++] = srcByte & 16 ? white : black;
                        dest32[destPos++] = srcByte & 8 ? white : black;
                        dest32[destPos++] = srcByte & 4 ? white : black;
                        dest32[destPos++] = srcByte & 2 ? white : black;
                        dest32[destPos++] = srcByte & 1 ? white : black;
                      }
                      for (; k < kEnd; k++) {
                        if (mask === 0) {
                          srcByte = src[srcPos++];
                          mask = 128;
                        }
                        dest32[destPos++] = srcByte & mask ? white : black;
                        mask >>= 1;
                      }
                    }
                    while (destPos < dest32DataLength) {
                      dest32[destPos++] = 0;
                    }
                    ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
                  }
                } else if (imgData.kind === _util2.ImageKind.RGBA_32BPP) {
                  const hasTransferMaps = !!(transferMapRed || transferMapGreen || transferMapBlue);
                  j = 0;
                  elemsInThisChunk = width * FULL_CHUNK_HEIGHT * 4;
                  for (i = 0; i < fullChunks; i++) {
                    dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));
                    srcPos += elemsInThisChunk;
                    if (hasTransferMaps) {
                      for (let k = 0; k < elemsInThisChunk; k += 4) {
                        if (transferMapRed) {
                          dest[k + 0] = transferMapRed[dest[k + 0]];
                        }
                        if (transferMapGreen) {
                          dest[k + 1] = transferMapGreen[dest[k + 1]];
                        }
                        if (transferMapBlue) {
                          dest[k + 2] = transferMapBlue[dest[k + 2]];
                        }
                      }
                    }
                    ctx.putImageData(chunkImgData, 0, j);
                    j += FULL_CHUNK_HEIGHT;
                  }
                  if (i < totalChunks) {
                    elemsInThisChunk = width * partialChunkHeight * 4;
                    dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));
                    if (hasTransferMaps) {
                      for (let k = 0; k < elemsInThisChunk; k += 4) {
                        if (transferMapRed) {
                          dest[k + 0] = transferMapRed[dest[k + 0]];
                        }
                        if (transferMapGreen) {
                          dest[k + 1] = transferMapGreen[dest[k + 1]];
                        }
                        if (transferMapBlue) {
                          dest[k + 2] = transferMapBlue[dest[k + 2]];
                        }
                      }
                    }
                    ctx.putImageData(chunkImgData, 0, j);
                  }
                } else if (imgData.kind === _util2.ImageKind.RGB_24BPP) {
                  const hasTransferMaps = !!(transferMapRed || transferMapGreen || transferMapBlue);
                  thisChunkHeight = FULL_CHUNK_HEIGHT;
                  elemsInThisChunk = width * thisChunkHeight;
                  for (i = 0; i < totalChunks; i++) {
                    if (i >= fullChunks) {
                      thisChunkHeight = partialChunkHeight;
                      elemsInThisChunk = width * thisChunkHeight;
                    }
                    destPos = 0;
                    for (j = elemsInThisChunk; j--; ) {
                      dest[destPos++] = src[srcPos++];
                      dest[destPos++] = src[srcPos++];
                      dest[destPos++] = src[srcPos++];
                      dest[destPos++] = 255;
                    }
                    if (hasTransferMaps) {
                      for (let k = 0; k < destPos; k += 4) {
                        if (transferMapRed) {
                          dest[k + 0] = transferMapRed[dest[k + 0]];
                        }
                        if (transferMapGreen) {
                          dest[k + 1] = transferMapGreen[dest[k + 1]];
                        }
                        if (transferMapBlue) {
                          dest[k + 2] = transferMapBlue[dest[k + 2]];
                        }
                      }
                    }
                    ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
                  }
                } else {
                  throw new Error(`bad image kind: ${imgData.kind}`);
                }
              }
              function putBinaryImageMask(ctx, imgData) {
                if (imgData.bitmap) {
                  ctx.drawImage(imgData.bitmap, 0, 0);
                  return;
                }
                const height = imgData.height, width = imgData.width;
                const partialChunkHeight = height % FULL_CHUNK_HEIGHT;
                const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
                const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
                const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
                let srcPos = 0;
                const src = imgData.data;
                const dest = chunkImgData.data;
                for (let i = 0; i < totalChunks; i++) {
                  const thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
                  ({
                    srcPos
                  } = (0, _image_utils.applyMaskImageData)({
                    src,
                    srcPos,
                    dest,
                    width,
                    height: thisChunkHeight
                  }));
                  ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
                }
              }
              function copyCtxState(sourceCtx, destCtx) {
                const properties = ["strokeStyle", "fillStyle", "fillRule", "globalAlpha", "lineWidth", "lineCap", "lineJoin", "miterLimit", "globalCompositeOperation", "font"];
                for (let i = 0, ii = properties.length; i < ii; i++) {
                  const property = properties[i];
                  if (sourceCtx[property] !== void 0) {
                    destCtx[property] = sourceCtx[property];
                  }
                }
                if (sourceCtx.setLineDash !== void 0) {
                  destCtx.setLineDash(sourceCtx.getLineDash());
                  destCtx.lineDashOffset = sourceCtx.lineDashOffset;
                }
              }
              function resetCtxToDefault(ctx, foregroundColor) {
                ctx.strokeStyle = ctx.fillStyle = foregroundColor || "#000000";
                ctx.fillRule = "nonzero";
                ctx.globalAlpha = 1;
                ctx.lineWidth = 1;
                ctx.lineCap = "butt";
                ctx.lineJoin = "miter";
                ctx.miterLimit = 10;
                ctx.globalCompositeOperation = "source-over";
                ctx.font = "10px sans-serif";
                if (ctx.setLineDash !== void 0) {
                  ctx.setLineDash([]);
                  ctx.lineDashOffset = 0;
                }
              }
              function composeSMaskBackdrop(bytes, r0, g0, b0) {
                const length = bytes.length;
                for (let i = 3; i < length; i += 4) {
                  const alpha = bytes[i];
                  if (alpha === 0) {
                    bytes[i - 3] = r0;
                    bytes[i - 2] = g0;
                    bytes[i - 1] = b0;
                  } else if (alpha < 255) {
                    const alpha_ = 255 - alpha;
                    bytes[i - 3] = bytes[i - 3] * alpha + r0 * alpha_ >> 8;
                    bytes[i - 2] = bytes[i - 2] * alpha + g0 * alpha_ >> 8;
                    bytes[i - 1] = bytes[i - 1] * alpha + b0 * alpha_ >> 8;
                  }
                }
              }
              function composeSMaskAlpha(maskData, layerData, transferMap) {
                const length = maskData.length;
                const scale = 1 / 255;
                for (let i = 3; i < length; i += 4) {
                  const alpha = transferMap ? transferMap[maskData[i]] : maskData[i];
                  layerData[i] = layerData[i] * alpha * scale | 0;
                }
              }
              function composeSMaskLuminosity(maskData, layerData, transferMap) {
                const length = maskData.length;
                for (let i = 3; i < length; i += 4) {
                  const y = maskData[i - 3] * 77 + maskData[i - 2] * 152 + maskData[i - 1] * 28;
                  layerData[i] = transferMap ? layerData[i] * transferMap[y >> 8] >> 8 : layerData[i] * y >> 16;
                }
              }
              function genericComposeSMask(maskCtx, layerCtx, width, height, subtype, backdrop, transferMap, layerOffsetX, layerOffsetY, maskOffsetX, maskOffsetY) {
                const hasBackdrop = !!backdrop;
                const r0 = hasBackdrop ? backdrop[0] : 0;
                const g0 = hasBackdrop ? backdrop[1] : 0;
                const b0 = hasBackdrop ? backdrop[2] : 0;
                let composeFn;
                if (subtype === "Luminosity") {
                  composeFn = composeSMaskLuminosity;
                } else {
                  composeFn = composeSMaskAlpha;
                }
                const PIXELS_TO_PROCESS = 1048576;
                const chunkSize = Math.min(height, Math.ceil(PIXELS_TO_PROCESS / width));
                for (let row = 0; row < height; row += chunkSize) {
                  const chunkHeight = Math.min(chunkSize, height - row);
                  const maskData = maskCtx.getImageData(layerOffsetX - maskOffsetX, row + (layerOffsetY - maskOffsetY), width, chunkHeight);
                  const layerData = layerCtx.getImageData(layerOffsetX, row + layerOffsetY, width, chunkHeight);
                  if (hasBackdrop) {
                    composeSMaskBackdrop(maskData.data, r0, g0, b0);
                  }
                  composeFn(maskData.data, layerData.data, transferMap);
                  layerCtx.putImageData(layerData, layerOffsetX, row + layerOffsetY);
                }
              }
              function composeSMask(ctx, smask, layerCtx, layerBox) {
                const layerOffsetX = layerBox[0];
                const layerOffsetY = layerBox[1];
                const layerWidth = layerBox[2] - layerOffsetX;
                const layerHeight = layerBox[3] - layerOffsetY;
                if (layerWidth === 0 || layerHeight === 0) {
                  return;
                }
                genericComposeSMask(smask.context, layerCtx, layerWidth, layerHeight, smask.subtype, smask.backdrop, smask.transferMap, layerOffsetX, layerOffsetY, smask.offsetX, smask.offsetY);
                ctx.save();
                ctx.globalAlpha = 1;
                ctx.globalCompositeOperation = "source-over";
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.drawImage(layerCtx.canvas, 0, 0);
                ctx.restore();
              }
              function getImageSmoothingEnabled(transform, interpolate) {
                const scale = _util2.Util.singularValueDecompose2dScale(transform);
                scale[0] = Math.fround(scale[0]);
                scale[1] = Math.fround(scale[1]);
                const actualScale = Math.fround((globalThis.devicePixelRatio || 1) * _display_utils2.PixelsPerInch.PDF_TO_CSS_UNITS);
                if (interpolate !== void 0) {
                  return interpolate;
                } else if (scale[0] <= actualScale || scale[1] <= actualScale) {
                  return true;
                }
                return false;
              }
              const LINE_CAP_STYLES = ["butt", "round", "square"];
              const LINE_JOIN_STYLES = ["miter", "round", "bevel"];
              const NORMAL_CLIP = {};
              const EO_CLIP = {};
              var _restoreInitialState = /* @__PURE__ */ new WeakSet();
              class CanvasGraphics {
                constructor(canvasCtx, commonObjs, objs, canvasFactory, imageLayer, optionalContentConfig, annotationCanvasMap, pageColors) {
                  _classPrivateMethodInitSpec2(this, _restoreInitialState);
                  this.ctx = canvasCtx;
                  this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);
                  this.stateStack = [];
                  this.pendingClip = null;
                  this.pendingEOFill = false;
                  this.res = null;
                  this.xobjs = null;
                  this.commonObjs = commonObjs;
                  this.objs = objs;
                  this.canvasFactory = canvasFactory;
                  this.imageLayer = imageLayer;
                  this.groupStack = [];
                  this.processingType3 = null;
                  this.baseTransform = null;
                  this.baseTransformStack = [];
                  this.groupLevel = 0;
                  this.smaskStack = [];
                  this.smaskCounter = 0;
                  this.tempSMask = null;
                  this.suspendedCtx = null;
                  this.contentVisible = true;
                  this.markedContentStack = [];
                  this.optionalContentConfig = optionalContentConfig;
                  this.cachedCanvases = new CachedCanvases(this.canvasFactory);
                  this.cachedPatterns = /* @__PURE__ */ new Map();
                  this.annotationCanvasMap = annotationCanvasMap;
                  this.viewportScale = 1;
                  this.outputScaleX = 1;
                  this.outputScaleY = 1;
                  this.backgroundColor = (pageColors === null || pageColors === void 0 ? void 0 : pageColors.background) || null;
                  this.foregroundColor = (pageColors === null || pageColors === void 0 ? void 0 : pageColors.foreground) || null;
                  this._cachedScaleForStroking = null;
                  this._cachedGetSinglePixelWidth = null;
                  this._cachedBitmapsMap = /* @__PURE__ */ new Map();
                }
                getObject(data) {
                  let fallback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
                  if (typeof data === "string") {
                    return data.startsWith("g_") ? this.commonObjs.get(data) : this.objs.get(data);
                  }
                  return fallback;
                }
                beginDrawing(_ref) {
                  let {
                    transform,
                    viewport,
                    transparency = false,
                    background = null
                  } = _ref;
                  const width = this.ctx.canvas.width;
                  const height = this.ctx.canvas.height;
                  const defaultBackgroundColor = background || "#ffffff";
                  this.ctx.save();
                  if (this.foregroundColor && this.backgroundColor) {
                    this.ctx.fillStyle = this.foregroundColor;
                    const fg = this.foregroundColor = this.ctx.fillStyle;
                    this.ctx.fillStyle = this.backgroundColor;
                    const bg = this.backgroundColor = this.ctx.fillStyle;
                    let isValidDefaultBg = true;
                    let defaultBg = defaultBackgroundColor;
                    this.ctx.fillStyle = defaultBackgroundColor;
                    defaultBg = this.ctx.fillStyle;
                    isValidDefaultBg = typeof defaultBg === "string" && /^#[0-9A-Fa-f]{6}$/.test(defaultBg);
                    if (fg === "#000000" && bg === "#ffffff" || fg === bg || !isValidDefaultBg) {
                      this.foregroundColor = this.backgroundColor = null;
                    } else {
                      const [rB, gB, bB] = (0, _display_utils2.getRGB)(defaultBg);
                      const newComp = (x) => {
                        x /= 255;
                        return x <= 0.03928 ? x / 12.92 : ((x + 0.055) / 1.055) ** 2.4;
                      };
                      const lumB = Math.round(0.2126 * newComp(rB) + 0.7152 * newComp(gB) + 0.0722 * newComp(bB));
                      this.selectColor = (r2, g, b) => {
                        const lumC = 0.2126 * newComp(r2) + 0.7152 * newComp(g) + 0.0722 * newComp(b);
                        return Math.round(lumC) === lumB ? bg : fg;
                      };
                    }
                  }
                  this.ctx.fillStyle = this.backgroundColor || defaultBackgroundColor;
                  this.ctx.fillRect(0, 0, width, height);
                  this.ctx.restore();
                  if (transparency) {
                    const transparentCanvas = this.cachedCanvases.getCanvas("transparent", width, height);
                    this.compositeCtx = this.ctx;
                    this.transparentCanvas = transparentCanvas.canvas;
                    this.ctx = transparentCanvas.context;
                    this.ctx.save();
                    this.ctx.transform(...(0, _display_utils2.getCurrentTransform)(this.compositeCtx));
                  }
                  this.ctx.save();
                  resetCtxToDefault(this.ctx, this.foregroundColor);
                  if (transform) {
                    this.ctx.transform(...transform);
                    this.outputScaleX = transform[0];
                    this.outputScaleY = transform[0];
                  }
                  this.ctx.transform(...viewport.transform);
                  this.viewportScale = viewport.scale;
                  this.baseTransform = (0, _display_utils2.getCurrentTransform)(this.ctx);
                  if (this.imageLayer) {
                    (0, _display_utils2.deprecated)("The `imageLayer` functionality will be removed in the future.");
                    this.imageLayer.beginLayout();
                  }
                }
                executeOperatorList(operatorList, executionStartIdx, continueCallback, stepper) {
                  const argsArray = operatorList.argsArray;
                  const fnArray = operatorList.fnArray;
                  let i = executionStartIdx || 0;
                  const argsArrayLen = argsArray.length;
                  if (argsArrayLen === i) {
                    return i;
                  }
                  const chunkOperations = argsArrayLen - i > EXECUTION_STEPS && typeof continueCallback === "function";
                  const endTime = chunkOperations ? Date.now() + EXECUTION_TIME : 0;
                  let steps = 0;
                  const commonObjs = this.commonObjs;
                  const objs = this.objs;
                  let fnId;
                  while (true) {
                    if (stepper !== void 0 && i === stepper.nextBreakPoint) {
                      stepper.breakIt(i, continueCallback);
                      return i;
                    }
                    fnId = fnArray[i];
                    if (fnId !== _util2.OPS.dependency) {
                      this[fnId].apply(this, argsArray[i]);
                    } else {
                      for (const depObjId of argsArray[i]) {
                        const objsPool = depObjId.startsWith("g_") ? commonObjs : objs;
                        if (!objsPool.has(depObjId)) {
                          objsPool.get(depObjId, continueCallback);
                          return i;
                        }
                      }
                    }
                    i++;
                    if (i === argsArrayLen) {
                      return i;
                    }
                    if (chunkOperations && ++steps > EXECUTION_STEPS) {
                      if (Date.now() > endTime) {
                        continueCallback();
                        return i;
                      }
                      steps = 0;
                    }
                  }
                }
                endDrawing() {
                  _classPrivateMethodGet2(this, _restoreInitialState, _restoreInitialState2).call(this);
                  this.cachedCanvases.clear();
                  this.cachedPatterns.clear();
                  for (const cache of this._cachedBitmapsMap.values()) {
                    for (const canvas of cache.values()) {
                      if (typeof HTMLCanvasElement !== "undefined" && canvas instanceof HTMLCanvasElement) {
                        canvas.width = canvas.height = 0;
                      }
                    }
                    cache.clear();
                  }
                  this._cachedBitmapsMap.clear();
                  if (this.imageLayer) {
                    this.imageLayer.endLayout();
                  }
                }
                _scaleImage(img, inverseTransform) {
                  const width = img.width;
                  const height = img.height;
                  let widthScale = Math.max(Math.hypot(inverseTransform[0], inverseTransform[1]), 1);
                  let heightScale = Math.max(Math.hypot(inverseTransform[2], inverseTransform[3]), 1);
                  let paintWidth = width, paintHeight = height;
                  let tmpCanvasId = "prescale1";
                  let tmpCanvas, tmpCtx;
                  while (widthScale > 2 && paintWidth > 1 || heightScale > 2 && paintHeight > 1) {
                    let newWidth = paintWidth, newHeight = paintHeight;
                    if (widthScale > 2 && paintWidth > 1) {
                      newWidth = Math.ceil(paintWidth / 2);
                      widthScale /= paintWidth / newWidth;
                    }
                    if (heightScale > 2 && paintHeight > 1) {
                      newHeight = Math.ceil(paintHeight / 2);
                      heightScale /= paintHeight / newHeight;
                    }
                    tmpCanvas = this.cachedCanvases.getCanvas(tmpCanvasId, newWidth, newHeight);
                    tmpCtx = tmpCanvas.context;
                    tmpCtx.clearRect(0, 0, newWidth, newHeight);
                    tmpCtx.drawImage(img, 0, 0, paintWidth, paintHeight, 0, 0, newWidth, newHeight);
                    img = tmpCanvas.canvas;
                    paintWidth = newWidth;
                    paintHeight = newHeight;
                    tmpCanvasId = tmpCanvasId === "prescale1" ? "prescale2" : "prescale1";
                  }
                  return {
                    img,
                    paintWidth,
                    paintHeight
                  };
                }
                _createMaskCanvas(img) {
                  const ctx = this.ctx;
                  const {
                    width,
                    height
                  } = img;
                  const fillColor = this.current.fillColor;
                  const isPatternFill = this.current.patternFill;
                  const currentTransform = (0, _display_utils2.getCurrentTransform)(ctx);
                  let cache, cacheKey, scaled, maskCanvas;
                  if ((img.bitmap || img.data) && img.count > 1) {
                    const mainKey = img.bitmap || img.data.buffer;
                    const withoutTranslation = currentTransform.slice(0, 4);
                    cacheKey = JSON.stringify(isPatternFill ? withoutTranslation : [withoutTranslation, fillColor]);
                    cache = this._cachedBitmapsMap.get(mainKey);
                    if (!cache) {
                      cache = /* @__PURE__ */ new Map();
                      this._cachedBitmapsMap.set(mainKey, cache);
                    }
                    const cachedImage = cache.get(cacheKey);
                    if (cachedImage && !isPatternFill) {
                      const offsetX2 = Math.round(Math.min(currentTransform[0], currentTransform[2]) + currentTransform[4]);
                      const offsetY2 = Math.round(Math.min(currentTransform[1], currentTransform[3]) + currentTransform[5]);
                      return {
                        canvas: cachedImage,
                        offsetX: offsetX2,
                        offsetY: offsetY2
                      };
                    }
                    scaled = cachedImage;
                  }
                  if (!scaled) {
                    maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height);
                    putBinaryImageMask(maskCanvas.context, img);
                  }
                  let maskToCanvas = _util2.Util.transform(currentTransform, [1 / width, 0, 0, -1 / height, 0, 0]);
                  maskToCanvas = _util2.Util.transform(maskToCanvas, [1, 0, 0, 1, 0, -height]);
                  const cord1 = _util2.Util.applyTransform([0, 0], maskToCanvas);
                  const cord2 = _util2.Util.applyTransform([width, height], maskToCanvas);
                  const rect = _util2.Util.normalizeRect([cord1[0], cord1[1], cord2[0], cord2[1]]);
                  const drawnWidth = Math.round(rect[2] - rect[0]) || 1;
                  const drawnHeight = Math.round(rect[3] - rect[1]) || 1;
                  const fillCanvas = this.cachedCanvases.getCanvas("fillCanvas", drawnWidth, drawnHeight);
                  const fillCtx = fillCanvas.context;
                  const offsetX = Math.min(cord1[0], cord2[0]);
                  const offsetY = Math.min(cord1[1], cord2[1]);
                  fillCtx.translate(-offsetX, -offsetY);
                  fillCtx.transform(...maskToCanvas);
                  if (!scaled) {
                    scaled = this._scaleImage(maskCanvas.canvas, (0, _display_utils2.getCurrentTransformInverse)(fillCtx));
                    scaled = scaled.img;
                    if (cache && isPatternFill) {
                      cache.set(cacheKey, scaled);
                    }
                  }
                  fillCtx.imageSmoothingEnabled = getImageSmoothingEnabled((0, _display_utils2.getCurrentTransform)(fillCtx), img.interpolate);
                  drawImageAtIntegerCoords(fillCtx, scaled, 0, 0, scaled.width, scaled.height, 0, 0, width, height);
                  fillCtx.globalCompositeOperation = "source-in";
                  const inverse = _util2.Util.transform((0, _display_utils2.getCurrentTransformInverse)(fillCtx), [1, 0, 0, 1, -offsetX, -offsetY]);
                  fillCtx.fillStyle = isPatternFill ? fillColor.getPattern(ctx, this, inverse, _pattern_helper.PathType.FILL) : fillColor;
                  fillCtx.fillRect(0, 0, width, height);
                  if (cache && !isPatternFill) {
                    this.cachedCanvases.delete("fillCanvas");
                    cache.set(cacheKey, fillCanvas.canvas);
                  }
                  return {
                    canvas: fillCanvas.canvas,
                    offsetX: Math.round(offsetX),
                    offsetY: Math.round(offsetY)
                  };
                }
                setLineWidth(width) {
                  if (width !== this.current.lineWidth) {
                    this._cachedScaleForStroking = null;
                  }
                  this.current.lineWidth = width;
                  this.ctx.lineWidth = width;
                }
                setLineCap(style) {
                  this.ctx.lineCap = LINE_CAP_STYLES[style];
                }
                setLineJoin(style) {
                  this.ctx.lineJoin = LINE_JOIN_STYLES[style];
                }
                setMiterLimit(limit) {
                  this.ctx.miterLimit = limit;
                }
                setDash(dashArray, dashPhase) {
                  const ctx = this.ctx;
                  if (ctx.setLineDash !== void 0) {
                    ctx.setLineDash(dashArray);
                    ctx.lineDashOffset = dashPhase;
                  }
                }
                setRenderingIntent(intent) {
                }
                setFlatness(flatness) {
                }
                setGState(states) {
                  for (let i = 0, ii = states.length; i < ii; i++) {
                    const state = states[i];
                    const key = state[0];
                    const value = state[1];
                    switch (key) {
                      case "LW":
                        this.setLineWidth(value);
                        break;
                      case "LC":
                        this.setLineCap(value);
                        break;
                      case "LJ":
                        this.setLineJoin(value);
                        break;
                      case "ML":
                        this.setMiterLimit(value);
                        break;
                      case "D":
                        this.setDash(value[0], value[1]);
                        break;
                      case "RI":
                        this.setRenderingIntent(value);
                        break;
                      case "FL":
                        this.setFlatness(value);
                        break;
                      case "Font":
                        this.setFont(value[0], value[1]);
                        break;
                      case "CA":
                        this.current.strokeAlpha = state[1];
                        break;
                      case "ca":
                        this.current.fillAlpha = state[1];
                        this.ctx.globalAlpha = state[1];
                        break;
                      case "BM":
                        this.ctx.globalCompositeOperation = value;
                        break;
                      case "SMask":
                        this.current.activeSMask = value ? this.tempSMask : null;
                        this.tempSMask = null;
                        this.checkSMaskState();
                        break;
                      case "TR":
                        this.current.transferMaps = value;
                    }
                  }
                }
                get inSMaskMode() {
                  return !!this.suspendedCtx;
                }
                checkSMaskState() {
                  const inSMaskMode = this.inSMaskMode;
                  if (this.current.activeSMask && !inSMaskMode) {
                    this.beginSMaskMode();
                  } else if (!this.current.activeSMask && inSMaskMode) {
                    this.endSMaskMode();
                  }
                }
                beginSMaskMode() {
                  if (this.inSMaskMode) {
                    throw new Error("beginSMaskMode called while already in smask mode");
                  }
                  const drawnWidth = this.ctx.canvas.width;
                  const drawnHeight = this.ctx.canvas.height;
                  const cacheId = "smaskGroupAt" + this.groupLevel;
                  const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight);
                  this.suspendedCtx = this.ctx;
                  this.ctx = scratchCanvas.context;
                  const ctx = this.ctx;
                  ctx.setTransform(...(0, _display_utils2.getCurrentTransform)(this.suspendedCtx));
                  copyCtxState(this.suspendedCtx, ctx);
                  mirrorContextOperations(ctx, this.suspendedCtx);
                  this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]);
                }
                endSMaskMode() {
                  if (!this.inSMaskMode) {
                    throw new Error("endSMaskMode called while not in smask mode");
                  }
                  this.ctx._removeMirroring();
                  copyCtxState(this.ctx, this.suspendedCtx);
                  this.ctx = this.suspendedCtx;
                  this.suspendedCtx = null;
                }
                compose(dirtyBox) {
                  if (!this.current.activeSMask) {
                    return;
                  }
                  if (!dirtyBox) {
                    dirtyBox = [0, 0, this.ctx.canvas.width, this.ctx.canvas.height];
                  } else {
                    dirtyBox[0] = Math.floor(dirtyBox[0]);
                    dirtyBox[1] = Math.floor(dirtyBox[1]);
                    dirtyBox[2] = Math.ceil(dirtyBox[2]);
                    dirtyBox[3] = Math.ceil(dirtyBox[3]);
                  }
                  const smask = this.current.activeSMask;
                  const suspendedCtx = this.suspendedCtx;
                  composeSMask(suspendedCtx, smask, this.ctx, dirtyBox);
                  this.ctx.save();
                  this.ctx.setTransform(1, 0, 0, 1, 0, 0);
                  this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);
                  this.ctx.restore();
                }
                save() {
                  if (this.inSMaskMode) {
                    copyCtxState(this.ctx, this.suspendedCtx);
                    this.suspendedCtx.save();
                  } else {
                    this.ctx.save();
                  }
                  const old = this.current;
                  this.stateStack.push(old);
                  this.current = old.clone();
                }
                restore() {
                  if (this.stateStack.length === 0 && this.inSMaskMode) {
                    this.endSMaskMode();
                  }
                  if (this.stateStack.length !== 0) {
                    this.current = this.stateStack.pop();
                    if (this.inSMaskMode) {
                      this.suspendedCtx.restore();
                      copyCtxState(this.suspendedCtx, this.ctx);
                    } else {
                      this.ctx.restore();
                    }
                    this.checkSMaskState();
                    this.pendingClip = null;
                    this._cachedScaleForStroking = null;
                    this._cachedGetSinglePixelWidth = null;
                  }
                }
                transform(a, b, c, d, e, f) {
                  this.ctx.transform(a, b, c, d, e, f);
                  this._cachedScaleForStroking = null;
                  this._cachedGetSinglePixelWidth = null;
                }
                constructPath(ops, args, minMax) {
                  const ctx = this.ctx;
                  const current = this.current;
                  let x = current.x, y = current.y;
                  let startX, startY;
                  const currentTransform = (0, _display_utils2.getCurrentTransform)(ctx);
                  const isScalingMatrix = currentTransform[0] === 0 && currentTransform[3] === 0 || currentTransform[1] === 0 && currentTransform[2] === 0;
                  const minMaxForBezier = isScalingMatrix ? minMax.slice(0) : null;
                  for (let i = 0, j = 0, ii = ops.length; i < ii; i++) {
                    switch (ops[i] | 0) {
                      case _util2.OPS.rectangle:
                        x = args[j++];
                        y = args[j++];
                        const width = args[j++];
                        const height = args[j++];
                        const xw = x + width;
                        const yh = y + height;
                        ctx.moveTo(x, y);
                        if (width === 0 || height === 0) {
                          ctx.lineTo(xw, yh);
                        } else {
                          ctx.lineTo(xw, y);
                          ctx.lineTo(xw, yh);
                          ctx.lineTo(x, yh);
                        }
                        if (!isScalingMatrix) {
                          current.updateRectMinMax(currentTransform, [x, y, xw, yh]);
                        }
                        ctx.closePath();
                        break;
                      case _util2.OPS.moveTo:
                        x = args[j++];
                        y = args[j++];
                        ctx.moveTo(x, y);
                        if (!isScalingMatrix) {
                          current.updatePathMinMax(currentTransform, x, y);
                        }
                        break;
                      case _util2.OPS.lineTo:
                        x = args[j++];
                        y = args[j++];
                        ctx.lineTo(x, y);
                        if (!isScalingMatrix) {
                          current.updatePathMinMax(currentTransform, x, y);
                        }
                        break;
                      case _util2.OPS.curveTo:
                        startX = x;
                        startY = y;
                        x = args[j + 4];
                        y = args[j + 5];
                        ctx.bezierCurveTo(args[j], args[j + 1], args[j + 2], args[j + 3], x, y);
                        current.updateCurvePathMinMax(currentTransform, startX, startY, args[j], args[j + 1], args[j + 2], args[j + 3], x, y, minMaxForBezier);
                        j += 6;
                        break;
                      case _util2.OPS.curveTo2:
                        startX = x;
                        startY = y;
                        ctx.bezierCurveTo(x, y, args[j], args[j + 1], args[j + 2], args[j + 3]);
                        current.updateCurvePathMinMax(currentTransform, startX, startY, x, y, args[j], args[j + 1], args[j + 2], args[j + 3], minMaxForBezier);
                        x = args[j + 2];
                        y = args[j + 3];
                        j += 4;
                        break;
                      case _util2.OPS.curveTo3:
                        startX = x;
                        startY = y;
                        x = args[j + 2];
                        y = args[j + 3];
                        ctx.bezierCurveTo(args[j], args[j + 1], x, y, x, y);
                        current.updateCurvePathMinMax(currentTransform, startX, startY, args[j], args[j + 1], x, y, x, y, minMaxForBezier);
                        j += 4;
                        break;
                      case _util2.OPS.closePath:
                        ctx.closePath();
                        break;
                    }
                  }
                  if (isScalingMatrix) {
                    current.updateScalingPathMinMax(currentTransform, minMaxForBezier);
                  }
                  current.setCurrentPoint(x, y);
                }
                closePath() {
                  this.ctx.closePath();
                }
                stroke(consumePath) {
                  consumePath = typeof consumePath !== "undefined" ? consumePath : true;
                  const ctx = this.ctx;
                  const strokeColor = this.current.strokeColor;
                  ctx.globalAlpha = this.current.strokeAlpha;
                  if (this.contentVisible) {
                    if (typeof strokeColor === "object" && strokeColor !== null && strokeColor !== void 0 && strokeColor.getPattern) {
                      ctx.save();
                      ctx.strokeStyle = strokeColor.getPattern(ctx, this, (0, _display_utils2.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.STROKE);
                      this.rescaleAndStroke(false);
                      ctx.restore();
                    } else {
                      this.rescaleAndStroke(true);
                    }
                  }
                  if (consumePath) {
                    this.consumePath(this.current.getClippedPathBoundingBox());
                  }
                  ctx.globalAlpha = this.current.fillAlpha;
                }
                closeStroke() {
                  this.closePath();
                  this.stroke();
                }
                fill(consumePath) {
                  consumePath = typeof consumePath !== "undefined" ? consumePath : true;
                  const ctx = this.ctx;
                  const fillColor = this.current.fillColor;
                  const isPatternFill = this.current.patternFill;
                  let needRestore = false;
                  if (isPatternFill) {
                    ctx.save();
                    ctx.fillStyle = fillColor.getPattern(ctx, this, (0, _display_utils2.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.FILL);
                    needRestore = true;
                  }
                  const intersect = this.current.getClippedPathBoundingBox();
                  if (this.contentVisible && intersect !== null) {
                    if (this.pendingEOFill) {
                      ctx.fill("evenodd");
                      this.pendingEOFill = false;
                    } else {
                      ctx.fill();
                    }
                  }
                  if (needRestore) {
                    ctx.restore();
                  }
                  if (consumePath) {
                    this.consumePath(intersect);
                  }
                }
                eoFill() {
                  this.pendingEOFill = true;
                  this.fill();
                }
                fillStroke() {
                  this.fill(false);
                  this.stroke(false);
                  this.consumePath();
                }
                eoFillStroke() {
                  this.pendingEOFill = true;
                  this.fillStroke();
                }
                closeFillStroke() {
                  this.closePath();
                  this.fillStroke();
                }
                closeEOFillStroke() {
                  this.pendingEOFill = true;
                  this.closePath();
                  this.fillStroke();
                }
                endPath() {
                  this.consumePath();
                }
                clip() {
                  this.pendingClip = NORMAL_CLIP;
                }
                eoClip() {
                  this.pendingClip = EO_CLIP;
                }
                beginText() {
                  this.current.textMatrix = _util2.IDENTITY_MATRIX;
                  this.current.textMatrixScale = 1;
                  this.current.x = this.current.lineX = 0;
                  this.current.y = this.current.lineY = 0;
                }
                endText() {
                  const paths = this.pendingTextPaths;
                  const ctx = this.ctx;
                  if (paths === void 0) {
                    ctx.beginPath();
                    return;
                  }
                  ctx.save();
                  ctx.beginPath();
                  for (const path of paths) {
                    ctx.setTransform(...path.transform);
                    ctx.translate(path.x, path.y);
                    path.addToPath(ctx, path.fontSize);
                  }
                  ctx.restore();
                  ctx.clip();
                  ctx.beginPath();
                  delete this.pendingTextPaths;
                }
                setCharSpacing(spacing) {
                  this.current.charSpacing = spacing;
                }
                setWordSpacing(spacing) {
                  this.current.wordSpacing = spacing;
                }
                setHScale(scale) {
                  this.current.textHScale = scale / 100;
                }
                setLeading(leading) {
                  this.current.leading = -leading;
                }
                setFont(fontRefName, size) {
                  const fontObj = this.commonObjs.get(fontRefName);
                  const current = this.current;
                  if (!fontObj) {
                    throw new Error(`Can't find font for ${fontRefName}`);
                  }
                  current.fontMatrix = fontObj.fontMatrix || _util2.FONT_IDENTITY_MATRIX;
                  if (current.fontMatrix[0] === 0 || current.fontMatrix[3] === 0) {
                    (0, _util2.warn)("Invalid font matrix for font " + fontRefName);
                  }
                  if (size < 0) {
                    size = -size;
                    current.fontDirection = -1;
                  } else {
                    current.fontDirection = 1;
                  }
                  this.current.font = fontObj;
                  this.current.fontSize = size;
                  if (fontObj.isType3Font) {
                    return;
                  }
                  const name = fontObj.loadedName || "sans-serif";
                  let bold = "normal";
                  if (fontObj.black) {
                    bold = "900";
                  } else if (fontObj.bold) {
                    bold = "bold";
                  }
                  const italic = fontObj.italic ? "italic" : "normal";
                  const typeface = `"${name}", ${fontObj.fallbackName}`;
                  let browserFontSize = size;
                  if (size < MIN_FONT_SIZE) {
                    browserFontSize = MIN_FONT_SIZE;
                  } else if (size > MAX_FONT_SIZE) {
                    browserFontSize = MAX_FONT_SIZE;
                  }
                  this.current.fontSizeScale = size / browserFontSize;
                  this.ctx.font = `${italic} ${bold} ${browserFontSize}px ${typeface}`;
                }
                setTextRenderingMode(mode) {
                  this.current.textRenderingMode = mode;
                }
                setTextRise(rise) {
                  this.current.textRise = rise;
                }
                moveText(x, y) {
                  this.current.x = this.current.lineX += x;
                  this.current.y = this.current.lineY += y;
                }
                setLeadingMoveText(x, y) {
                  this.setLeading(-y);
                  this.moveText(x, y);
                }
                setTextMatrix(a, b, c, d, e, f) {
                  this.current.textMatrix = [a, b, c, d, e, f];
                  this.current.textMatrixScale = Math.hypot(a, b);
                  this.current.x = this.current.lineX = 0;
                  this.current.y = this.current.lineY = 0;
                }
                nextLine() {
                  this.moveText(0, this.current.leading);
                }
                paintChar(character, x, y, patternTransform) {
                  const ctx = this.ctx;
                  const current = this.current;
                  const font = current.font;
                  const textRenderingMode = current.textRenderingMode;
                  const fontSize = current.fontSize / current.fontSizeScale;
                  const fillStrokeMode = textRenderingMode & _util2.TextRenderingMode.FILL_STROKE_MASK;
                  const isAddToPathSet = !!(textRenderingMode & _util2.TextRenderingMode.ADD_TO_PATH_FLAG);
                  const patternFill = current.patternFill && !font.missingFile;
                  let addToPath;
                  if (font.disableFontFace || isAddToPathSet || patternFill) {
                    addToPath = font.getPathGenerator(this.commonObjs, character);
                  }
                  if (font.disableFontFace || patternFill) {
                    ctx.save();
                    ctx.translate(x, y);
                    ctx.beginPath();
                    addToPath(ctx, fontSize);
                    if (patternTransform) {
                      ctx.setTransform(...patternTransform);
                    }
                    if (fillStrokeMode === _util2.TextRenderingMode.FILL || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                      ctx.fill();
                    }
                    if (fillStrokeMode === _util2.TextRenderingMode.STROKE || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                      ctx.stroke();
                    }
                    ctx.restore();
                  } else {
                    if (fillStrokeMode === _util2.TextRenderingMode.FILL || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                      ctx.fillText(character, x, y);
                    }
                    if (fillStrokeMode === _util2.TextRenderingMode.STROKE || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                      ctx.strokeText(character, x, y);
                    }
                  }
                  if (isAddToPathSet) {
                    const paths = this.pendingTextPaths || (this.pendingTextPaths = []);
                    paths.push({
                      transform: (0, _display_utils2.getCurrentTransform)(ctx),
                      x,
                      y,
                      fontSize,
                      addToPath
                    });
                  }
                }
                get isFontSubpixelAAEnabled() {
                  const {
                    context: ctx
                  } = this.cachedCanvases.getCanvas("isFontSubpixelAAEnabled", 10, 10);
                  ctx.scale(1.5, 1);
                  ctx.fillText("I", 0, 10);
                  const data = ctx.getImageData(0, 0, 10, 10).data;
                  let enabled = false;
                  for (let i = 3; i < data.length; i += 4) {
                    if (data[i] > 0 && data[i] < 255) {
                      enabled = true;
                      break;
                    }
                  }
                  return (0, _util2.shadow)(this, "isFontSubpixelAAEnabled", enabled);
                }
                showText(glyphs) {
                  const current = this.current;
                  const font = current.font;
                  if (font.isType3Font) {
                    return this.showType3Text(glyphs);
                  }
                  const fontSize = current.fontSize;
                  if (fontSize === 0) {
                    return void 0;
                  }
                  const ctx = this.ctx;
                  const fontSizeScale = current.fontSizeScale;
                  const charSpacing = current.charSpacing;
                  const wordSpacing = current.wordSpacing;
                  const fontDirection = current.fontDirection;
                  const textHScale = current.textHScale * fontDirection;
                  const glyphsLength = glyphs.length;
                  const vertical = font.vertical;
                  const spacingDir = vertical ? 1 : -1;
                  const defaultVMetrics = font.defaultVMetrics;
                  const widthAdvanceScale = fontSize * current.fontMatrix[0];
                  const simpleFillText = current.textRenderingMode === _util2.TextRenderingMode.FILL && !font.disableFontFace && !current.patternFill;
                  ctx.save();
                  ctx.transform(...current.textMatrix);
                  ctx.translate(current.x, current.y + current.textRise);
                  if (fontDirection > 0) {
                    ctx.scale(textHScale, -1);
                  } else {
                    ctx.scale(textHScale, 1);
                  }
                  let patternTransform;
                  if (current.patternFill) {
                    ctx.save();
                    const pattern = current.fillColor.getPattern(ctx, this, (0, _display_utils2.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.FILL);
                    patternTransform = (0, _display_utils2.getCurrentTransform)(ctx);
                    ctx.restore();
                    ctx.fillStyle = pattern;
                  }
                  let lineWidth = current.lineWidth;
                  const scale = current.textMatrixScale;
                  if (scale === 0 || lineWidth === 0) {
                    const fillStrokeMode = current.textRenderingMode & _util2.TextRenderingMode.FILL_STROKE_MASK;
                    if (fillStrokeMode === _util2.TextRenderingMode.STROKE || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                      lineWidth = this.getSinglePixelWidth();
                    }
                  } else {
                    lineWidth /= scale;
                  }
                  if (fontSizeScale !== 1) {
                    ctx.scale(fontSizeScale, fontSizeScale);
                    lineWidth /= fontSizeScale;
                  }
                  ctx.lineWidth = lineWidth;
                  let x = 0, i;
                  for (i = 0; i < glyphsLength; ++i) {
                    const glyph = glyphs[i];
                    if (typeof glyph === "number") {
                      x += spacingDir * glyph * fontSize / 1e3;
                      continue;
                    }
                    let restoreNeeded = false;
                    const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
                    const character = glyph.fontChar;
                    const accent = glyph.accent;
                    let scaledX, scaledY;
                    let width = glyph.width;
                    if (vertical) {
                      const vmetric = glyph.vmetric || defaultVMetrics;
                      const vx = -(glyph.vmetric ? vmetric[1] : width * 0.5) * widthAdvanceScale;
                      const vy = vmetric[2] * widthAdvanceScale;
                      width = vmetric ? -vmetric[0] : width;
                      scaledX = vx / fontSizeScale;
                      scaledY = (x + vy) / fontSizeScale;
                    } else {
                      scaledX = x / fontSizeScale;
                      scaledY = 0;
                    }
                    if (font.remeasure && width > 0) {
                      const measuredWidth = ctx.measureText(character).width * 1e3 / fontSize * fontSizeScale;
                      if (width < measuredWidth && this.isFontSubpixelAAEnabled) {
                        const characterScaleX = width / measuredWidth;
                        restoreNeeded = true;
                        ctx.save();
                        ctx.scale(characterScaleX, 1);
                        scaledX /= characterScaleX;
                      } else if (width !== measuredWidth) {
                        scaledX += (width - measuredWidth) / 2e3 * fontSize / fontSizeScale;
                      }
                    }
                    if (this.contentVisible && (glyph.isInFont || font.missingFile)) {
                      if (simpleFillText && !accent) {
                        ctx.fillText(character, scaledX, scaledY);
                      } else {
                        this.paintChar(character, scaledX, scaledY, patternTransform);
                        if (accent) {
                          const scaledAccentX = scaledX + fontSize * accent.offset.x / fontSizeScale;
                          const scaledAccentY = scaledY - fontSize * accent.offset.y / fontSizeScale;
                          this.paintChar(accent.fontChar, scaledAccentX, scaledAccentY, patternTransform);
                        }
                      }
                    }
                    let charWidth;
                    if (vertical) {
                      charWidth = width * widthAdvanceScale - spacing * fontDirection;
                    } else {
                      charWidth = width * widthAdvanceScale + spacing * fontDirection;
                    }
                    x += charWidth;
                    if (restoreNeeded) {
                      ctx.restore();
                    }
                  }
                  if (vertical) {
                    current.y -= x;
                  } else {
                    current.x += x * textHScale;
                  }
                  ctx.restore();
                  this.compose();
                  return void 0;
                }
                showType3Text(glyphs) {
                  const ctx = this.ctx;
                  const current = this.current;
                  const font = current.font;
                  const fontSize = current.fontSize;
                  const fontDirection = current.fontDirection;
                  const spacingDir = font.vertical ? 1 : -1;
                  const charSpacing = current.charSpacing;
                  const wordSpacing = current.wordSpacing;
                  const textHScale = current.textHScale * fontDirection;
                  const fontMatrix = current.fontMatrix || _util2.FONT_IDENTITY_MATRIX;
                  const glyphsLength = glyphs.length;
                  const isTextInvisible = current.textRenderingMode === _util2.TextRenderingMode.INVISIBLE;
                  let i, glyph, width, spacingLength;
                  if (isTextInvisible || fontSize === 0) {
                    return;
                  }
                  this._cachedScaleForStroking = null;
                  this._cachedGetSinglePixelWidth = null;
                  ctx.save();
                  ctx.transform(...current.textMatrix);
                  ctx.translate(current.x, current.y);
                  ctx.scale(textHScale, fontDirection);
                  for (i = 0; i < glyphsLength; ++i) {
                    glyph = glyphs[i];
                    if (typeof glyph === "number") {
                      spacingLength = spacingDir * glyph * fontSize / 1e3;
                      this.ctx.translate(spacingLength, 0);
                      current.x += spacingLength * textHScale;
                      continue;
                    }
                    const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
                    const operatorList = font.charProcOperatorList[glyph.operatorListId];
                    if (!operatorList) {
                      (0, _util2.warn)(`Type3 character "${glyph.operatorListId}" is not available.`);
                      continue;
                    }
                    if (this.contentVisible) {
                      this.processingType3 = glyph;
                      this.save();
                      ctx.scale(fontSize, fontSize);
                      ctx.transform(...fontMatrix);
                      this.executeOperatorList(operatorList);
                      this.restore();
                    }
                    const transformed = _util2.Util.applyTransform([glyph.width, 0], fontMatrix);
                    width = transformed[0] * fontSize + spacing;
                    ctx.translate(width, 0);
                    current.x += width * textHScale;
                  }
                  ctx.restore();
                  this.processingType3 = null;
                }
                setCharWidth(xWidth, yWidth) {
                }
                setCharWidthAndBounds(xWidth, yWidth, llx, lly, urx, ury) {
                  this.ctx.rect(llx, lly, urx - llx, ury - lly);
                  this.ctx.clip();
                  this.endPath();
                }
                getColorN_Pattern(IR) {
                  let pattern;
                  if (IR[0] === "TilingPattern") {
                    const color = IR[1];
                    const baseTransform = this.baseTransform || (0, _display_utils2.getCurrentTransform)(this.ctx);
                    const canvasGraphicsFactory = {
                      createCanvasGraphics: (ctx) => {
                        return new CanvasGraphics(ctx, this.commonObjs, this.objs, this.canvasFactory);
                      }
                    };
                    pattern = new _pattern_helper.TilingPattern(IR, color, this.ctx, canvasGraphicsFactory, baseTransform);
                  } else {
                    pattern = this._getPattern(IR[1], IR[2]);
                  }
                  return pattern;
                }
                setStrokeColorN() {
                  this.current.strokeColor = this.getColorN_Pattern(arguments);
                }
                setFillColorN() {
                  this.current.fillColor = this.getColorN_Pattern(arguments);
                  this.current.patternFill = true;
                }
                setStrokeRGBColor(r2, g, b) {
                  var _this$selectColor;
                  const color = ((_this$selectColor = this.selectColor) === null || _this$selectColor === void 0 ? void 0 : _this$selectColor.call(this, r2, g, b)) || _util2.Util.makeHexColor(r2, g, b);
                  this.ctx.strokeStyle = color;
                  this.current.strokeColor = color;
                }
                setFillRGBColor(r2, g, b) {
                  var _this$selectColor2;
                  const color = ((_this$selectColor2 = this.selectColor) === null || _this$selectColor2 === void 0 ? void 0 : _this$selectColor2.call(this, r2, g, b)) || _util2.Util.makeHexColor(r2, g, b);
                  this.ctx.fillStyle = color;
                  this.current.fillColor = color;
                  this.current.patternFill = false;
                }
                _getPattern(objId) {
                  let matrix = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
                  let pattern;
                  if (this.cachedPatterns.has(objId)) {
                    pattern = this.cachedPatterns.get(objId);
                  } else {
                    pattern = (0, _pattern_helper.getShadingPattern)(this.objs.get(objId));
                    this.cachedPatterns.set(objId, pattern);
                  }
                  if (matrix) {
                    pattern.matrix = matrix;
                  }
                  return pattern;
                }
                shadingFill(objId) {
                  if (!this.contentVisible) {
                    return;
                  }
                  const ctx = this.ctx;
                  this.save();
                  const pattern = this._getPattern(objId);
                  ctx.fillStyle = pattern.getPattern(ctx, this, (0, _display_utils2.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.SHADING);
                  const inv = (0, _display_utils2.getCurrentTransformInverse)(ctx);
                  if (inv) {
                    const canvas = ctx.canvas;
                    const width = canvas.width;
                    const height = canvas.height;
                    const bl = _util2.Util.applyTransform([0, 0], inv);
                    const br = _util2.Util.applyTransform([0, height], inv);
                    const ul = _util2.Util.applyTransform([width, 0], inv);
                    const ur = _util2.Util.applyTransform([width, height], inv);
                    const x0 = Math.min(bl[0], br[0], ul[0], ur[0]);
                    const y0 = Math.min(bl[1], br[1], ul[1], ur[1]);
                    const x1 = Math.max(bl[0], br[0], ul[0], ur[0]);
                    const y1 = Math.max(bl[1], br[1], ul[1], ur[1]);
                    this.ctx.fillRect(x0, y0, x1 - x0, y1 - y0);
                  } else {
                    this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);
                  }
                  this.compose(this.current.getClippedPathBoundingBox());
                  this.restore();
                }
                beginInlineImage() {
                  (0, _util2.unreachable)("Should not call beginInlineImage");
                }
                beginImageData() {
                  (0, _util2.unreachable)("Should not call beginImageData");
                }
                paintFormXObjectBegin(matrix, bbox) {
                  if (!this.contentVisible) {
                    return;
                  }
                  this.save();
                  this.baseTransformStack.push(this.baseTransform);
                  if (Array.isArray(matrix) && matrix.length === 6) {
                    this.transform(...matrix);
                  }
                  this.baseTransform = (0, _display_utils2.getCurrentTransform)(this.ctx);
                  if (bbox) {
                    const width = bbox[2] - bbox[0];
                    const height = bbox[3] - bbox[1];
                    this.ctx.rect(bbox[0], bbox[1], width, height);
                    this.current.updateRectMinMax((0, _display_utils2.getCurrentTransform)(this.ctx), bbox);
                    this.clip();
                    this.endPath();
                  }
                }
                paintFormXObjectEnd() {
                  if (!this.contentVisible) {
                    return;
                  }
                  this.restore();
                  this.baseTransform = this.baseTransformStack.pop();
                }
                beginGroup(group) {
                  if (!this.contentVisible) {
                    return;
                  }
                  this.save();
                  if (this.inSMaskMode) {
                    this.endSMaskMode();
                    this.current.activeSMask = null;
                  }
                  const currentCtx = this.ctx;
                  if (!group.isolated) {
                    (0, _util2.info)("TODO: Support non-isolated groups.");
                  }
                  if (group.knockout) {
                    (0, _util2.warn)("Knockout groups not supported.");
                  }
                  const currentTransform = (0, _display_utils2.getCurrentTransform)(currentCtx);
                  if (group.matrix) {
                    currentCtx.transform(...group.matrix);
                  }
                  if (!group.bbox) {
                    throw new Error("Bounding box is required.");
                  }
                  let bounds = _util2.Util.getAxialAlignedBoundingBox(group.bbox, (0, _display_utils2.getCurrentTransform)(currentCtx));
                  const canvasBounds = [0, 0, currentCtx.canvas.width, currentCtx.canvas.height];
                  bounds = _util2.Util.intersect(bounds, canvasBounds) || [0, 0, 0, 0];
                  const offsetX = Math.floor(bounds[0]);
                  const offsetY = Math.floor(bounds[1]);
                  let drawnWidth = Math.max(Math.ceil(bounds[2]) - offsetX, 1);
                  let drawnHeight = Math.max(Math.ceil(bounds[3]) - offsetY, 1);
                  let scaleX = 1, scaleY = 1;
                  if (drawnWidth > MAX_GROUP_SIZE) {
                    scaleX = drawnWidth / MAX_GROUP_SIZE;
                    drawnWidth = MAX_GROUP_SIZE;
                  }
                  if (drawnHeight > MAX_GROUP_SIZE) {
                    scaleY = drawnHeight / MAX_GROUP_SIZE;
                    drawnHeight = MAX_GROUP_SIZE;
                  }
                  this.current.startNewPathAndClipBox([0, 0, drawnWidth, drawnHeight]);
                  let cacheId = "groupAt" + this.groupLevel;
                  if (group.smask) {
                    cacheId += "_smask_" + this.smaskCounter++ % 2;
                  }
                  const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight);
                  const groupCtx = scratchCanvas.context;
                  groupCtx.scale(1 / scaleX, 1 / scaleY);
                  groupCtx.translate(-offsetX, -offsetY);
                  groupCtx.transform(...currentTransform);
                  if (group.smask) {
                    this.smaskStack.push({
                      canvas: scratchCanvas.canvas,
                      context: groupCtx,
                      offsetX,
                      offsetY,
                      scaleX,
                      scaleY,
                      subtype: group.smask.subtype,
                      backdrop: group.smask.backdrop,
                      transferMap: group.smask.transferMap || null,
                      startTransformInverse: null
                    });
                  } else {
                    currentCtx.setTransform(1, 0, 0, 1, 0, 0);
                    currentCtx.translate(offsetX, offsetY);
                    currentCtx.scale(scaleX, scaleY);
                    currentCtx.save();
                  }
                  copyCtxState(currentCtx, groupCtx);
                  this.ctx = groupCtx;
                  this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]);
                  this.groupStack.push(currentCtx);
                  this.groupLevel++;
                }
                endGroup(group) {
                  if (!this.contentVisible) {
                    return;
                  }
                  this.groupLevel--;
                  const groupCtx = this.ctx;
                  const ctx = this.groupStack.pop();
                  this.ctx = ctx;
                  this.ctx.imageSmoothingEnabled = false;
                  if (group.smask) {
                    this.tempSMask = this.smaskStack.pop();
                    this.restore();
                  } else {
                    this.ctx.restore();
                    const currentMtx = (0, _display_utils2.getCurrentTransform)(this.ctx);
                    this.restore();
                    this.ctx.save();
                    this.ctx.setTransform(...currentMtx);
                    const dirtyBox = _util2.Util.getAxialAlignedBoundingBox([0, 0, groupCtx.canvas.width, groupCtx.canvas.height], currentMtx);
                    this.ctx.drawImage(groupCtx.canvas, 0, 0);
                    this.ctx.restore();
                    this.compose(dirtyBox);
                  }
                }
                beginAnnotation(id, rect, transform, matrix, hasOwnCanvas) {
                  _classPrivateMethodGet2(this, _restoreInitialState, _restoreInitialState2).call(this);
                  resetCtxToDefault(this.ctx, this.foregroundColor);
                  this.ctx.save();
                  this.save();
                  if (this.baseTransform) {
                    this.ctx.setTransform(...this.baseTransform);
                  }
                  if (Array.isArray(rect) && rect.length === 4) {
                    const width = rect[2] - rect[0];
                    const height = rect[3] - rect[1];
                    if (hasOwnCanvas && this.annotationCanvasMap) {
                      transform = transform.slice();
                      transform[4] -= rect[0];
                      transform[5] -= rect[1];
                      rect = rect.slice();
                      rect[0] = rect[1] = 0;
                      rect[2] = width;
                      rect[3] = height;
                      const [scaleX, scaleY] = _util2.Util.singularValueDecompose2dScale((0, _display_utils2.getCurrentTransform)(this.ctx));
                      const {
                        viewportScale
                      } = this;
                      const canvasWidth = Math.ceil(width * this.outputScaleX * viewportScale);
                      const canvasHeight = Math.ceil(height * this.outputScaleY * viewportScale);
                      this.annotationCanvas = this.canvasFactory.create(canvasWidth, canvasHeight);
                      const {
                        canvas,
                        context
                      } = this.annotationCanvas;
                      this.annotationCanvasMap.set(id, canvas);
                      this.annotationCanvas.savedCtx = this.ctx;
                      this.ctx = context;
                      this.ctx.setTransform(scaleX, 0, 0, -scaleY, 0, height * scaleY);
                      resetCtxToDefault(this.ctx, this.foregroundColor);
                    } else {
                      resetCtxToDefault(this.ctx, this.foregroundColor);
                      this.ctx.rect(rect[0], rect[1], width, height);
                      this.ctx.clip();
                      this.endPath();
                    }
                  }
                  this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);
                  this.transform(...transform);
                  this.transform(...matrix);
                }
                endAnnotation() {
                  if (this.annotationCanvas) {
                    this.ctx = this.annotationCanvas.savedCtx;
                    delete this.annotationCanvas.savedCtx;
                    delete this.annotationCanvas;
                  }
                }
                paintImageMaskXObject(img) {
                  if (!this.contentVisible) {
                    return;
                  }
                  const count = img.count;
                  img = this.getObject(img.data, img);
                  img.count = count;
                  const ctx = this.ctx;
                  const glyph = this.processingType3;
                  if (glyph) {
                    if (glyph.compiled === void 0) {
                      glyph.compiled = compileType3Glyph(img);
                    }
                    if (glyph.compiled) {
                      glyph.compiled(ctx);
                      return;
                    }
                  }
                  const mask = this._createMaskCanvas(img);
                  const maskCanvas = mask.canvas;
                  ctx.save();
                  ctx.setTransform(1, 0, 0, 1, 0, 0);
                  ctx.drawImage(maskCanvas, mask.offsetX, mask.offsetY);
                  ctx.restore();
                  this.compose();
                }
                paintImageMaskXObjectRepeat(img, scaleX) {
                  let skewX = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
                  let skewY = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
                  let scaleY = arguments.length > 4 ? arguments[4] : void 0;
                  let positions = arguments.length > 5 ? arguments[5] : void 0;
                  if (!this.contentVisible) {
                    return;
                  }
                  img = this.getObject(img.data, img);
                  const ctx = this.ctx;
                  ctx.save();
                  const currentTransform = (0, _display_utils2.getCurrentTransform)(ctx);
                  ctx.transform(scaleX, skewX, skewY, scaleY, 0, 0);
                  const mask = this._createMaskCanvas(img);
                  ctx.setTransform(1, 0, 0, 1, 0, 0);
                  for (let i = 0, ii = positions.length; i < ii; i += 2) {
                    const trans = _util2.Util.transform(currentTransform, [scaleX, skewX, skewY, scaleY, positions[i], positions[i + 1]]);
                    const [x, y] = _util2.Util.applyTransform([0, 0], trans);
                    ctx.drawImage(mask.canvas, x, y);
                  }
                  ctx.restore();
                  this.compose();
                }
                paintImageMaskXObjectGroup(images) {
                  if (!this.contentVisible) {
                    return;
                  }
                  const ctx = this.ctx;
                  const fillColor = this.current.fillColor;
                  const isPatternFill = this.current.patternFill;
                  for (const image of images) {
                    const {
                      data,
                      width,
                      height,
                      transform
                    } = image;
                    const maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height);
                    const maskCtx = maskCanvas.context;
                    maskCtx.save();
                    const img = this.getObject(data, image);
                    putBinaryImageMask(maskCtx, img);
                    maskCtx.globalCompositeOperation = "source-in";
                    maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this, (0, _display_utils2.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.FILL) : fillColor;
                    maskCtx.fillRect(0, 0, width, height);
                    maskCtx.restore();
                    ctx.save();
                    ctx.transform(...transform);
                    ctx.scale(1, -1);
                    drawImageAtIntegerCoords(ctx, maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);
                    ctx.restore();
                  }
                  this.compose();
                }
                paintImageXObject(objId) {
                  if (!this.contentVisible) {
                    return;
                  }
                  const imgData = this.getObject(objId);
                  if (!imgData) {
                    (0, _util2.warn)("Dependent image isn't ready yet");
                    return;
                  }
                  this.paintInlineImageXObject(imgData);
                }
                paintImageXObjectRepeat(objId, scaleX, scaleY, positions) {
                  if (!this.contentVisible) {
                    return;
                  }
                  const imgData = this.getObject(objId);
                  if (!imgData) {
                    (0, _util2.warn)("Dependent image isn't ready yet");
                    return;
                  }
                  const width = imgData.width;
                  const height = imgData.height;
                  const map = [];
                  for (let i = 0, ii = positions.length; i < ii; i += 2) {
                    map.push({
                      transform: [scaleX, 0, 0, scaleY, positions[i], positions[i + 1]],
                      x: 0,
                      y: 0,
                      w: width,
                      h: height
                    });
                  }
                  this.paintInlineImageXObjectGroup(imgData, map);
                }
                paintInlineImageXObject(imgData) {
                  if (!this.contentVisible) {
                    return;
                  }
                  const width = imgData.width;
                  const height = imgData.height;
                  const ctx = this.ctx;
                  this.save();
                  ctx.scale(1 / width, -1 / height);
                  let imgToPaint;
                  if (typeof HTMLElement === "function" && imgData instanceof HTMLElement || !imgData.data) {
                    imgToPaint = imgData;
                  } else {
                    const tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", width, height);
                    const tmpCtx = tmpCanvas.context;
                    putBinaryImageData(tmpCtx, imgData, this.current.transferMaps);
                    imgToPaint = tmpCanvas.canvas;
                  }
                  const scaled = this._scaleImage(imgToPaint, (0, _display_utils2.getCurrentTransformInverse)(ctx));
                  ctx.imageSmoothingEnabled = getImageSmoothingEnabled((0, _display_utils2.getCurrentTransform)(ctx), imgData.interpolate);
                  const [rWidth, rHeight] = drawImageAtIntegerCoords(ctx, scaled.img, 0, 0, scaled.paintWidth, scaled.paintHeight, 0, -height, width, height);
                  if (this.imageLayer) {
                    const [left, top] = _util2.Util.applyTransform([0, -height], (0, _display_utils2.getCurrentTransform)(this.ctx));
                    this.imageLayer.appendImage({
                      imgData,
                      left,
                      top,
                      width: rWidth,
                      height: rHeight
                    });
                  }
                  this.compose();
                  this.restore();
                }
                paintInlineImageXObjectGroup(imgData, map) {
                  if (!this.contentVisible) {
                    return;
                  }
                  const ctx = this.ctx;
                  const w = imgData.width;
                  const h = imgData.height;
                  const tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", w, h);
                  const tmpCtx = tmpCanvas.context;
                  putBinaryImageData(tmpCtx, imgData, this.current.transferMaps);
                  for (const entry of map) {
                    ctx.save();
                    ctx.transform(...entry.transform);
                    ctx.scale(1, -1);
                    drawImageAtIntegerCoords(ctx, tmpCanvas.canvas, entry.x, entry.y, entry.w, entry.h, 0, -1, 1, 1);
                    if (this.imageLayer) {
                      const [left, top] = _util2.Util.applyTransform([entry.x, entry.y], (0, _display_utils2.getCurrentTransform)(this.ctx));
                      this.imageLayer.appendImage({
                        imgData,
                        left,
                        top,
                        width: w,
                        height: h
                      });
                    }
                    ctx.restore();
                  }
                  this.compose();
                }
                paintSolidColorImageMask() {
                  if (!this.contentVisible) {
                    return;
                  }
                  this.ctx.fillRect(0, 0, 1, 1);
                  this.compose();
                }
                markPoint(tag) {
                }
                markPointProps(tag, properties) {
                }
                beginMarkedContent(tag) {
                  this.markedContentStack.push({
                    visible: true
                  });
                }
                beginMarkedContentProps(tag, properties) {
                  if (tag === "OC") {
                    this.markedContentStack.push({
                      visible: this.optionalContentConfig.isVisible(properties)
                    });
                  } else {
                    this.markedContentStack.push({
                      visible: true
                    });
                  }
                  this.contentVisible = this.isContentVisible();
                }
                endMarkedContent() {
                  this.markedContentStack.pop();
                  this.contentVisible = this.isContentVisible();
                }
                beginCompat() {
                }
                endCompat() {
                }
                consumePath(clipBox) {
                  const isEmpty = this.current.isEmptyClip();
                  if (this.pendingClip) {
                    this.current.updateClipFromPath();
                  }
                  if (!this.pendingClip) {
                    this.compose(clipBox);
                  }
                  const ctx = this.ctx;
                  if (this.pendingClip) {
                    if (!isEmpty) {
                      if (this.pendingClip === EO_CLIP) {
                        ctx.clip("evenodd");
                      } else {
                        ctx.clip();
                      }
                    }
                    this.pendingClip = null;
                  }
                  this.current.startNewPathAndClipBox(this.current.clipBox);
                  ctx.beginPath();
                }
                getSinglePixelWidth() {
                  if (!this._cachedGetSinglePixelWidth) {
                    const m = (0, _display_utils2.getCurrentTransform)(this.ctx);
                    if (m[1] === 0 && m[2] === 0) {
                      this._cachedGetSinglePixelWidth = 1 / Math.min(Math.abs(m[0]), Math.abs(m[3]));
                    } else {
                      const absDet = Math.abs(m[0] * m[3] - m[2] * m[1]);
                      const normX = Math.hypot(m[0], m[2]);
                      const normY = Math.hypot(m[1], m[3]);
                      this._cachedGetSinglePixelWidth = Math.max(normX, normY) / absDet;
                    }
                  }
                  return this._cachedGetSinglePixelWidth;
                }
                getScaleForStroking() {
                  if (!this._cachedScaleForStroking) {
                    const {
                      lineWidth
                    } = this.current;
                    const m = (0, _display_utils2.getCurrentTransform)(this.ctx);
                    let scaleX, scaleY;
                    if (m[1] === 0 && m[2] === 0) {
                      const normX = Math.abs(m[0]);
                      const normY = Math.abs(m[3]);
                      if (lineWidth === 0) {
                        scaleX = 1 / normX;
                        scaleY = 1 / normY;
                      } else {
                        const scaledXLineWidth = normX * lineWidth;
                        const scaledYLineWidth = normY * lineWidth;
                        scaleX = scaledXLineWidth < 1 ? 1 / scaledXLineWidth : 1;
                        scaleY = scaledYLineWidth < 1 ? 1 / scaledYLineWidth : 1;
                      }
                    } else {
                      const absDet = Math.abs(m[0] * m[3] - m[2] * m[1]);
                      const normX = Math.hypot(m[0], m[1]);
                      const normY = Math.hypot(m[2], m[3]);
                      if (lineWidth === 0) {
                        scaleX = normY / absDet;
                        scaleY = normX / absDet;
                      } else {
                        const baseArea = lineWidth * absDet;
                        scaleX = normY > baseArea ? normY / baseArea : 1;
                        scaleY = normX > baseArea ? normX / baseArea : 1;
                      }
                    }
                    this._cachedScaleForStroking = [scaleX, scaleY];
                  }
                  return this._cachedScaleForStroking;
                }
                rescaleAndStroke(saveRestore) {
                  const {
                    ctx
                  } = this;
                  const {
                    lineWidth
                  } = this.current;
                  const [scaleX, scaleY] = this.getScaleForStroking();
                  ctx.lineWidth = lineWidth || 1;
                  if (scaleX === 1 && scaleY === 1) {
                    ctx.stroke();
                    return;
                  }
                  let savedMatrix, savedDashes, savedDashOffset;
                  if (saveRestore) {
                    savedMatrix = (0, _display_utils2.getCurrentTransform)(ctx);
                    savedDashes = ctx.getLineDash().slice();
                    savedDashOffset = ctx.lineDashOffset;
                  }
                  ctx.scale(scaleX, scaleY);
                  const scale = Math.max(scaleX, scaleY);
                  ctx.setLineDash(ctx.getLineDash().map((x) => x / scale));
                  ctx.lineDashOffset /= scale;
                  ctx.stroke();
                  if (saveRestore) {
                    ctx.setTransform(...savedMatrix);
                    ctx.setLineDash(savedDashes);
                    ctx.lineDashOffset = savedDashOffset;
                  }
                }
                isContentVisible() {
                  for (let i = this.markedContentStack.length - 1; i >= 0; i--) {
                    if (!this.markedContentStack[i].visible) {
                      return false;
                    }
                  }
                  return true;
                }
              }
              exports2.CanvasGraphics = CanvasGraphics;
              function _restoreInitialState2() {
                while (this.stateStack.length || this.inSMaskMode) {
                  this.restore();
                }
                this.ctx.restore();
                if (this.transparentCanvas) {
                  this.ctx = this.compositeCtx;
                  this.ctx.save();
                  this.ctx.setTransform(1, 0, 0, 1, 0, 0);
                  this.ctx.drawImage(this.transparentCanvas, 0, 0);
                  this.ctx.restore();
                  this.transparentCanvas = null;
                }
              }
              for (const op in _util2.OPS) {
                if (CanvasGraphics.prototype[op] !== void 0) {
                  CanvasGraphics.prototype[_util2.OPS[op]] = CanvasGraphics.prototype[op];
                }
              }
            },
            /* 138 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.TilingPattern = exports2.PathType = void 0;
              exports2.getShadingPattern = getShadingPattern;
              var _util2 = __w_pdfjs_require__2(1);
              var _display_utils2 = __w_pdfjs_require__2(133);
              var _is_node2 = __w_pdfjs_require__2(3);
              const PathType = {
                FILL: "Fill",
                STROKE: "Stroke",
                SHADING: "Shading"
              };
              exports2.PathType = PathType;
              function applyBoundingBox(ctx, bbox) {
                if (!bbox || _is_node2.isNodeJS) {
                  return;
                }
                const width = bbox[2] - bbox[0];
                const height = bbox[3] - bbox[1];
                const region = new Path2D();
                region.rect(bbox[0], bbox[1], width, height);
                ctx.clip(region);
              }
              class BaseShadingPattern {
                constructor() {
                  if (this.constructor === BaseShadingPattern) {
                    (0, _util2.unreachable)("Cannot initialize BaseShadingPattern.");
                  }
                }
                getPattern() {
                  (0, _util2.unreachable)("Abstract method `getPattern` called.");
                }
              }
              class RadialAxialShadingPattern extends BaseShadingPattern {
                constructor(IR) {
                  super();
                  this._type = IR[1];
                  this._bbox = IR[2];
                  this._colorStops = IR[3];
                  this._p0 = IR[4];
                  this._p1 = IR[5];
                  this._r0 = IR[6];
                  this._r1 = IR[7];
                  this.matrix = null;
                }
                _createGradient(ctx) {
                  let grad;
                  if (this._type === "axial") {
                    grad = ctx.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1]);
                  } else if (this._type === "radial") {
                    grad = ctx.createRadialGradient(this._p0[0], this._p0[1], this._r0, this._p1[0], this._p1[1], this._r1);
                  }
                  for (const colorStop of this._colorStops) {
                    grad.addColorStop(colorStop[0], colorStop[1]);
                  }
                  return grad;
                }
                getPattern(ctx, owner, inverse, pathType) {
                  let pattern;
                  if (pathType === PathType.STROKE || pathType === PathType.FILL) {
                    const ownerBBox = owner.current.getClippedPathBoundingBox(pathType, (0, _display_utils2.getCurrentTransform)(ctx)) || [0, 0, 0, 0];
                    const width = Math.ceil(ownerBBox[2] - ownerBBox[0]) || 1;
                    const height = Math.ceil(ownerBBox[3] - ownerBBox[1]) || 1;
                    const tmpCanvas = owner.cachedCanvases.getCanvas("pattern", width, height, true);
                    const tmpCtx = tmpCanvas.context;
                    tmpCtx.clearRect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);
                    tmpCtx.beginPath();
                    tmpCtx.rect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);
                    tmpCtx.translate(-ownerBBox[0], -ownerBBox[1]);
                    inverse = _util2.Util.transform(inverse, [1, 0, 0, 1, ownerBBox[0], ownerBBox[1]]);
                    tmpCtx.transform(...owner.baseTransform);
                    if (this.matrix) {
                      tmpCtx.transform(...this.matrix);
                    }
                    applyBoundingBox(tmpCtx, this._bbox);
                    tmpCtx.fillStyle = this._createGradient(tmpCtx);
                    tmpCtx.fill();
                    pattern = ctx.createPattern(tmpCanvas.canvas, "no-repeat");
                    const domMatrix = new DOMMatrix(inverse);
                    try {
                      pattern.setTransform(domMatrix);
                    } catch (ex) {
                      (0, _util2.warn)(`RadialAxialShadingPattern.getPattern: "${ex === null || ex === void 0 ? void 0 : ex.message}".`);
                    }
                  } else {
                    applyBoundingBox(ctx, this._bbox);
                    pattern = this._createGradient(ctx);
                  }
                  return pattern;
                }
              }
              function drawTriangle(data, context, p1, p2, p3, c1, c2, c3) {
                const coords = context.coords, colors = context.colors;
                const bytes = data.data, rowSize = data.width * 4;
                let tmp;
                if (coords[p1 + 1] > coords[p2 + 1]) {
                  tmp = p1;
                  p1 = p2;
                  p2 = tmp;
                  tmp = c1;
                  c1 = c2;
                  c2 = tmp;
                }
                if (coords[p2 + 1] > coords[p3 + 1]) {
                  tmp = p2;
                  p2 = p3;
                  p3 = tmp;
                  tmp = c2;
                  c2 = c3;
                  c3 = tmp;
                }
                if (coords[p1 + 1] > coords[p2 + 1]) {
                  tmp = p1;
                  p1 = p2;
                  p2 = tmp;
                  tmp = c1;
                  c1 = c2;
                  c2 = tmp;
                }
                const x1 = (coords[p1] + context.offsetX) * context.scaleX;
                const y1 = (coords[p1 + 1] + context.offsetY) * context.scaleY;
                const x2 = (coords[p2] + context.offsetX) * context.scaleX;
                const y2 = (coords[p2 + 1] + context.offsetY) * context.scaleY;
                const x3 = (coords[p3] + context.offsetX) * context.scaleX;
                const y3 = (coords[p3 + 1] + context.offsetY) * context.scaleY;
                if (y1 >= y3) {
                  return;
                }
                const c1r = colors[c1], c1g = colors[c1 + 1], c1b = colors[c1 + 2];
                const c2r = colors[c2], c2g = colors[c2 + 1], c2b = colors[c2 + 2];
                const c3r = colors[c3], c3g = colors[c3 + 1], c3b = colors[c3 + 2];
                const minY = Math.round(y1), maxY = Math.round(y3);
                let xa, car, cag, cab;
                let xb, cbr, cbg, cbb;
                for (let y = minY; y <= maxY; y++) {
                  if (y < y2) {
                    let k2;
                    if (y < y1) {
                      k2 = 0;
                    } else {
                      k2 = (y1 - y) / (y1 - y2);
                    }
                    xa = x1 - (x1 - x2) * k2;
                    car = c1r - (c1r - c2r) * k2;
                    cag = c1g - (c1g - c2g) * k2;
                    cab = c1b - (c1b - c2b) * k2;
                  } else {
                    let k2;
                    if (y > y3) {
                      k2 = 1;
                    } else if (y2 === y3) {
                      k2 = 0;
                    } else {
                      k2 = (y2 - y) / (y2 - y3);
                    }
                    xa = x2 - (x2 - x3) * k2;
                    car = c2r - (c2r - c3r) * k2;
                    cag = c2g - (c2g - c3g) * k2;
                    cab = c2b - (c2b - c3b) * k2;
                  }
                  let k;
                  if (y < y1) {
                    k = 0;
                  } else if (y > y3) {
                    k = 1;
                  } else {
                    k = (y1 - y) / (y1 - y3);
                  }
                  xb = x1 - (x1 - x3) * k;
                  cbr = c1r - (c1r - c3r) * k;
                  cbg = c1g - (c1g - c3g) * k;
                  cbb = c1b - (c1b - c3b) * k;
                  const x1_ = Math.round(Math.min(xa, xb));
                  const x2_ = Math.round(Math.max(xa, xb));
                  let j = rowSize * y + x1_ * 4;
                  for (let x = x1_; x <= x2_; x++) {
                    k = (xa - x) / (xa - xb);
                    if (k < 0) {
                      k = 0;
                    } else if (k > 1) {
                      k = 1;
                    }
                    bytes[j++] = car - (car - cbr) * k | 0;
                    bytes[j++] = cag - (cag - cbg) * k | 0;
                    bytes[j++] = cab - (cab - cbb) * k | 0;
                    bytes[j++] = 255;
                  }
                }
              }
              function drawFigure(data, figure, context) {
                const ps = figure.coords;
                const cs = figure.colors;
                let i, ii;
                switch (figure.type) {
                  case "lattice":
                    const verticesPerRow = figure.verticesPerRow;
                    const rows = Math.floor(ps.length / verticesPerRow) - 1;
                    const cols = verticesPerRow - 1;
                    for (i = 0; i < rows; i++) {
                      let q = i * verticesPerRow;
                      for (let j = 0; j < cols; j++, q++) {
                        drawTriangle(data, context, ps[q], ps[q + 1], ps[q + verticesPerRow], cs[q], cs[q + 1], cs[q + verticesPerRow]);
                        drawTriangle(data, context, ps[q + verticesPerRow + 1], ps[q + 1], ps[q + verticesPerRow], cs[q + verticesPerRow + 1], cs[q + 1], cs[q + verticesPerRow]);
                      }
                    }
                    break;
                  case "triangles":
                    for (i = 0, ii = ps.length; i < ii; i += 3) {
                      drawTriangle(data, context, ps[i], ps[i + 1], ps[i + 2], cs[i], cs[i + 1], cs[i + 2]);
                    }
                    break;
                  default:
                    throw new Error("illegal figure");
                }
              }
              class MeshShadingPattern extends BaseShadingPattern {
                constructor(IR) {
                  super();
                  this._coords = IR[2];
                  this._colors = IR[3];
                  this._figures = IR[4];
                  this._bounds = IR[5];
                  this._bbox = IR[7];
                  this._background = IR[8];
                  this.matrix = null;
                }
                _createMeshCanvas(combinedScale, backgroundColor, cachedCanvases) {
                  const EXPECTED_SCALE = 1.1;
                  const MAX_PATTERN_SIZE = 3e3;
                  const BORDER_SIZE = 2;
                  const offsetX = Math.floor(this._bounds[0]);
                  const offsetY = Math.floor(this._bounds[1]);
                  const boundsWidth = Math.ceil(this._bounds[2]) - offsetX;
                  const boundsHeight = Math.ceil(this._bounds[3]) - offsetY;
                  const width = Math.min(Math.ceil(Math.abs(boundsWidth * combinedScale[0] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);
                  const height = Math.min(Math.ceil(Math.abs(boundsHeight * combinedScale[1] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);
                  const scaleX = boundsWidth / width;
                  const scaleY = boundsHeight / height;
                  const context = {
                    coords: this._coords,
                    colors: this._colors,
                    offsetX: -offsetX,
                    offsetY: -offsetY,
                    scaleX: 1 / scaleX,
                    scaleY: 1 / scaleY
                  };
                  const paddedWidth = width + BORDER_SIZE * 2;
                  const paddedHeight = height + BORDER_SIZE * 2;
                  const tmpCanvas = cachedCanvases.getCanvas("mesh", paddedWidth, paddedHeight, false);
                  const tmpCtx = tmpCanvas.context;
                  const data = tmpCtx.createImageData(width, height);
                  if (backgroundColor) {
                    const bytes = data.data;
                    for (let i = 0, ii = bytes.length; i < ii; i += 4) {
                      bytes[i] = backgroundColor[0];
                      bytes[i + 1] = backgroundColor[1];
                      bytes[i + 2] = backgroundColor[2];
                      bytes[i + 3] = 255;
                    }
                  }
                  for (const figure of this._figures) {
                    drawFigure(data, figure, context);
                  }
                  tmpCtx.putImageData(data, BORDER_SIZE, BORDER_SIZE);
                  const canvas = tmpCanvas.canvas;
                  return {
                    canvas,
                    offsetX: offsetX - BORDER_SIZE * scaleX,
                    offsetY: offsetY - BORDER_SIZE * scaleY,
                    scaleX,
                    scaleY
                  };
                }
                getPattern(ctx, owner, inverse, pathType) {
                  applyBoundingBox(ctx, this._bbox);
                  let scale;
                  if (pathType === PathType.SHADING) {
                    scale = _util2.Util.singularValueDecompose2dScale((0, _display_utils2.getCurrentTransform)(ctx));
                  } else {
                    scale = _util2.Util.singularValueDecompose2dScale(owner.baseTransform);
                    if (this.matrix) {
                      const matrixScale = _util2.Util.singularValueDecompose2dScale(this.matrix);
                      scale = [scale[0] * matrixScale[0], scale[1] * matrixScale[1]];
                    }
                  }
                  const temporaryPatternCanvas = this._createMeshCanvas(scale, pathType === PathType.SHADING ? null : this._background, owner.cachedCanvases);
                  if (pathType !== PathType.SHADING) {
                    ctx.setTransform(...owner.baseTransform);
                    if (this.matrix) {
                      ctx.transform(...this.matrix);
                    }
                  }
                  ctx.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);
                  ctx.scale(temporaryPatternCanvas.scaleX, temporaryPatternCanvas.scaleY);
                  return ctx.createPattern(temporaryPatternCanvas.canvas, "no-repeat");
                }
              }
              class DummyShadingPattern extends BaseShadingPattern {
                getPattern() {
                  return "hotpink";
                }
              }
              function getShadingPattern(IR) {
                switch (IR[0]) {
                  case "RadialAxial":
                    return new RadialAxialShadingPattern(IR);
                  case "Mesh":
                    return new MeshShadingPattern(IR);
                  case "Dummy":
                    return new DummyShadingPattern();
                }
                throw new Error(`Unknown IR type: ${IR[0]}`);
              }
              const PaintType = {
                COLORED: 1,
                UNCOLORED: 2
              };
              class TilingPattern {
                static get MAX_PATTERN_SIZE() {
                  return (0, _util2.shadow)(this, "MAX_PATTERN_SIZE", 3e3);
                }
                constructor(IR, color, ctx, canvasGraphicsFactory, baseTransform) {
                  this.operatorList = IR[2];
                  this.matrix = IR[3] || [1, 0, 0, 1, 0, 0];
                  this.bbox = IR[4];
                  this.xstep = IR[5];
                  this.ystep = IR[6];
                  this.paintType = IR[7];
                  this.tilingType = IR[8];
                  this.color = color;
                  this.ctx = ctx;
                  this.canvasGraphicsFactory = canvasGraphicsFactory;
                  this.baseTransform = baseTransform;
                }
                createPatternCanvas(owner) {
                  const operatorList = this.operatorList;
                  const bbox = this.bbox;
                  const xstep = this.xstep;
                  const ystep = this.ystep;
                  const paintType = this.paintType;
                  const tilingType = this.tilingType;
                  const color = this.color;
                  const canvasGraphicsFactory = this.canvasGraphicsFactory;
                  (0, _util2.info)("TilingType: " + tilingType);
                  const x0 = bbox[0], y0 = bbox[1], x1 = bbox[2], y1 = bbox[3];
                  const matrixScale = _util2.Util.singularValueDecompose2dScale(this.matrix);
                  const curMatrixScale = _util2.Util.singularValueDecompose2dScale(this.baseTransform);
                  const combinedScale = [matrixScale[0] * curMatrixScale[0], matrixScale[1] * curMatrixScale[1]];
                  const dimx = this.getSizeAndScale(xstep, this.ctx.canvas.width, combinedScale[0]);
                  const dimy = this.getSizeAndScale(ystep, this.ctx.canvas.height, combinedScale[1]);
                  const tmpCanvas = owner.cachedCanvases.getCanvas("pattern", dimx.size, dimy.size, true);
                  const tmpCtx = tmpCanvas.context;
                  const graphics = canvasGraphicsFactory.createCanvasGraphics(tmpCtx);
                  graphics.groupLevel = owner.groupLevel;
                  this.setFillAndStrokeStyleToContext(graphics, paintType, color);
                  let adjustedX0 = x0;
                  let adjustedY0 = y0;
                  let adjustedX1 = x1;
                  let adjustedY1 = y1;
                  if (x0 < 0) {
                    adjustedX0 = 0;
                    adjustedX1 += Math.abs(x0);
                  }
                  if (y0 < 0) {
                    adjustedY0 = 0;
                    adjustedY1 += Math.abs(y0);
                  }
                  tmpCtx.translate(-(dimx.scale * adjustedX0), -(dimy.scale * adjustedY0));
                  graphics.transform(dimx.scale, 0, 0, dimy.scale, 0, 0);
                  tmpCtx.save();
                  this.clipBbox(graphics, adjustedX0, adjustedY0, adjustedX1, adjustedY1);
                  graphics.baseTransform = (0, _display_utils2.getCurrentTransform)(graphics.ctx);
                  graphics.executeOperatorList(operatorList);
                  graphics.endDrawing();
                  return {
                    canvas: tmpCanvas.canvas,
                    scaleX: dimx.scale,
                    scaleY: dimy.scale,
                    offsetX: adjustedX0,
                    offsetY: adjustedY0
                  };
                }
                getSizeAndScale(step, realOutputSize, scale) {
                  step = Math.abs(step);
                  const maxSize = Math.max(TilingPattern.MAX_PATTERN_SIZE, realOutputSize);
                  let size = Math.ceil(step * scale);
                  if (size >= maxSize) {
                    size = maxSize;
                  } else {
                    scale = size / step;
                  }
                  return {
                    scale,
                    size
                  };
                }
                clipBbox(graphics, x0, y0, x1, y1) {
                  const bboxWidth = x1 - x0;
                  const bboxHeight = y1 - y0;
                  graphics.ctx.rect(x0, y0, bboxWidth, bboxHeight);
                  graphics.current.updateRectMinMax((0, _display_utils2.getCurrentTransform)(graphics.ctx), [x0, y0, x1, y1]);
                  graphics.clip();
                  graphics.endPath();
                }
                setFillAndStrokeStyleToContext(graphics, paintType, color) {
                  const context = graphics.ctx, current = graphics.current;
                  switch (paintType) {
                    case PaintType.COLORED:
                      const ctx = this.ctx;
                      context.fillStyle = ctx.fillStyle;
                      context.strokeStyle = ctx.strokeStyle;
                      current.fillColor = ctx.fillStyle;
                      current.strokeColor = ctx.strokeStyle;
                      break;
                    case PaintType.UNCOLORED:
                      const cssColor = _util2.Util.makeHexColor(color[0], color[1], color[2]);
                      context.fillStyle = cssColor;
                      context.strokeStyle = cssColor;
                      current.fillColor = cssColor;
                      current.strokeColor = cssColor;
                      break;
                    default:
                      throw new _util2.FormatError(`Unsupported paint type: ${paintType}`);
                  }
                }
                getPattern(ctx, owner, inverse, pathType) {
                  let matrix = inverse;
                  if (pathType !== PathType.SHADING) {
                    matrix = _util2.Util.transform(matrix, owner.baseTransform);
                    if (this.matrix) {
                      matrix = _util2.Util.transform(matrix, this.matrix);
                    }
                  }
                  const temporaryPatternCanvas = this.createPatternCanvas(owner);
                  let domMatrix = new DOMMatrix(matrix);
                  domMatrix = domMatrix.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);
                  domMatrix = domMatrix.scale(1 / temporaryPatternCanvas.scaleX, 1 / temporaryPatternCanvas.scaleY);
                  const pattern = ctx.createPattern(temporaryPatternCanvas.canvas, "repeat");
                  try {
                    pattern.setTransform(domMatrix);
                  } catch (ex) {
                    (0, _util2.warn)(`TilingPattern.getPattern: "${ex === null || ex === void 0 ? void 0 : ex.message}".`);
                  }
                  return pattern;
                }
              }
              exports2.TilingPattern = TilingPattern;
            },
            /* 139 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.applyMaskImageData = applyMaskImageData;
              var _util2 = __w_pdfjs_require__2(1);
              function applyMaskImageData(_ref) {
                let {
                  src,
                  srcPos = 0,
                  dest,
                  destPos = 0,
                  width,
                  height,
                  inverseDecode = false
                } = _ref;
                const opaque = _util2.FeatureTest.isLittleEndian ? 4278190080 : 255;
                const [zeroMapping, oneMapping] = !inverseDecode ? [opaque, 0] : [0, opaque];
                const widthInSource = width >> 3;
                const widthRemainder = width & 7;
                const srcLength = src.length;
                dest = new Uint32Array(dest.buffer);
                for (let i = 0; i < height; i++) {
                  for (const max = srcPos + widthInSource; srcPos < max; srcPos++) {
                    const elem2 = srcPos < srcLength ? src[srcPos] : 255;
                    dest[destPos++] = elem2 & 128 ? oneMapping : zeroMapping;
                    dest[destPos++] = elem2 & 64 ? oneMapping : zeroMapping;
                    dest[destPos++] = elem2 & 32 ? oneMapping : zeroMapping;
                    dest[destPos++] = elem2 & 16 ? oneMapping : zeroMapping;
                    dest[destPos++] = elem2 & 8 ? oneMapping : zeroMapping;
                    dest[destPos++] = elem2 & 4 ? oneMapping : zeroMapping;
                    dest[destPos++] = elem2 & 2 ? oneMapping : zeroMapping;
                    dest[destPos++] = elem2 & 1 ? oneMapping : zeroMapping;
                  }
                  if (widthRemainder === 0) {
                    continue;
                  }
                  const elem = srcPos < srcLength ? src[srcPos++] : 255;
                  for (let j = 0; j < widthRemainder; j++) {
                    dest[destPos++] = elem & 1 << 7 - j ? oneMapping : zeroMapping;
                  }
                }
                return {
                  srcPos,
                  destPos
                };
              }
            },
            /* 140 */
            /***/
            (__unused_webpack_module2, exports2) => {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.GlobalWorkerOptions = void 0;
              const GlobalWorkerOptions2 = /* @__PURE__ */ Object.create(null);
              exports2.GlobalWorkerOptions = GlobalWorkerOptions2;
              GlobalWorkerOptions2.workerPort = GlobalWorkerOptions2.workerPort === void 0 ? null : GlobalWorkerOptions2.workerPort;
              GlobalWorkerOptions2.workerSrc = GlobalWorkerOptions2.workerSrc === void 0 ? "" : GlobalWorkerOptions2.workerSrc;
            },
            /* 141 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.MessageHandler = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              const CallbackKind = {
                UNKNOWN: 0,
                DATA: 1,
                ERROR: 2
              };
              const StreamKind = {
                UNKNOWN: 0,
                CANCEL: 1,
                CANCEL_COMPLETE: 2,
                CLOSE: 3,
                ENQUEUE: 4,
                ERROR: 5,
                PULL: 6,
                PULL_COMPLETE: 7,
                START_COMPLETE: 8
              };
              function wrapReason(reason) {
                if (!(reason instanceof Error || typeof reason === "object" && reason !== null)) {
                  (0, _util2.unreachable)('wrapReason: Expected "reason" to be a (possibly cloned) Error.');
                }
                switch (reason.name) {
                  case "AbortException":
                    return new _util2.AbortException(reason.message);
                  case "MissingPDFException":
                    return new _util2.MissingPDFException(reason.message);
                  case "PasswordException":
                    return new _util2.PasswordException(reason.message, reason.code);
                  case "UnexpectedResponseException":
                    return new _util2.UnexpectedResponseException(reason.message, reason.status);
                  case "UnknownErrorException":
                    return new _util2.UnknownErrorException(reason.message, reason.details);
                  default:
                    return new _util2.UnknownErrorException(reason.message, reason.toString());
                }
              }
              class MessageHandler {
                constructor(sourceName, targetName, comObj) {
                  this.sourceName = sourceName;
                  this.targetName = targetName;
                  this.comObj = comObj;
                  this.callbackId = 1;
                  this.streamId = 1;
                  this.streamSinks = /* @__PURE__ */ Object.create(null);
                  this.streamControllers = /* @__PURE__ */ Object.create(null);
                  this.callbackCapabilities = /* @__PURE__ */ Object.create(null);
                  this.actionHandler = /* @__PURE__ */ Object.create(null);
                  this._onComObjOnMessage = (event) => {
                    const data = event.data;
                    if (data.targetName !== this.sourceName) {
                      return;
                    }
                    if (data.stream) {
                      this._processStreamMessage(data);
                      return;
                    }
                    if (data.callback) {
                      const callbackId = data.callbackId;
                      const capability = this.callbackCapabilities[callbackId];
                      if (!capability) {
                        throw new Error(`Cannot resolve callback ${callbackId}`);
                      }
                      delete this.callbackCapabilities[callbackId];
                      if (data.callback === CallbackKind.DATA) {
                        capability.resolve(data.data);
                      } else if (data.callback === CallbackKind.ERROR) {
                        capability.reject(wrapReason(data.reason));
                      } else {
                        throw new Error("Unexpected callback case");
                      }
                      return;
                    }
                    const action = this.actionHandler[data.action];
                    if (!action) {
                      throw new Error(`Unknown action from worker: ${data.action}`);
                    }
                    if (data.callbackId) {
                      const cbSourceName = this.sourceName;
                      const cbTargetName = data.sourceName;
                      new Promise(function(resolve) {
                        resolve(action(data.data));
                      }).then(function(result) {
                        comObj.postMessage({
                          sourceName: cbSourceName,
                          targetName: cbTargetName,
                          callback: CallbackKind.DATA,
                          callbackId: data.callbackId,
                          data: result
                        });
                      }, function(reason) {
                        comObj.postMessage({
                          sourceName: cbSourceName,
                          targetName: cbTargetName,
                          callback: CallbackKind.ERROR,
                          callbackId: data.callbackId,
                          reason: wrapReason(reason)
                        });
                      });
                      return;
                    }
                    if (data.streamId) {
                      this._createStreamSink(data);
                      return;
                    }
                    action(data.data);
                  };
                  comObj.addEventListener("message", this._onComObjOnMessage);
                }
                on(actionName, handler) {
                  const ah = this.actionHandler;
                  if (ah[actionName]) {
                    throw new Error(`There is already an actionName called "${actionName}"`);
                  }
                  ah[actionName] = handler;
                }
                send(actionName, data, transfers) {
                  this.comObj.postMessage({
                    sourceName: this.sourceName,
                    targetName: this.targetName,
                    action: actionName,
                    data
                  }, transfers);
                }
                sendWithPromise(actionName, data, transfers) {
                  const callbackId = this.callbackId++;
                  const capability = (0, _util2.createPromiseCapability)();
                  this.callbackCapabilities[callbackId] = capability;
                  try {
                    this.comObj.postMessage({
                      sourceName: this.sourceName,
                      targetName: this.targetName,
                      action: actionName,
                      callbackId,
                      data
                    }, transfers);
                  } catch (ex) {
                    capability.reject(ex);
                  }
                  return capability.promise;
                }
                sendWithStream(actionName, data, queueingStrategy, transfers) {
                  const streamId = this.streamId++, sourceName = this.sourceName, targetName = this.targetName, comObj = this.comObj;
                  return new ReadableStream({
                    start: (controller) => {
                      const startCapability = (0, _util2.createPromiseCapability)();
                      this.streamControllers[streamId] = {
                        controller,
                        startCall: startCapability,
                        pullCall: null,
                        cancelCall: null,
                        isClosed: false
                      };
                      comObj.postMessage({
                        sourceName,
                        targetName,
                        action: actionName,
                        streamId,
                        data,
                        desiredSize: controller.desiredSize
                      }, transfers);
                      return startCapability.promise;
                    },
                    pull: (controller) => {
                      const pullCapability = (0, _util2.createPromiseCapability)();
                      this.streamControllers[streamId].pullCall = pullCapability;
                      comObj.postMessage({
                        sourceName,
                        targetName,
                        stream: StreamKind.PULL,
                        streamId,
                        desiredSize: controller.desiredSize
                      });
                      return pullCapability.promise;
                    },
                    cancel: (reason) => {
                      (0, _util2.assert)(reason instanceof Error, "cancel must have a valid reason");
                      const cancelCapability = (0, _util2.createPromiseCapability)();
                      this.streamControllers[streamId].cancelCall = cancelCapability;
                      this.streamControllers[streamId].isClosed = true;
                      comObj.postMessage({
                        sourceName,
                        targetName,
                        stream: StreamKind.CANCEL,
                        streamId,
                        reason: wrapReason(reason)
                      });
                      return cancelCapability.promise;
                    }
                  }, queueingStrategy);
                }
                _createStreamSink(data) {
                  const streamId = data.streamId, sourceName = this.sourceName, targetName = data.sourceName, comObj = this.comObj;
                  const self2 = this, action = this.actionHandler[data.action];
                  const streamSink = {
                    enqueue(chunk) {
                      let size = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
                      let transfers = arguments.length > 2 ? arguments[2] : void 0;
                      if (this.isCancelled) {
                        return;
                      }
                      const lastDesiredSize = this.desiredSize;
                      this.desiredSize -= size;
                      if (lastDesiredSize > 0 && this.desiredSize <= 0) {
                        this.sinkCapability = (0, _util2.createPromiseCapability)();
                        this.ready = this.sinkCapability.promise;
                      }
                      comObj.postMessage({
                        sourceName,
                        targetName,
                        stream: StreamKind.ENQUEUE,
                        streamId,
                        chunk
                      }, transfers);
                    },
                    close() {
                      if (this.isCancelled) {
                        return;
                      }
                      this.isCancelled = true;
                      comObj.postMessage({
                        sourceName,
                        targetName,
                        stream: StreamKind.CLOSE,
                        streamId
                      });
                      delete self2.streamSinks[streamId];
                    },
                    error(reason) {
                      (0, _util2.assert)(reason instanceof Error, "error must have a valid reason");
                      if (this.isCancelled) {
                        return;
                      }
                      this.isCancelled = true;
                      comObj.postMessage({
                        sourceName,
                        targetName,
                        stream: StreamKind.ERROR,
                        streamId,
                        reason: wrapReason(reason)
                      });
                    },
                    sinkCapability: (0, _util2.createPromiseCapability)(),
                    onPull: null,
                    onCancel: null,
                    isCancelled: false,
                    desiredSize: data.desiredSize,
                    ready: null
                  };
                  streamSink.sinkCapability.resolve();
                  streamSink.ready = streamSink.sinkCapability.promise;
                  this.streamSinks[streamId] = streamSink;
                  new Promise(function(resolve) {
                    resolve(action(data.data, streamSink));
                  }).then(function() {
                    comObj.postMessage({
                      sourceName,
                      targetName,
                      stream: StreamKind.START_COMPLETE,
                      streamId,
                      success: true
                    });
                  }, function(reason) {
                    comObj.postMessage({
                      sourceName,
                      targetName,
                      stream: StreamKind.START_COMPLETE,
                      streamId,
                      reason: wrapReason(reason)
                    });
                  });
                }
                _processStreamMessage(data) {
                  const streamId = data.streamId, sourceName = this.sourceName, targetName = data.sourceName, comObj = this.comObj;
                  const streamController = this.streamControllers[streamId], streamSink = this.streamSinks[streamId];
                  switch (data.stream) {
                    case StreamKind.START_COMPLETE:
                      if (data.success) {
                        streamController.startCall.resolve();
                      } else {
                        streamController.startCall.reject(wrapReason(data.reason));
                      }
                      break;
                    case StreamKind.PULL_COMPLETE:
                      if (data.success) {
                        streamController.pullCall.resolve();
                      } else {
                        streamController.pullCall.reject(wrapReason(data.reason));
                      }
                      break;
                    case StreamKind.PULL:
                      if (!streamSink) {
                        comObj.postMessage({
                          sourceName,
                          targetName,
                          stream: StreamKind.PULL_COMPLETE,
                          streamId,
                          success: true
                        });
                        break;
                      }
                      if (streamSink.desiredSize <= 0 && data.desiredSize > 0) {
                        streamSink.sinkCapability.resolve();
                      }
                      streamSink.desiredSize = data.desiredSize;
                      new Promise(function(resolve) {
                        resolve(streamSink.onPull && streamSink.onPull());
                      }).then(function() {
                        comObj.postMessage({
                          sourceName,
                          targetName,
                          stream: StreamKind.PULL_COMPLETE,
                          streamId,
                          success: true
                        });
                      }, function(reason) {
                        comObj.postMessage({
                          sourceName,
                          targetName,
                          stream: StreamKind.PULL_COMPLETE,
                          streamId,
                          reason: wrapReason(reason)
                        });
                      });
                      break;
                    case StreamKind.ENQUEUE:
                      (0, _util2.assert)(streamController, "enqueue should have stream controller");
                      if (streamController.isClosed) {
                        break;
                      }
                      streamController.controller.enqueue(data.chunk);
                      break;
                    case StreamKind.CLOSE:
                      (0, _util2.assert)(streamController, "close should have stream controller");
                      if (streamController.isClosed) {
                        break;
                      }
                      streamController.isClosed = true;
                      streamController.controller.close();
                      this._deleteStreamController(streamController, streamId);
                      break;
                    case StreamKind.ERROR:
                      (0, _util2.assert)(streamController, "error should have stream controller");
                      streamController.controller.error(wrapReason(data.reason));
                      this._deleteStreamController(streamController, streamId);
                      break;
                    case StreamKind.CANCEL_COMPLETE:
                      if (data.success) {
                        streamController.cancelCall.resolve();
                      } else {
                        streamController.cancelCall.reject(wrapReason(data.reason));
                      }
                      this._deleteStreamController(streamController, streamId);
                      break;
                    case StreamKind.CANCEL:
                      if (!streamSink) {
                        break;
                      }
                      new Promise(function(resolve) {
                        resolve(streamSink.onCancel && streamSink.onCancel(wrapReason(data.reason)));
                      }).then(function() {
                        comObj.postMessage({
                          sourceName,
                          targetName,
                          stream: StreamKind.CANCEL_COMPLETE,
                          streamId,
                          success: true
                        });
                      }, function(reason) {
                        comObj.postMessage({
                          sourceName,
                          targetName,
                          stream: StreamKind.CANCEL_COMPLETE,
                          streamId,
                          reason: wrapReason(reason)
                        });
                      });
                      streamSink.sinkCapability.reject(wrapReason(data.reason));
                      streamSink.isCancelled = true;
                      delete this.streamSinks[streamId];
                      break;
                    default:
                      throw new Error("Unexpected stream case");
                  }
                }
                async _deleteStreamController(streamController, streamId) {
                  await Promise.allSettled([streamController.startCall && streamController.startCall.promise, streamController.pullCall && streamController.pullCall.promise, streamController.cancelCall && streamController.cancelCall.promise]);
                  delete this.streamControllers[streamId];
                }
                destroy() {
                  this.comObj.removeEventListener("message", this._onComObjOnMessage);
                }
              }
              exports2.MessageHandler = MessageHandler;
            },
            /* 142 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.Metadata = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              function _classPrivateFieldInitSpec2(obj, privateMap, value) {
                _checkPrivateRedeclaration2(obj, privateMap);
                privateMap.set(obj, value);
              }
              function _checkPrivateRedeclaration2(obj, privateCollection) {
                if (privateCollection.has(obj)) {
                  throw new TypeError("Cannot initialize the same private elements twice on an object");
                }
              }
              function _classPrivateFieldGet2(receiver, privateMap) {
                var descriptor = _classExtractFieldDescriptor2(receiver, privateMap, "get");
                return _classApplyDescriptorGet2(receiver, descriptor);
              }
              function _classApplyDescriptorGet2(receiver, descriptor) {
                if (descriptor.get) {
                  return descriptor.get.call(receiver);
                }
                return descriptor.value;
              }
              function _classPrivateFieldSet2(receiver, privateMap, value) {
                var descriptor = _classExtractFieldDescriptor2(receiver, privateMap, "set");
                _classApplyDescriptorSet2(receiver, descriptor, value);
                return value;
              }
              function _classExtractFieldDescriptor2(receiver, privateMap, action) {
                if (!privateMap.has(receiver)) {
                  throw new TypeError("attempted to " + action + " private field on non-instance");
                }
                return privateMap.get(receiver);
              }
              function _classApplyDescriptorSet2(receiver, descriptor, value) {
                if (descriptor.set) {
                  descriptor.set.call(receiver, value);
                } else {
                  if (!descriptor.writable) {
                    throw new TypeError("attempted to set read only private field");
                  }
                  descriptor.value = value;
                }
              }
              var _metadataMap = /* @__PURE__ */ new WeakMap();
              var _data = /* @__PURE__ */ new WeakMap();
              class Metadata {
                constructor(_ref) {
                  let {
                    parsedData,
                    rawData
                  } = _ref;
                  _classPrivateFieldInitSpec2(this, _metadataMap, {
                    writable: true,
                    value: void 0
                  });
                  _classPrivateFieldInitSpec2(this, _data, {
                    writable: true,
                    value: void 0
                  });
                  _classPrivateFieldSet2(this, _metadataMap, parsedData);
                  _classPrivateFieldSet2(this, _data, rawData);
                }
                getRaw() {
                  return _classPrivateFieldGet2(this, _data);
                }
                get(name) {
                  var _classPrivateFieldGet22;
                  return (_classPrivateFieldGet22 = _classPrivateFieldGet2(this, _metadataMap).get(name)) !== null && _classPrivateFieldGet22 !== void 0 ? _classPrivateFieldGet22 : null;
                }
                getAll() {
                  return (0, _util2.objectFromMap)(_classPrivateFieldGet2(this, _metadataMap));
                }
                has(name) {
                  return _classPrivateFieldGet2(this, _metadataMap).has(name);
                }
              }
              exports2.Metadata = Metadata;
            },
            /* 143 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.OptionalContentConfig = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              function _classPrivateMethodInitSpec2(obj, privateSet) {
                _checkPrivateRedeclaration2(obj, privateSet);
                privateSet.add(obj);
              }
              function _classPrivateMethodGet2(receiver, privateSet, fn) {
                if (!privateSet.has(receiver)) {
                  throw new TypeError("attempted to get private field on non-instance");
                }
                return fn;
              }
              function _classPrivateFieldInitSpec2(obj, privateMap, value) {
                _checkPrivateRedeclaration2(obj, privateMap);
                privateMap.set(obj, value);
              }
              function _checkPrivateRedeclaration2(obj, privateCollection) {
                if (privateCollection.has(obj)) {
                  throw new TypeError("Cannot initialize the same private elements twice on an object");
                }
              }
              function _classPrivateFieldSet2(receiver, privateMap, value) {
                var descriptor = _classExtractFieldDescriptor2(receiver, privateMap, "set");
                _classApplyDescriptorSet2(receiver, descriptor, value);
                return value;
              }
              function _classApplyDescriptorSet2(receiver, descriptor, value) {
                if (descriptor.set) {
                  descriptor.set.call(receiver, value);
                } else {
                  if (!descriptor.writable) {
                    throw new TypeError("attempted to set read only private field");
                  }
                  descriptor.value = value;
                }
              }
              function _classPrivateFieldGet2(receiver, privateMap) {
                var descriptor = _classExtractFieldDescriptor2(receiver, privateMap, "get");
                return _classApplyDescriptorGet2(receiver, descriptor);
              }
              function _classExtractFieldDescriptor2(receiver, privateMap, action) {
                if (!privateMap.has(receiver)) {
                  throw new TypeError("attempted to " + action + " private field on non-instance");
                }
                return privateMap.get(receiver);
              }
              function _classApplyDescriptorGet2(receiver, descriptor) {
                if (descriptor.get) {
                  return descriptor.get.call(receiver);
                }
                return descriptor.value;
              }
              const INTERNAL = Symbol("INTERNAL");
              var _visible = /* @__PURE__ */ new WeakMap();
              class OptionalContentGroup {
                constructor(name, intent) {
                  _classPrivateFieldInitSpec2(this, _visible, {
                    writable: true,
                    value: true
                  });
                  this.name = name;
                  this.intent = intent;
                }
                get visible() {
                  return _classPrivateFieldGet2(this, _visible);
                }
                _setVisible(internal, visible) {
                  if (internal !== INTERNAL) {
                    (0, _util2.unreachable)("Internal method `_setVisible` called.");
                  }
                  _classPrivateFieldSet2(this, _visible, visible);
                }
              }
              var _cachedHasInitialVisibility = /* @__PURE__ */ new WeakMap();
              var _groups = /* @__PURE__ */ new WeakMap();
              var _initialVisibility = /* @__PURE__ */ new WeakMap();
              var _order = /* @__PURE__ */ new WeakMap();
              var _evaluateVisibilityExpression = /* @__PURE__ */ new WeakSet();
              class OptionalContentConfig {
                constructor(data) {
                  _classPrivateMethodInitSpec2(this, _evaluateVisibilityExpression);
                  _classPrivateFieldInitSpec2(this, _cachedHasInitialVisibility, {
                    writable: true,
                    value: true
                  });
                  _classPrivateFieldInitSpec2(this, _groups, {
                    writable: true,
                    value: /* @__PURE__ */ new Map()
                  });
                  _classPrivateFieldInitSpec2(this, _initialVisibility, {
                    writable: true,
                    value: null
                  });
                  _classPrivateFieldInitSpec2(this, _order, {
                    writable: true,
                    value: null
                  });
                  this.name = null;
                  this.creator = null;
                  if (data === null) {
                    return;
                  }
                  this.name = data.name;
                  this.creator = data.creator;
                  _classPrivateFieldSet2(this, _order, data.order);
                  for (const group of data.groups) {
                    _classPrivateFieldGet2(this, _groups).set(group.id, new OptionalContentGroup(group.name, group.intent));
                  }
                  if (data.baseState === "OFF") {
                    for (const group of _classPrivateFieldGet2(this, _groups).values()) {
                      group._setVisible(INTERNAL, false);
                    }
                  }
                  for (const on of data.on) {
                    _classPrivateFieldGet2(this, _groups).get(on)._setVisible(INTERNAL, true);
                  }
                  for (const off of data.off) {
                    _classPrivateFieldGet2(this, _groups).get(off)._setVisible(INTERNAL, false);
                  }
                  _classPrivateFieldSet2(this, _initialVisibility, /* @__PURE__ */ new Map());
                  for (const [id, group] of _classPrivateFieldGet2(this, _groups)) {
                    _classPrivateFieldGet2(this, _initialVisibility).set(id, group.visible);
                  }
                }
                isVisible(group) {
                  if (_classPrivateFieldGet2(this, _groups).size === 0) {
                    return true;
                  }
                  if (!group) {
                    (0, _util2.warn)("Optional content group not defined.");
                    return true;
                  }
                  if (group.type === "OCG") {
                    if (!_classPrivateFieldGet2(this, _groups).has(group.id)) {
                      (0, _util2.warn)(`Optional content group not found: ${group.id}`);
                      return true;
                    }
                    return _classPrivateFieldGet2(this, _groups).get(group.id).visible;
                  } else if (group.type === "OCMD") {
                    if (group.expression) {
                      return _classPrivateMethodGet2(this, _evaluateVisibilityExpression, _evaluateVisibilityExpression2).call(this, group.expression);
                    }
                    if (!group.policy || group.policy === "AnyOn") {
                      for (const id of group.ids) {
                        if (!_classPrivateFieldGet2(this, _groups).has(id)) {
                          (0, _util2.warn)(`Optional content group not found: ${id}`);
                          return true;
                        }
                        if (_classPrivateFieldGet2(this, _groups).get(id).visible) {
                          return true;
                        }
                      }
                      return false;
                    } else if (group.policy === "AllOn") {
                      for (const id of group.ids) {
                        if (!_classPrivateFieldGet2(this, _groups).has(id)) {
                          (0, _util2.warn)(`Optional content group not found: ${id}`);
                          return true;
                        }
                        if (!_classPrivateFieldGet2(this, _groups).get(id).visible) {
                          return false;
                        }
                      }
                      return true;
                    } else if (group.policy === "AnyOff") {
                      for (const id of group.ids) {
                        if (!_classPrivateFieldGet2(this, _groups).has(id)) {
                          (0, _util2.warn)(`Optional content group not found: ${id}`);
                          return true;
                        }
                        if (!_classPrivateFieldGet2(this, _groups).get(id).visible) {
                          return true;
                        }
                      }
                      return false;
                    } else if (group.policy === "AllOff") {
                      for (const id of group.ids) {
                        if (!_classPrivateFieldGet2(this, _groups).has(id)) {
                          (0, _util2.warn)(`Optional content group not found: ${id}`);
                          return true;
                        }
                        if (_classPrivateFieldGet2(this, _groups).get(id).visible) {
                          return false;
                        }
                      }
                      return true;
                    }
                    (0, _util2.warn)(`Unknown optional content policy ${group.policy}.`);
                    return true;
                  }
                  (0, _util2.warn)(`Unknown group type ${group.type}.`);
                  return true;
                }
                setVisibility(id) {
                  let visible = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
                  if (!_classPrivateFieldGet2(this, _groups).has(id)) {
                    (0, _util2.warn)(`Optional content group not found: ${id}`);
                    return;
                  }
                  _classPrivateFieldGet2(this, _groups).get(id)._setVisible(INTERNAL, !!visible);
                  _classPrivateFieldSet2(this, _cachedHasInitialVisibility, null);
                }
                get hasInitialVisibility() {
                  if (_classPrivateFieldGet2(this, _cachedHasInitialVisibility) !== null) {
                    return _classPrivateFieldGet2(this, _cachedHasInitialVisibility);
                  }
                  for (const [id, group] of _classPrivateFieldGet2(this, _groups)) {
                    const visible = _classPrivateFieldGet2(this, _initialVisibility).get(id);
                    if (group.visible !== visible) {
                      return _classPrivateFieldSet2(this, _cachedHasInitialVisibility, false);
                    }
                  }
                  return _classPrivateFieldSet2(this, _cachedHasInitialVisibility, true);
                }
                getOrder() {
                  if (!_classPrivateFieldGet2(this, _groups).size) {
                    return null;
                  }
                  if (_classPrivateFieldGet2(this, _order)) {
                    return _classPrivateFieldGet2(this, _order).slice();
                  }
                  return [..._classPrivateFieldGet2(this, _groups).keys()];
                }
                getGroups() {
                  return _classPrivateFieldGet2(this, _groups).size > 0 ? (0, _util2.objectFromMap)(_classPrivateFieldGet2(this, _groups)) : null;
                }
                getGroup(id) {
                  return _classPrivateFieldGet2(this, _groups).get(id) || null;
                }
              }
              exports2.OptionalContentConfig = OptionalContentConfig;
              function _evaluateVisibilityExpression2(array) {
                const length = array.length;
                if (length < 2) {
                  return true;
                }
                const operator = array[0];
                for (let i = 1; i < length; i++) {
                  const element = array[i];
                  let state;
                  if (Array.isArray(element)) {
                    state = _classPrivateMethodGet2(this, _evaluateVisibilityExpression, _evaluateVisibilityExpression2).call(this, element);
                  } else if (_classPrivateFieldGet2(this, _groups).has(element)) {
                    state = _classPrivateFieldGet2(this, _groups).get(element).visible;
                  } else {
                    (0, _util2.warn)(`Optional content group not found: ${element}`);
                    return true;
                  }
                  switch (operator) {
                    case "And":
                      if (!state) {
                        return false;
                      }
                      break;
                    case "Or":
                      if (state) {
                        return true;
                      }
                      break;
                    case "Not":
                      return !state;
                    default:
                      return true;
                  }
                }
                return operator === "And";
              }
            },
            /* 144 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.PDFDataTransportStream = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              var _display_utils2 = __w_pdfjs_require__2(133);
              class PDFDataTransportStream {
                constructor(params, pdfDataRangeTransport) {
                  (0, _util2.assert)(pdfDataRangeTransport, 'PDFDataTransportStream - missing required "pdfDataRangeTransport" argument.');
                  this._queuedChunks = [];
                  this._progressiveDone = params.progressiveDone || false;
                  this._contentDispositionFilename = params.contentDispositionFilename || null;
                  const initialData = params.initialData;
                  if ((initialData === null || initialData === void 0 ? void 0 : initialData.length) > 0) {
                    const buffer = new Uint8Array(initialData).buffer;
                    this._queuedChunks.push(buffer);
                  }
                  this._pdfDataRangeTransport = pdfDataRangeTransport;
                  this._isStreamingSupported = !params.disableStream;
                  this._isRangeSupported = !params.disableRange;
                  this._contentLength = params.length;
                  this._fullRequestReader = null;
                  this._rangeReaders = [];
                  this._pdfDataRangeTransport.addRangeListener((begin, chunk) => {
                    this._onReceiveData({
                      begin,
                      chunk
                    });
                  });
                  this._pdfDataRangeTransport.addProgressListener((loaded, total) => {
                    this._onProgress({
                      loaded,
                      total
                    });
                  });
                  this._pdfDataRangeTransport.addProgressiveReadListener((chunk) => {
                    this._onReceiveData({
                      chunk
                    });
                  });
                  this._pdfDataRangeTransport.addProgressiveDoneListener(() => {
                    this._onProgressiveDone();
                  });
                  this._pdfDataRangeTransport.transportReady();
                }
                _onReceiveData(args) {
                  const buffer = new Uint8Array(args.chunk).buffer;
                  if (args.begin === void 0) {
                    if (this._fullRequestReader) {
                      this._fullRequestReader._enqueue(buffer);
                    } else {
                      this._queuedChunks.push(buffer);
                    }
                  } else {
                    const found = this._rangeReaders.some(function(rangeReader) {
                      if (rangeReader._begin !== args.begin) {
                        return false;
                      }
                      rangeReader._enqueue(buffer);
                      return true;
                    });
                    (0, _util2.assert)(found, "_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.");
                  }
                }
                get _progressiveDataLength() {
                  var _this$_fullRequestRea, _this$_fullRequestRea2;
                  return (_this$_fullRequestRea = (_this$_fullRequestRea2 = this._fullRequestReader) === null || _this$_fullRequestRea2 === void 0 ? void 0 : _this$_fullRequestRea2._loaded) !== null && _this$_fullRequestRea !== void 0 ? _this$_fullRequestRea : 0;
                }
                _onProgress(evt) {
                  if (evt.total === void 0) {
                    const firstReader = this._rangeReaders[0];
                    if (firstReader !== null && firstReader !== void 0 && firstReader.onProgress) {
                      firstReader.onProgress({
                        loaded: evt.loaded
                      });
                    }
                  } else {
                    const fullReader = this._fullRequestReader;
                    if (fullReader !== null && fullReader !== void 0 && fullReader.onProgress) {
                      fullReader.onProgress({
                        loaded: evt.loaded,
                        total: evt.total
                      });
                    }
                  }
                }
                _onProgressiveDone() {
                  if (this._fullRequestReader) {
                    this._fullRequestReader.progressiveDone();
                  }
                  this._progressiveDone = true;
                }
                _removeRangeReader(reader) {
                  const i = this._rangeReaders.indexOf(reader);
                  if (i >= 0) {
                    this._rangeReaders.splice(i, 1);
                  }
                }
                getFullReader() {
                  (0, _util2.assert)(!this._fullRequestReader, "PDFDataTransportStream.getFullReader can only be called once.");
                  const queuedChunks = this._queuedChunks;
                  this._queuedChunks = null;
                  return new PDFDataTransportStreamReader(this, queuedChunks, this._progressiveDone, this._contentDispositionFilename);
                }
                getRangeReader(begin, end) {
                  if (end <= this._progressiveDataLength) {
                    return null;
                  }
                  const reader = new PDFDataTransportStreamRangeReader(this, begin, end);
                  this._pdfDataRangeTransport.requestDataRange(begin, end);
                  this._rangeReaders.push(reader);
                  return reader;
                }
                cancelAllRequests(reason) {
                  if (this._fullRequestReader) {
                    this._fullRequestReader.cancel(reason);
                  }
                  for (const reader of this._rangeReaders.slice(0)) {
                    reader.cancel(reason);
                  }
                  this._pdfDataRangeTransport.abort();
                }
              }
              exports2.PDFDataTransportStream = PDFDataTransportStream;
              class PDFDataTransportStreamReader {
                constructor(stream, queuedChunks) {
                  let progressiveDone = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                  let contentDispositionFilename = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
                  this._stream = stream;
                  this._done = progressiveDone || false;
                  this._filename = (0, _display_utils2.isPdfFile)(contentDispositionFilename) ? contentDispositionFilename : null;
                  this._queuedChunks = queuedChunks || [];
                  this._loaded = 0;
                  for (const chunk of this._queuedChunks) {
                    this._loaded += chunk.byteLength;
                  }
                  this._requests = [];
                  this._headersReady = Promise.resolve();
                  stream._fullRequestReader = this;
                  this.onProgress = null;
                }
                _enqueue(chunk) {
                  if (this._done) {
                    return;
                  }
                  if (this._requests.length > 0) {
                    const requestCapability = this._requests.shift();
                    requestCapability.resolve({
                      value: chunk,
                      done: false
                    });
                  } else {
                    this._queuedChunks.push(chunk);
                  }
                  this._loaded += chunk.byteLength;
                }
                get headersReady() {
                  return this._headersReady;
                }
                get filename() {
                  return this._filename;
                }
                get isRangeSupported() {
                  return this._stream._isRangeSupported;
                }
                get isStreamingSupported() {
                  return this._stream._isStreamingSupported;
                }
                get contentLength() {
                  return this._stream._contentLength;
                }
                async read() {
                  if (this._queuedChunks.length > 0) {
                    const chunk = this._queuedChunks.shift();
                    return {
                      value: chunk,
                      done: false
                    };
                  }
                  if (this._done) {
                    return {
                      value: void 0,
                      done: true
                    };
                  }
                  const requestCapability = (0, _util2.createPromiseCapability)();
                  this._requests.push(requestCapability);
                  return requestCapability.promise;
                }
                cancel(reason) {
                  this._done = true;
                  for (const requestCapability of this._requests) {
                    requestCapability.resolve({
                      value: void 0,
                      done: true
                    });
                  }
                  this._requests.length = 0;
                }
                progressiveDone() {
                  if (this._done) {
                    return;
                  }
                  this._done = true;
                }
              }
              class PDFDataTransportStreamRangeReader {
                constructor(stream, begin, end) {
                  this._stream = stream;
                  this._begin = begin;
                  this._end = end;
                  this._queuedChunk = null;
                  this._requests = [];
                  this._done = false;
                  this.onProgress = null;
                }
                _enqueue(chunk) {
                  if (this._done) {
                    return;
                  }
                  if (this._requests.length === 0) {
                    this._queuedChunk = chunk;
                  } else {
                    const requestsCapability = this._requests.shift();
                    requestsCapability.resolve({
                      value: chunk,
                      done: false
                    });
                    for (const requestCapability of this._requests) {
                      requestCapability.resolve({
                        value: void 0,
                        done: true
                      });
                    }
                    this._requests.length = 0;
                  }
                  this._done = true;
                  this._stream._removeRangeReader(this);
                }
                get isStreamingSupported() {
                  return false;
                }
                async read() {
                  if (this._queuedChunk) {
                    const chunk = this._queuedChunk;
                    this._queuedChunk = null;
                    return {
                      value: chunk,
                      done: false
                    };
                  }
                  if (this._done) {
                    return {
                      value: void 0,
                      done: true
                    };
                  }
                  const requestCapability = (0, _util2.createPromiseCapability)();
                  this._requests.push(requestCapability);
                  return requestCapability.promise;
                }
                cancel(reason) {
                  this._done = true;
                  for (const requestCapability of this._requests) {
                    requestCapability.resolve({
                      value: void 0,
                      done: true
                    });
                  }
                  this._requests.length = 0;
                  this._stream._removeRangeReader(this);
                }
              }
            },
            /* 145 */
            /***/
            (__unused_webpack_module2, exports2) => {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.XfaText = void 0;
              class XfaText {
                static textContent(xfa) {
                  const items = [];
                  const output = {
                    items,
                    styles: /* @__PURE__ */ Object.create(null)
                  };
                  function walk(node) {
                    var _node$attributes;
                    if (!node) {
                      return;
                    }
                    let str = null;
                    const name = node.name;
                    if (name === "#text") {
                      str = node.value;
                    } else if (!XfaText.shouldBuildText(name)) {
                      return;
                    } else if (node !== null && node !== void 0 && (_node$attributes = node.attributes) !== null && _node$attributes !== void 0 && _node$attributes.textContent) {
                      str = node.attributes.textContent;
                    } else if (node.value) {
                      str = node.value;
                    }
                    if (str !== null) {
                      items.push({
                        str
                      });
                    }
                    if (!node.children) {
                      return;
                    }
                    for (const child of node.children) {
                      walk(child);
                    }
                  }
                  walk(xfa);
                  return output;
                }
                static shouldBuildText(name) {
                  return !(name === "textarea" || name === "input" || name === "option" || name === "select");
                }
              }
              exports2.XfaText = XfaText;
            },
            /* 146 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.NodeStandardFontDataFactory = exports2.NodeCanvasFactory = exports2.NodeCMapReaderFactory = void 0;
              var _base_factory = __w_pdfjs_require__2(134);
              ;
              const fetchData = function(url) {
                return new Promise((resolve, reject) => {
                  const fs = require_fs();
                  fs.readFile(url, (error, data) => {
                    if (error || !data) {
                      reject(new Error(error));
                      return;
                    }
                    resolve(new Uint8Array(data));
                  });
                });
              };
              class NodeCanvasFactory extends _base_factory.BaseCanvasFactory {
                _createCanvas(width, height) {
                  const Canvas = require_canvas();
                  return Canvas.createCanvas(width, height);
                }
              }
              exports2.NodeCanvasFactory = NodeCanvasFactory;
              class NodeCMapReaderFactory extends _base_factory.BaseCMapReaderFactory {
                _fetchData(url, compressionType) {
                  return fetchData(url).then((data) => {
                    return {
                      cMapData: data,
                      compressionType
                    };
                  });
                }
              }
              exports2.NodeCMapReaderFactory = NodeCMapReaderFactory;
              class NodeStandardFontDataFactory extends _base_factory.BaseStandardFontDataFactory {
                _fetchData(url) {
                  return fetchData(url);
                }
              }
              exports2.NodeStandardFontDataFactory = NodeStandardFontDataFactory;
            },
            /* 147 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.AnnotationEditorLayer = void 0;
              var _tools = __w_pdfjs_require__2(132);
              var _util2 = __w_pdfjs_require__2(1);
              var _freetext = __w_pdfjs_require__2(148);
              var _ink = __w_pdfjs_require__2(149);
              function _classPrivateMethodInitSpec2(obj, privateSet) {
                _checkPrivateRedeclaration2(obj, privateSet);
                privateSet.add(obj);
              }
              function _defineProperty(obj, key, value) {
                if (key in obj) {
                  Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
                } else {
                  obj[key] = value;
                }
                return obj;
              }
              function _classPrivateFieldInitSpec2(obj, privateMap, value) {
                _checkPrivateRedeclaration2(obj, privateMap);
                privateMap.set(obj, value);
              }
              function _checkPrivateRedeclaration2(obj, privateCollection) {
                if (privateCollection.has(obj)) {
                  throw new TypeError("Cannot initialize the same private elements twice on an object");
                }
              }
              function _classPrivateMethodGet2(receiver, privateSet, fn) {
                if (!privateSet.has(receiver)) {
                  throw new TypeError("attempted to get private field on non-instance");
                }
                return fn;
              }
              function _classPrivateFieldGet2(receiver, privateMap) {
                var descriptor = _classExtractFieldDescriptor2(receiver, privateMap, "get");
                return _classApplyDescriptorGet2(receiver, descriptor);
              }
              function _classApplyDescriptorGet2(receiver, descriptor) {
                if (descriptor.get) {
                  return descriptor.get.call(receiver);
                }
                return descriptor.value;
              }
              function _classPrivateFieldSet2(receiver, privateMap, value) {
                var descriptor = _classExtractFieldDescriptor2(receiver, privateMap, "set");
                _classApplyDescriptorSet2(receiver, descriptor, value);
                return value;
              }
              function _classExtractFieldDescriptor2(receiver, privateMap, action) {
                if (!privateMap.has(receiver)) {
                  throw new TypeError("attempted to " + action + " private field on non-instance");
                }
                return privateMap.get(receiver);
              }
              function _classApplyDescriptorSet2(receiver, descriptor, value) {
                if (descriptor.set) {
                  descriptor.set.call(receiver, value);
                } else {
                  if (!descriptor.writable) {
                    throw new TypeError("attempted to set read only private field");
                  }
                  descriptor.value = value;
                }
              }
              var _accessibilityManager = /* @__PURE__ */ new WeakMap();
              var _allowClick = /* @__PURE__ */ new WeakMap();
              var _boundPointerup = /* @__PURE__ */ new WeakMap();
              var _boundPointerdown = /* @__PURE__ */ new WeakMap();
              var _editors = /* @__PURE__ */ new WeakMap();
              var _hadPointerDown = /* @__PURE__ */ new WeakMap();
              var _isCleaningUp = /* @__PURE__ */ new WeakMap();
              var _uiManager = /* @__PURE__ */ new WeakMap();
              var _changeParent = /* @__PURE__ */ new WeakSet();
              var _createNewEditor = /* @__PURE__ */ new WeakSet();
              var _createAndAddNewEditor = /* @__PURE__ */ new WeakSet();
              var _cleanup = /* @__PURE__ */ new WeakSet();
              class AnnotationEditorLayer {
                constructor(options) {
                  _classPrivateMethodInitSpec2(this, _cleanup);
                  _classPrivateMethodInitSpec2(this, _createAndAddNewEditor);
                  _classPrivateMethodInitSpec2(this, _createNewEditor);
                  _classPrivateMethodInitSpec2(this, _changeParent);
                  _classPrivateFieldInitSpec2(this, _accessibilityManager, {
                    writable: true,
                    value: void 0
                  });
                  _classPrivateFieldInitSpec2(this, _allowClick, {
                    writable: true,
                    value: false
                  });
                  _classPrivateFieldInitSpec2(this, _boundPointerup, {
                    writable: true,
                    value: this.pointerup.bind(this)
                  });
                  _classPrivateFieldInitSpec2(this, _boundPointerdown, {
                    writable: true,
                    value: this.pointerdown.bind(this)
                  });
                  _classPrivateFieldInitSpec2(this, _editors, {
                    writable: true,
                    value: /* @__PURE__ */ new Map()
                  });
                  _classPrivateFieldInitSpec2(this, _hadPointerDown, {
                    writable: true,
                    value: false
                  });
                  _classPrivateFieldInitSpec2(this, _isCleaningUp, {
                    writable: true,
                    value: false
                  });
                  _classPrivateFieldInitSpec2(this, _uiManager, {
                    writable: true,
                    value: void 0
                  });
                  if (!AnnotationEditorLayer._initialized) {
                    AnnotationEditorLayer._initialized = true;
                    _freetext.FreeTextEditor.initialize(options.l10n);
                    _ink.InkEditor.initialize(options.l10n);
                    options.uiManager.registerEditorTypes([_freetext.FreeTextEditor, _ink.InkEditor]);
                  }
                  _classPrivateFieldSet2(this, _uiManager, options.uiManager);
                  this.annotationStorage = options.annotationStorage;
                  this.pageIndex = options.pageIndex;
                  this.div = options.div;
                  _classPrivateFieldSet2(this, _accessibilityManager, options.accessibilityManager);
                  _classPrivateFieldGet2(this, _uiManager).addLayer(this);
                }
                updateToolbar(mode) {
                  _classPrivateFieldGet2(this, _uiManager).updateToolbar(mode);
                }
                updateMode() {
                  let mode = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : _classPrivateFieldGet2(this, _uiManager).getMode();
                  _classPrivateMethodGet2(this, _cleanup, _cleanup2).call(this);
                  if (mode === _util2.AnnotationEditorType.INK) {
                    this.addInkEditorIfNeeded(false);
                    this.disableClick();
                  } else {
                    this.enableClick();
                  }
                  _classPrivateFieldGet2(this, _uiManager).unselectAll();
                }
                addInkEditorIfNeeded(isCommitting) {
                  if (!isCommitting && _classPrivateFieldGet2(this, _uiManager).getMode() !== _util2.AnnotationEditorType.INK) {
                    return;
                  }
                  if (!isCommitting) {
                    for (const editor2 of _classPrivateFieldGet2(this, _editors).values()) {
                      if (editor2.isEmpty()) {
                        editor2.setInBackground();
                        return;
                      }
                    }
                  }
                  const editor = _classPrivateMethodGet2(this, _createAndAddNewEditor, _createAndAddNewEditor2).call(this, {
                    offsetX: 0,
                    offsetY: 0
                  });
                  editor.setInBackground();
                }
                setEditingState(isEditing) {
                  _classPrivateFieldGet2(this, _uiManager).setEditingState(isEditing);
                }
                addCommands(params) {
                  _classPrivateFieldGet2(this, _uiManager).addCommands(params);
                }
                enable() {
                  this.div.style.pointerEvents = "auto";
                  for (const editor of _classPrivateFieldGet2(this, _editors).values()) {
                    editor.enableEditing();
                  }
                }
                disable() {
                  this.div.style.pointerEvents = "none";
                  for (const editor of _classPrivateFieldGet2(this, _editors).values()) {
                    editor.disableEditing();
                  }
                }
                setActiveEditor(editor) {
                  const currentActive = _classPrivateFieldGet2(this, _uiManager).getActive();
                  if (currentActive === editor) {
                    return;
                  }
                  _classPrivateFieldGet2(this, _uiManager).setActiveEditor(editor);
                }
                enableClick() {
                  this.div.addEventListener("pointerdown", _classPrivateFieldGet2(this, _boundPointerdown));
                  this.div.addEventListener("pointerup", _classPrivateFieldGet2(this, _boundPointerup));
                }
                disableClick() {
                  this.div.removeEventListener("pointerdown", _classPrivateFieldGet2(this, _boundPointerdown));
                  this.div.removeEventListener("pointerup", _classPrivateFieldGet2(this, _boundPointerup));
                }
                attach(editor) {
                  _classPrivateFieldGet2(this, _editors).set(editor.id, editor);
                }
                detach(editor) {
                  var _classPrivateFieldGet22;
                  _classPrivateFieldGet2(this, _editors).delete(editor.id);
                  (_classPrivateFieldGet22 = _classPrivateFieldGet2(this, _accessibilityManager)) === null || _classPrivateFieldGet22 === void 0 ? void 0 : _classPrivateFieldGet22.removePointerInTextLayer(editor.contentDiv);
                }
                remove(editor) {
                  _classPrivateFieldGet2(this, _uiManager).removeEditor(editor);
                  this.detach(editor);
                  this.annotationStorage.remove(editor.id);
                  editor.div.style.display = "none";
                  setTimeout(() => {
                    editor.div.style.display = "";
                    editor.div.remove();
                    editor.isAttachedToDOM = false;
                    if (document.activeElement === document.body) {
                      _classPrivateFieldGet2(this, _uiManager).focusMainContainer();
                    }
                  }, 0);
                  if (!_classPrivateFieldGet2(this, _isCleaningUp)) {
                    this.addInkEditorIfNeeded(false);
                  }
                }
                add(editor) {
                  _classPrivateMethodGet2(this, _changeParent, _changeParent2).call(this, editor);
                  _classPrivateFieldGet2(this, _uiManager).addEditor(editor);
                  this.attach(editor);
                  if (!editor.isAttachedToDOM) {
                    const div = editor.render();
                    this.div.append(div);
                    editor.isAttachedToDOM = true;
                  }
                  this.moveEditorInDOM(editor);
                  editor.onceAdded();
                  this.addToAnnotationStorage(editor);
                }
                moveEditorInDOM(editor) {
                  var _classPrivateFieldGet3;
                  (_classPrivateFieldGet3 = _classPrivateFieldGet2(this, _accessibilityManager)) === null || _classPrivateFieldGet3 === void 0 ? void 0 : _classPrivateFieldGet3.moveElementInDOM(this.div, editor.div, editor.contentDiv, true);
                }
                addToAnnotationStorage(editor) {
                  if (!editor.isEmpty() && !this.annotationStorage.has(editor.id)) {
                    this.annotationStorage.setValue(editor.id, editor);
                  }
                }
                addOrRebuild(editor) {
                  if (editor.needsToBeRebuilt()) {
                    editor.rebuild();
                  } else {
                    this.add(editor);
                  }
                }
                addANewEditor(editor) {
                  const cmd = () => {
                    this.addOrRebuild(editor);
                  };
                  const undo = () => {
                    editor.remove();
                  };
                  this.addCommands({
                    cmd,
                    undo,
                    mustExec: true
                  });
                }
                addUndoableEditor(editor) {
                  const cmd = () => {
                    this.addOrRebuild(editor);
                  };
                  const undo = () => {
                    editor.remove();
                  };
                  this.addCommands({
                    cmd,
                    undo,
                    mustExec: false
                  });
                }
                getNextId() {
                  return _classPrivateFieldGet2(this, _uiManager).getId();
                }
                deserialize(data) {
                  switch (data.annotationType) {
                    case _util2.AnnotationEditorType.FREETEXT:
                      return _freetext.FreeTextEditor.deserialize(data, this);
                    case _util2.AnnotationEditorType.INK:
                      return _ink.InkEditor.deserialize(data, this);
                  }
                  return null;
                }
                setSelected(editor) {
                  _classPrivateFieldGet2(this, _uiManager).setSelected(editor);
                }
                toggleSelected(editor) {
                  _classPrivateFieldGet2(this, _uiManager).toggleSelected(editor);
                }
                isSelected(editor) {
                  return _classPrivateFieldGet2(this, _uiManager).isSelected(editor);
                }
                unselect(editor) {
                  _classPrivateFieldGet2(this, _uiManager).unselect(editor);
                }
                pointerup(event) {
                  const isMac = _tools.KeyboardManager.platform.isMac;
                  if (event.button !== 0 || event.ctrlKey && isMac) {
                    return;
                  }
                  if (event.target !== this.div) {
                    return;
                  }
                  if (!_classPrivateFieldGet2(this, _hadPointerDown)) {
                    return;
                  }
                  _classPrivateFieldSet2(this, _hadPointerDown, false);
                  if (!_classPrivateFieldGet2(this, _allowClick)) {
                    _classPrivateFieldSet2(this, _allowClick, true);
                    return;
                  }
                  _classPrivateMethodGet2(this, _createAndAddNewEditor, _createAndAddNewEditor2).call(this, event);
                }
                pointerdown(event) {
                  const isMac = _tools.KeyboardManager.platform.isMac;
                  if (event.button !== 0 || event.ctrlKey && isMac) {
                    return;
                  }
                  if (event.target !== this.div) {
                    return;
                  }
                  _classPrivateFieldSet2(this, _hadPointerDown, true);
                  const editor = _classPrivateFieldGet2(this, _uiManager).getActive();
                  _classPrivateFieldSet2(this, _allowClick, !editor || editor.isEmpty());
                }
                drop(event) {
                  const id = event.dataTransfer.getData("text/plain");
                  const editor = _classPrivateFieldGet2(this, _uiManager).getEditor(id);
                  if (!editor) {
                    return;
                  }
                  event.preventDefault();
                  event.dataTransfer.dropEffect = "move";
                  _classPrivateMethodGet2(this, _changeParent, _changeParent2).call(this, editor);
                  const rect = this.div.getBoundingClientRect();
                  const endX = event.clientX - rect.x;
                  const endY = event.clientY - rect.y;
                  editor.translate(endX - editor.startX, endY - editor.startY);
                  this.moveEditorInDOM(editor);
                  editor.div.focus();
                }
                dragover(event) {
                  event.preventDefault();
                }
                destroy() {
                  var _classPrivateFieldGet4;
                  if (((_classPrivateFieldGet4 = _classPrivateFieldGet2(this, _uiManager).getActive()) === null || _classPrivateFieldGet4 === void 0 ? void 0 : _classPrivateFieldGet4.parent) === this) {
                    _classPrivateFieldGet2(this, _uiManager).setActiveEditor(null);
                  }
                  for (const editor of _classPrivateFieldGet2(this, _editors).values()) {
                    var _classPrivateFieldGet5;
                    (_classPrivateFieldGet5 = _classPrivateFieldGet2(this, _accessibilityManager)) === null || _classPrivateFieldGet5 === void 0 ? void 0 : _classPrivateFieldGet5.removePointerInTextLayer(editor.contentDiv);
                    editor.isAttachedToDOM = false;
                    editor.div.remove();
                    editor.parent = null;
                  }
                  this.div = null;
                  _classPrivateFieldGet2(this, _editors).clear();
                  _classPrivateFieldGet2(this, _uiManager).removeLayer(this);
                }
                render(parameters) {
                  this.viewport = parameters.viewport;
                  (0, _tools.bindEvents)(this, this.div, ["dragover", "drop"]);
                  this.setDimensions();
                  for (const editor of _classPrivateFieldGet2(this, _uiManager).getEditors(this.pageIndex)) {
                    this.add(editor);
                  }
                  this.updateMode();
                }
                update(parameters) {
                  this.viewport = parameters.viewport;
                  this.setDimensions();
                  this.updateMode();
                }
                get scaleFactor() {
                  return this.viewport.scale;
                }
                get pageDimensions() {
                  const [pageLLx, pageLLy, pageURx, pageURy] = this.viewport.viewBox;
                  const width = pageURx - pageLLx;
                  const height = pageURy - pageLLy;
                  return [width, height];
                }
                get viewportBaseDimensions() {
                  const {
                    width,
                    height,
                    rotation
                  } = this.viewport;
                  return rotation % 180 === 0 ? [width, height] : [height, width];
                }
                setDimensions() {
                  const {
                    width,
                    height,
                    rotation
                  } = this.viewport;
                  const flipOrientation = rotation % 180 !== 0, widthStr = Math.floor(width) + "px", heightStr = Math.floor(height) + "px";
                  this.div.style.width = flipOrientation ? heightStr : widthStr;
                  this.div.style.height = flipOrientation ? widthStr : heightStr;
                  this.div.setAttribute("data-main-rotation", rotation);
                }
              }
              exports2.AnnotationEditorLayer = AnnotationEditorLayer;
              function _changeParent2(editor) {
                var _editor$parent;
                if (editor.parent === this) {
                  return;
                }
                this.attach(editor);
                editor.pageIndex = this.pageIndex;
                (_editor$parent = editor.parent) === null || _editor$parent === void 0 ? void 0 : _editor$parent.detach(editor);
                editor.parent = this;
                if (editor.div && editor.isAttachedToDOM) {
                  editor.div.remove();
                  this.div.append(editor.div);
                }
              }
              function _createNewEditor2(params) {
                switch (_classPrivateFieldGet2(this, _uiManager).getMode()) {
                  case _util2.AnnotationEditorType.FREETEXT:
                    return new _freetext.FreeTextEditor(params);
                  case _util2.AnnotationEditorType.INK:
                    return new _ink.InkEditor(params);
                }
                return null;
              }
              function _createAndAddNewEditor2(event) {
                const id = this.getNextId();
                const editor = _classPrivateMethodGet2(this, _createNewEditor, _createNewEditor2).call(this, {
                  parent: this,
                  id,
                  x: event.offsetX,
                  y: event.offsetY
                });
                if (editor) {
                  this.add(editor);
                }
                return editor;
              }
              function _cleanup2() {
                _classPrivateFieldSet2(this, _isCleaningUp, true);
                for (const editor of _classPrivateFieldGet2(this, _editors).values()) {
                  if (editor.isEmpty()) {
                    editor.remove();
                  }
                }
                _classPrivateFieldSet2(this, _isCleaningUp, false);
              }
              _defineProperty(AnnotationEditorLayer, "_initialized", false);
            },
            /* 148 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.FreeTextEditor = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              var _tools = __w_pdfjs_require__2(132);
              var _editor = __w_pdfjs_require__2(131);
              function _classPrivateMethodInitSpec2(obj, privateSet) {
                _checkPrivateRedeclaration2(obj, privateSet);
                privateSet.add(obj);
              }
              function _defineProperty(obj, key, value) {
                if (key in obj) {
                  Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
                } else {
                  obj[key] = value;
                }
                return obj;
              }
              function _classPrivateFieldInitSpec2(obj, privateMap, value) {
                _checkPrivateRedeclaration2(obj, privateMap);
                privateMap.set(obj, value);
              }
              function _checkPrivateRedeclaration2(obj, privateCollection) {
                if (privateCollection.has(obj)) {
                  throw new TypeError("Cannot initialize the same private elements twice on an object");
                }
              }
              function _classPrivateFieldGet2(receiver, privateMap) {
                var descriptor = _classExtractFieldDescriptor2(receiver, privateMap, "get");
                return _classApplyDescriptorGet2(receiver, descriptor);
              }
              function _classApplyDescriptorGet2(receiver, descriptor) {
                if (descriptor.get) {
                  return descriptor.get.call(receiver);
                }
                return descriptor.value;
              }
              function _classPrivateMethodGet2(receiver, privateSet, fn) {
                if (!privateSet.has(receiver)) {
                  throw new TypeError("attempted to get private field on non-instance");
                }
                return fn;
              }
              function _classPrivateFieldSet2(receiver, privateMap, value) {
                var descriptor = _classExtractFieldDescriptor2(receiver, privateMap, "set");
                _classApplyDescriptorSet2(receiver, descriptor, value);
                return value;
              }
              function _classExtractFieldDescriptor2(receiver, privateMap, action) {
                if (!privateMap.has(receiver)) {
                  throw new TypeError("attempted to " + action + " private field on non-instance");
                }
                return privateMap.get(receiver);
              }
              function _classApplyDescriptorSet2(receiver, descriptor, value) {
                if (descriptor.set) {
                  descriptor.set.call(receiver, value);
                } else {
                  if (!descriptor.writable) {
                    throw new TypeError("attempted to set read only private field");
                  }
                  descriptor.value = value;
                }
              }
              var _boundEditorDivBlur = /* @__PURE__ */ new WeakMap();
              var _boundEditorDivFocus = /* @__PURE__ */ new WeakMap();
              var _boundEditorDivKeydown = /* @__PURE__ */ new WeakMap();
              var _color = /* @__PURE__ */ new WeakMap();
              var _content = /* @__PURE__ */ new WeakMap();
              var _hasAlreadyBeenCommitted = /* @__PURE__ */ new WeakMap();
              var _fontSize = /* @__PURE__ */ new WeakMap();
              var _updateFontSize = /* @__PURE__ */ new WeakSet();
              var _updateColor = /* @__PURE__ */ new WeakSet();
              var _extractText = /* @__PURE__ */ new WeakSet();
              var _setEditorDimensions = /* @__PURE__ */ new WeakSet();
              class FreeTextEditor extends _editor.AnnotationEditor {
                constructor(params) {
                  super({
                    ...params,
                    name: "freeTextEditor"
                  });
                  _classPrivateMethodInitSpec2(this, _setEditorDimensions);
                  _classPrivateMethodInitSpec2(this, _extractText);
                  _classPrivateMethodInitSpec2(this, _updateColor);
                  _classPrivateMethodInitSpec2(this, _updateFontSize);
                  _classPrivateFieldInitSpec2(this, _boundEditorDivBlur, {
                    writable: true,
                    value: this.editorDivBlur.bind(this)
                  });
                  _classPrivateFieldInitSpec2(this, _boundEditorDivFocus, {
                    writable: true,
                    value: this.editorDivFocus.bind(this)
                  });
                  _classPrivateFieldInitSpec2(this, _boundEditorDivKeydown, {
                    writable: true,
                    value: this.editorDivKeydown.bind(this)
                  });
                  _classPrivateFieldInitSpec2(this, _color, {
                    writable: true,
                    value: void 0
                  });
                  _classPrivateFieldInitSpec2(this, _content, {
                    writable: true,
                    value: ""
                  });
                  _classPrivateFieldInitSpec2(this, _hasAlreadyBeenCommitted, {
                    writable: true,
                    value: false
                  });
                  _classPrivateFieldInitSpec2(this, _fontSize, {
                    writable: true,
                    value: void 0
                  });
                  _classPrivateFieldSet2(this, _color, params.color || FreeTextEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor);
                  _classPrivateFieldSet2(this, _fontSize, params.fontSize || FreeTextEditor._defaultFontSize);
                }
                static initialize(l10n) {
                  this._l10nPromise = new Map(["free_text_default_content", "editor_free_text_aria_label"].map((str) => [str, l10n.get(str)]));
                  const style = getComputedStyle(document.documentElement);
                  this._internalPadding = parseFloat(style.getPropertyValue("--freetext-padding"));
                }
                static updateDefaultParams(type, value) {
                  switch (type) {
                    case _util2.AnnotationEditorParamsType.FREETEXT_SIZE:
                      FreeTextEditor._defaultFontSize = value;
                      break;
                    case _util2.AnnotationEditorParamsType.FREETEXT_COLOR:
                      FreeTextEditor._defaultColor = value;
                      break;
                  }
                }
                updateParams(type, value) {
                  switch (type) {
                    case _util2.AnnotationEditorParamsType.FREETEXT_SIZE:
                      _classPrivateMethodGet2(this, _updateFontSize, _updateFontSize2).call(this, value);
                      break;
                    case _util2.AnnotationEditorParamsType.FREETEXT_COLOR:
                      _classPrivateMethodGet2(this, _updateColor, _updateColor2).call(this, value);
                      break;
                  }
                }
                static get defaultPropertiesToUpdate() {
                  return [[_util2.AnnotationEditorParamsType.FREETEXT_SIZE, FreeTextEditor._defaultFontSize], [_util2.AnnotationEditorParamsType.FREETEXT_COLOR, FreeTextEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor]];
                }
                get propertiesToUpdate() {
                  return [[_util2.AnnotationEditorParamsType.FREETEXT_SIZE, _classPrivateFieldGet2(this, _fontSize)], [_util2.AnnotationEditorParamsType.FREETEXT_COLOR, _classPrivateFieldGet2(this, _color)]];
                }
                getInitialTranslation() {
                  return [-FreeTextEditor._internalPadding * this.parent.scaleFactor, -(FreeTextEditor._internalPadding + _classPrivateFieldGet2(this, _fontSize)) * this.parent.scaleFactor];
                }
                rebuild() {
                  super.rebuild();
                  if (this.div === null) {
                    return;
                  }
                  if (!this.isAttachedToDOM) {
                    this.parent.add(this);
                  }
                }
                enableEditMode() {
                  if (this.isInEditMode()) {
                    return;
                  }
                  this.parent.setEditingState(false);
                  this.parent.updateToolbar(_util2.AnnotationEditorType.FREETEXT);
                  super.enableEditMode();
                  this.enableEditing();
                  this.overlayDiv.classList.remove("enabled");
                  this.editorDiv.contentEditable = true;
                  this.div.draggable = false;
                  this.editorDiv.addEventListener("keydown", _classPrivateFieldGet2(this, _boundEditorDivKeydown));
                  this.editorDiv.addEventListener("focus", _classPrivateFieldGet2(this, _boundEditorDivFocus));
                  this.editorDiv.addEventListener("blur", _classPrivateFieldGet2(this, _boundEditorDivBlur));
                }
                disableEditMode() {
                  if (!this.isInEditMode()) {
                    return;
                  }
                  this.parent.setEditingState(true);
                  super.disableEditMode();
                  this.disableEditing();
                  this.overlayDiv.classList.add("enabled");
                  this.editorDiv.contentEditable = false;
                  this.div.draggable = true;
                  this.editorDiv.removeEventListener("keydown", _classPrivateFieldGet2(this, _boundEditorDivKeydown));
                  this.editorDiv.removeEventListener("focus", _classPrivateFieldGet2(this, _boundEditorDivFocus));
                  this.editorDiv.removeEventListener("blur", _classPrivateFieldGet2(this, _boundEditorDivBlur));
                  this.div.focus();
                  this.isEditing = false;
                }
                focusin(event) {
                  super.focusin(event);
                  if (event.target !== this.editorDiv) {
                    this.editorDiv.focus();
                  }
                }
                onceAdded() {
                  if (this.width) {
                    return;
                  }
                  this.enableEditMode();
                  this.editorDiv.focus();
                }
                isEmpty() {
                  return !this.editorDiv || this.editorDiv.innerText.trim() === "";
                }
                remove() {
                  this.isEditing = false;
                  this.parent.setEditingState(true);
                  super.remove();
                }
                commit() {
                  super.commit();
                  if (!_classPrivateFieldGet2(this, _hasAlreadyBeenCommitted)) {
                    _classPrivateFieldSet2(this, _hasAlreadyBeenCommitted, true);
                    this.parent.addUndoableEditor(this);
                  }
                  this.disableEditMode();
                  _classPrivateFieldSet2(this, _content, _classPrivateMethodGet2(this, _extractText, _extractText2).call(this).trimEnd());
                  _classPrivateMethodGet2(this, _setEditorDimensions, _setEditorDimensions2).call(this);
                }
                shouldGetKeyboardEvents() {
                  return this.isInEditMode();
                }
                dblclick(event) {
                  this.enableEditMode();
                  this.editorDiv.focus();
                }
                keydown(event) {
                  if (event.target === this.div && event.key === "Enter") {
                    this.enableEditMode();
                    this.editorDiv.focus();
                  }
                }
                editorDivKeydown(event) {
                  FreeTextEditor._keyboardManager.exec(this, event);
                }
                editorDivFocus(event) {
                  this.isEditing = true;
                }
                editorDivBlur(event) {
                  this.isEditing = false;
                }
                disableEditing() {
                  this.editorDiv.setAttribute("role", "comment");
                  this.editorDiv.removeAttribute("aria-multiline");
                }
                enableEditing() {
                  this.editorDiv.setAttribute("role", "textbox");
                  this.editorDiv.setAttribute("aria-multiline", true);
                }
                render() {
                  if (this.div) {
                    return this.div;
                  }
                  let baseX, baseY;
                  if (this.width) {
                    baseX = this.x;
                    baseY = this.y;
                  }
                  super.render();
                  this.editorDiv = document.createElement("div");
                  this.editorDiv.className = "internal";
                  this.editorDiv.setAttribute("id", `${this.id}-editor`);
                  this.enableEditing();
                  FreeTextEditor._l10nPromise.get("editor_free_text_aria_label").then((msg) => {
                    var _this$editorDiv;
                    return (_this$editorDiv = this.editorDiv) === null || _this$editorDiv === void 0 ? void 0 : _this$editorDiv.setAttribute("aria-label", msg);
                  });
                  FreeTextEditor._l10nPromise.get("free_text_default_content").then((msg) => {
                    var _this$editorDiv2;
                    return (_this$editorDiv2 = this.editorDiv) === null || _this$editorDiv2 === void 0 ? void 0 : _this$editorDiv2.setAttribute("default-content", msg);
                  });
                  this.editorDiv.contentEditable = true;
                  const {
                    style
                  } = this.editorDiv;
                  style.fontSize = `calc(${_classPrivateFieldGet2(this, _fontSize)}px * var(--scale-factor))`;
                  style.color = _classPrivateFieldGet2(this, _color);
                  this.div.append(this.editorDiv);
                  this.overlayDiv = document.createElement("div");
                  this.overlayDiv.classList.add("overlay", "enabled");
                  this.div.append(this.overlayDiv);
                  (0, _tools.bindEvents)(this, this.div, ["dblclick", "keydown"]);
                  if (this.width) {
                    const [parentWidth, parentHeight] = this.parent.viewportBaseDimensions;
                    this.setAt(baseX * parentWidth, baseY * parentHeight, this.width * parentWidth, this.height * parentHeight);
                    for (const line of _classPrivateFieldGet2(this, _content).split("\n")) {
                      const div = document.createElement("div");
                      div.append(line ? document.createTextNode(line) : document.createElement("br"));
                      this.editorDiv.append(div);
                    }
                    this.div.draggable = true;
                    this.editorDiv.contentEditable = false;
                  } else {
                    this.div.draggable = false;
                    this.editorDiv.contentEditable = true;
                  }
                  return this.div;
                }
                get contentDiv() {
                  return this.editorDiv;
                }
                static deserialize(data, parent) {
                  const editor = super.deserialize(data, parent);
                  _classPrivateFieldSet2(editor, _fontSize, data.fontSize);
                  _classPrivateFieldSet2(editor, _color, _util2.Util.makeHexColor(...data.color));
                  _classPrivateFieldSet2(editor, _content, data.value);
                  return editor;
                }
                serialize() {
                  if (this.isEmpty()) {
                    return null;
                  }
                  const padding = FreeTextEditor._internalPadding * this.parent.scaleFactor;
                  const rect = this.getRect(padding, padding);
                  const color = _editor.AnnotationEditor._colorManager.convert(getComputedStyle(this.editorDiv).color);
                  return {
                    annotationType: _util2.AnnotationEditorType.FREETEXT,
                    color,
                    fontSize: _classPrivateFieldGet2(this, _fontSize),
                    value: _classPrivateFieldGet2(this, _content),
                    pageIndex: this.parent.pageIndex,
                    rect,
                    rotation: this.rotation
                  };
                }
              }
              exports2.FreeTextEditor = FreeTextEditor;
              function _updateFontSize2(fontSize) {
                const setFontsize = (size) => {
                  this.editorDiv.style.fontSize = `calc(${size}px * var(--scale-factor))`;
                  this.translate(0, -(size - _classPrivateFieldGet2(this, _fontSize)) * this.parent.scaleFactor);
                  _classPrivateFieldSet2(this, _fontSize, size);
                  _classPrivateMethodGet2(this, _setEditorDimensions, _setEditorDimensions2).call(this);
                };
                const savedFontsize = _classPrivateFieldGet2(this, _fontSize);
                this.parent.addCommands({
                  cmd: () => {
                    setFontsize(fontSize);
                  },
                  undo: () => {
                    setFontsize(savedFontsize);
                  },
                  mustExec: true,
                  type: _util2.AnnotationEditorParamsType.FREETEXT_SIZE,
                  overwriteIfSameType: true,
                  keepUndo: true
                });
              }
              function _updateColor2(color) {
                const savedColor = _classPrivateFieldGet2(this, _color);
                this.parent.addCommands({
                  cmd: () => {
                    _classPrivateFieldSet2(this, _color, color);
                    this.editorDiv.style.color = color;
                  },
                  undo: () => {
                    _classPrivateFieldSet2(this, _color, savedColor);
                    this.editorDiv.style.color = savedColor;
                  },
                  mustExec: true,
                  type: _util2.AnnotationEditorParamsType.FREETEXT_COLOR,
                  overwriteIfSameType: true,
                  keepUndo: true
                });
              }
              function _extractText2() {
                const divs = this.editorDiv.getElementsByTagName("div");
                if (divs.length === 0) {
                  return this.editorDiv.innerText;
                }
                const buffer = [];
                for (let i = 0, ii = divs.length; i < ii; i++) {
                  const div = divs[i];
                  const first = div.firstChild;
                  if ((first === null || first === void 0 ? void 0 : first.nodeName) === "#text") {
                    buffer.push(first.data);
                  } else {
                    buffer.push("");
                  }
                }
                return buffer.join("\n");
              }
              function _setEditorDimensions2() {
                const [parentWidth, parentHeight] = this.parent.viewportBaseDimensions;
                const rect = this.div.getBoundingClientRect();
                this.width = rect.width / parentWidth;
                this.height = rect.height / parentHeight;
              }
              _defineProperty(FreeTextEditor, "_freeTextDefaultContent", "");
              _defineProperty(FreeTextEditor, "_l10nPromise", void 0);
              _defineProperty(FreeTextEditor, "_internalPadding", 0);
              _defineProperty(FreeTextEditor, "_defaultColor", null);
              _defineProperty(FreeTextEditor, "_defaultFontSize", 10);
              _defineProperty(FreeTextEditor, "_keyboardManager", new _tools.KeyboardManager([[["ctrl+Enter", "mac+meta+Enter", "Escape", "mac+Escape"], FreeTextEditor.prototype.commitOrRemove]]));
              _defineProperty(FreeTextEditor, "_type", "freetext");
            },
            /* 149 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.InkEditor = void 0;
              Object.defineProperty(exports2, "fitCurve", {
                enumerable: true,
                get: function() {
                  return _pdfjsFitCurve.fitCurve;
                }
              });
              var _util2 = __w_pdfjs_require__2(1);
              var _editor = __w_pdfjs_require__2(131);
              var _pdfjsFitCurve = __w_pdfjs_require__2(150);
              var _tools = __w_pdfjs_require__2(132);
              function _classPrivateMethodInitSpec2(obj, privateSet) {
                _checkPrivateRedeclaration2(obj, privateSet);
                privateSet.add(obj);
              }
              function _defineProperty(obj, key, value) {
                if (key in obj) {
                  Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
                } else {
                  obj[key] = value;
                }
                return obj;
              }
              function _classPrivateFieldInitSpec2(obj, privateMap, value) {
                _checkPrivateRedeclaration2(obj, privateMap);
                privateMap.set(obj, value);
              }
              function _checkPrivateRedeclaration2(obj, privateCollection) {
                if (privateCollection.has(obj)) {
                  throw new TypeError("Cannot initialize the same private elements twice on an object");
                }
              }
              function _classStaticPrivateMethodGet(receiver, classConstructor, method) {
                _classCheckPrivateStaticAccess2(receiver, classConstructor);
                return method;
              }
              function _classCheckPrivateStaticAccess2(receiver, classConstructor) {
                if (receiver !== classConstructor) {
                  throw new TypeError("Private static access of wrong provenance");
                }
              }
              function _classPrivateFieldSet2(receiver, privateMap, value) {
                var descriptor = _classExtractFieldDescriptor2(receiver, privateMap, "set");
                _classApplyDescriptorSet2(receiver, descriptor, value);
                return value;
              }
              function _classApplyDescriptorSet2(receiver, descriptor, value) {
                if (descriptor.set) {
                  descriptor.set.call(receiver, value);
                } else {
                  if (!descriptor.writable) {
                    throw new TypeError("attempted to set read only private field");
                  }
                  descriptor.value = value;
                }
              }
              function _classPrivateFieldGet2(receiver, privateMap) {
                var descriptor = _classExtractFieldDescriptor2(receiver, privateMap, "get");
                return _classApplyDescriptorGet2(receiver, descriptor);
              }
              function _classExtractFieldDescriptor2(receiver, privateMap, action) {
                if (!privateMap.has(receiver)) {
                  throw new TypeError("attempted to " + action + " private field on non-instance");
                }
                return privateMap.get(receiver);
              }
              function _classApplyDescriptorGet2(receiver, descriptor) {
                if (descriptor.get) {
                  return descriptor.get.call(receiver);
                }
                return descriptor.value;
              }
              function _classPrivateMethodGet2(receiver, privateSet, fn) {
                if (!privateSet.has(receiver)) {
                  throw new TypeError("attempted to get private field on non-instance");
                }
                return fn;
              }
              const RESIZER_SIZE = 16;
              var _aspectRatio = /* @__PURE__ */ new WeakMap();
              var _baseHeight = /* @__PURE__ */ new WeakMap();
              var _baseWidth = /* @__PURE__ */ new WeakMap();
              var _boundCanvasPointermove = /* @__PURE__ */ new WeakMap();
              var _boundCanvasPointerleave = /* @__PURE__ */ new WeakMap();
              var _boundCanvasPointerup = /* @__PURE__ */ new WeakMap();
              var _boundCanvasPointerdown = /* @__PURE__ */ new WeakMap();
              var _disableEditing = /* @__PURE__ */ new WeakMap();
              var _isCanvasInitialized = /* @__PURE__ */ new WeakMap();
              var _lastPoint = /* @__PURE__ */ new WeakMap();
              var _observer = /* @__PURE__ */ new WeakMap();
              var _realWidth = /* @__PURE__ */ new WeakMap();
              var _realHeight = /* @__PURE__ */ new WeakMap();
              var _requestFrameCallback = /* @__PURE__ */ new WeakMap();
              var _updateThickness = /* @__PURE__ */ new WeakSet();
              var _updateColor = /* @__PURE__ */ new WeakSet();
              var _updateOpacity = /* @__PURE__ */ new WeakSet();
              var _getInitialBBox = /* @__PURE__ */ new WeakSet();
              var _setStroke = /* @__PURE__ */ new WeakSet();
              var _startDrawing = /* @__PURE__ */ new WeakSet();
              var _draw = /* @__PURE__ */ new WeakSet();
              var _stopDrawing = /* @__PURE__ */ new WeakSet();
              var _redraw = /* @__PURE__ */ new WeakSet();
              var _endDrawing = /* @__PURE__ */ new WeakSet();
              var _createCanvas = /* @__PURE__ */ new WeakSet();
              var _createObserver = /* @__PURE__ */ new WeakSet();
              var _setCanvasDims = /* @__PURE__ */ new WeakSet();
              var _setScaleFactor = /* @__PURE__ */ new WeakSet();
              var _updateTransform = /* @__PURE__ */ new WeakSet();
              var _serializePaths = /* @__PURE__ */ new WeakSet();
              var _extractPointsOnBezier = /* @__PURE__ */ new WeakSet();
              var _isAlmostFlat = /* @__PURE__ */ new WeakSet();
              var _getBbox = /* @__PURE__ */ new WeakSet();
              var _getPadding = /* @__PURE__ */ new WeakSet();
              var _fitToContent = /* @__PURE__ */ new WeakSet();
              var _setMinDims = /* @__PURE__ */ new WeakSet();
              class InkEditor extends _editor.AnnotationEditor {
                constructor(params) {
                  super({
                    ...params,
                    name: "inkEditor"
                  });
                  _classPrivateMethodInitSpec2(this, _setMinDims);
                  _classPrivateMethodInitSpec2(this, _fitToContent);
                  _classPrivateMethodInitSpec2(this, _getPadding);
                  _classPrivateMethodInitSpec2(this, _getBbox);
                  _classPrivateMethodInitSpec2(this, _isAlmostFlat);
                  _classPrivateMethodInitSpec2(this, _extractPointsOnBezier);
                  _classPrivateMethodInitSpec2(this, _serializePaths);
                  _classPrivateMethodInitSpec2(this, _updateTransform);
                  _classPrivateMethodInitSpec2(this, _setScaleFactor);
                  _classPrivateMethodInitSpec2(this, _setCanvasDims);
                  _classPrivateMethodInitSpec2(this, _createObserver);
                  _classPrivateMethodInitSpec2(this, _createCanvas);
                  _classPrivateMethodInitSpec2(this, _endDrawing);
                  _classPrivateMethodInitSpec2(this, _redraw);
                  _classPrivateMethodInitSpec2(this, _stopDrawing);
                  _classPrivateMethodInitSpec2(this, _draw);
                  _classPrivateMethodInitSpec2(this, _startDrawing);
                  _classPrivateMethodInitSpec2(this, _setStroke);
                  _classPrivateMethodInitSpec2(this, _getInitialBBox);
                  _classPrivateMethodInitSpec2(this, _updateOpacity);
                  _classPrivateMethodInitSpec2(this, _updateColor);
                  _classPrivateMethodInitSpec2(this, _updateThickness);
                  _classPrivateFieldInitSpec2(this, _aspectRatio, {
                    writable: true,
                    value: 0
                  });
                  _classPrivateFieldInitSpec2(this, _baseHeight, {
                    writable: true,
                    value: 0
                  });
                  _classPrivateFieldInitSpec2(this, _baseWidth, {
                    writable: true,
                    value: 0
                  });
                  _classPrivateFieldInitSpec2(this, _boundCanvasPointermove, {
                    writable: true,
                    value: this.canvasPointermove.bind(this)
                  });
                  _classPrivateFieldInitSpec2(this, _boundCanvasPointerleave, {
                    writable: true,
                    value: this.canvasPointerleave.bind(this)
                  });
                  _classPrivateFieldInitSpec2(this, _boundCanvasPointerup, {
                    writable: true,
                    value: this.canvasPointerup.bind(this)
                  });
                  _classPrivateFieldInitSpec2(this, _boundCanvasPointerdown, {
                    writable: true,
                    value: this.canvasPointerdown.bind(this)
                  });
                  _classPrivateFieldInitSpec2(this, _disableEditing, {
                    writable: true,
                    value: false
                  });
                  _classPrivateFieldInitSpec2(this, _isCanvasInitialized, {
                    writable: true,
                    value: false
                  });
                  _classPrivateFieldInitSpec2(this, _lastPoint, {
                    writable: true,
                    value: null
                  });
                  _classPrivateFieldInitSpec2(this, _observer, {
                    writable: true,
                    value: null
                  });
                  _classPrivateFieldInitSpec2(this, _realWidth, {
                    writable: true,
                    value: 0
                  });
                  _classPrivateFieldInitSpec2(this, _realHeight, {
                    writable: true,
                    value: 0
                  });
                  _classPrivateFieldInitSpec2(this, _requestFrameCallback, {
                    writable: true,
                    value: null
                  });
                  this.color = params.color || null;
                  this.thickness = params.thickness || null;
                  this.opacity = params.opacity || null;
                  this.paths = [];
                  this.bezierPath2D = [];
                  this.currentPath = [];
                  this.scaleFactor = 1;
                  this.translationX = this.translationY = 0;
                  this.x = 0;
                  this.y = 0;
                }
                static initialize(l10n) {
                  this._l10nPromise = new Map(["editor_ink_canvas_aria_label", "editor_ink_aria_label"].map((str) => [str, l10n.get(str)]));
                }
                static updateDefaultParams(type, value) {
                  switch (type) {
                    case _util2.AnnotationEditorParamsType.INK_THICKNESS:
                      InkEditor._defaultThickness = value;
                      break;
                    case _util2.AnnotationEditorParamsType.INK_COLOR:
                      InkEditor._defaultColor = value;
                      break;
                    case _util2.AnnotationEditorParamsType.INK_OPACITY:
                      InkEditor._defaultOpacity = value / 100;
                      break;
                  }
                }
                updateParams(type, value) {
                  switch (type) {
                    case _util2.AnnotationEditorParamsType.INK_THICKNESS:
                      _classPrivateMethodGet2(this, _updateThickness, _updateThickness2).call(this, value);
                      break;
                    case _util2.AnnotationEditorParamsType.INK_COLOR:
                      _classPrivateMethodGet2(this, _updateColor, _updateColor2).call(this, value);
                      break;
                    case _util2.AnnotationEditorParamsType.INK_OPACITY:
                      _classPrivateMethodGet2(this, _updateOpacity, _updateOpacity2).call(this, value);
                      break;
                  }
                }
                static get defaultPropertiesToUpdate() {
                  return [[_util2.AnnotationEditorParamsType.INK_THICKNESS, InkEditor._defaultThickness], [_util2.AnnotationEditorParamsType.INK_COLOR, InkEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor], [_util2.AnnotationEditorParamsType.INK_OPACITY, Math.round(InkEditor._defaultOpacity * 100)]];
                }
                get propertiesToUpdate() {
                  var _this$opacity;
                  return [[_util2.AnnotationEditorParamsType.INK_THICKNESS, this.thickness || InkEditor._defaultThickness], [_util2.AnnotationEditorParamsType.INK_COLOR, this.color || InkEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor], [_util2.AnnotationEditorParamsType.INK_OPACITY, Math.round(100 * ((_this$opacity = this.opacity) !== null && _this$opacity !== void 0 ? _this$opacity : InkEditor._defaultOpacity))]];
                }
                rebuild() {
                  super.rebuild();
                  if (this.div === null) {
                    return;
                  }
                  if (!this.canvas) {
                    _classPrivateMethodGet2(this, _createCanvas, _createCanvas2).call(this);
                    _classPrivateMethodGet2(this, _createObserver, _createObserver2).call(this);
                  }
                  if (!this.isAttachedToDOM) {
                    this.parent.add(this);
                    _classPrivateMethodGet2(this, _setCanvasDims, _setCanvasDims2).call(this);
                  }
                  _classPrivateMethodGet2(this, _fitToContent, _fitToContent2).call(this);
                }
                remove() {
                  if (this.canvas === null) {
                    return;
                  }
                  if (!this.isEmpty()) {
                    this.commit();
                  }
                  this.canvas.width = this.canvas.height = 0;
                  this.canvas.remove();
                  this.canvas = null;
                  _classPrivateFieldGet2(this, _observer).disconnect();
                  _classPrivateFieldSet2(this, _observer, null);
                  super.remove();
                }
                enableEditMode() {
                  if (_classPrivateFieldGet2(this, _disableEditing) || this.canvas === null) {
                    return;
                  }
                  super.enableEditMode();
                  this.div.draggable = false;
                  this.canvas.addEventListener("pointerdown", _classPrivateFieldGet2(this, _boundCanvasPointerdown));
                  this.canvas.addEventListener("pointerup", _classPrivateFieldGet2(this, _boundCanvasPointerup));
                }
                disableEditMode() {
                  if (!this.isInEditMode() || this.canvas === null) {
                    return;
                  }
                  super.disableEditMode();
                  this.div.draggable = !this.isEmpty();
                  this.div.classList.remove("editing");
                  this.canvas.removeEventListener("pointerdown", _classPrivateFieldGet2(this, _boundCanvasPointerdown));
                  this.canvas.removeEventListener("pointerup", _classPrivateFieldGet2(this, _boundCanvasPointerup));
                }
                onceAdded() {
                  this.div.draggable = !this.isEmpty();
                }
                isEmpty() {
                  return this.paths.length === 0 || this.paths.length === 1 && this.paths[0].length === 0;
                }
                commit() {
                  if (_classPrivateFieldGet2(this, _disableEditing)) {
                    return;
                  }
                  super.commit();
                  this.isEditing = false;
                  this.disableEditMode();
                  this.setInForeground();
                  _classPrivateFieldSet2(this, _disableEditing, true);
                  this.div.classList.add("disabled");
                  _classPrivateMethodGet2(this, _fitToContent, _fitToContent2).call(this, true);
                  this.parent.addInkEditorIfNeeded(true);
                  this.parent.moveEditorInDOM(this);
                  this.div.focus();
                }
                focusin(event) {
                  super.focusin(event);
                  this.enableEditMode();
                }
                canvasPointerdown(event) {
                  if (event.button !== 0 || !this.isInEditMode() || _classPrivateFieldGet2(this, _disableEditing)) {
                    return;
                  }
                  this.setInForeground();
                  if (event.type !== "mouse") {
                    this.div.focus();
                  }
                  event.stopPropagation();
                  this.canvas.addEventListener("pointerleave", _classPrivateFieldGet2(this, _boundCanvasPointerleave));
                  this.canvas.addEventListener("pointermove", _classPrivateFieldGet2(this, _boundCanvasPointermove));
                  _classPrivateMethodGet2(this, _startDrawing, _startDrawing2).call(this, event.offsetX, event.offsetY);
                }
                canvasPointermove(event) {
                  event.stopPropagation();
                  _classPrivateMethodGet2(this, _draw, _draw2).call(this, event.offsetX, event.offsetY);
                }
                canvasPointerup(event) {
                  if (event.button !== 0) {
                    return;
                  }
                  if (this.isInEditMode() && this.currentPath.length !== 0) {
                    event.stopPropagation();
                    _classPrivateMethodGet2(this, _endDrawing, _endDrawing2).call(this, event);
                    this.setInBackground();
                  }
                }
                canvasPointerleave(event) {
                  _classPrivateMethodGet2(this, _endDrawing, _endDrawing2).call(this, event);
                  this.setInBackground();
                }
                render() {
                  if (this.div) {
                    return this.div;
                  }
                  let baseX, baseY;
                  if (this.width) {
                    baseX = this.x;
                    baseY = this.y;
                  }
                  super.render();
                  InkEditor._l10nPromise.get("editor_ink_aria_label").then((msg) => {
                    var _this$div;
                    return (_this$div = this.div) === null || _this$div === void 0 ? void 0 : _this$div.setAttribute("aria-label", msg);
                  });
                  const [x, y, w, h] = _classPrivateMethodGet2(this, _getInitialBBox, _getInitialBBox2).call(this);
                  this.setAt(x, y, 0, 0);
                  this.setDims(w, h);
                  _classPrivateMethodGet2(this, _createCanvas, _createCanvas2).call(this);
                  if (this.width) {
                    const [parentWidth, parentHeight] = this.parent.viewportBaseDimensions;
                    this.setAt(baseX * parentWidth, baseY * parentHeight, this.width * parentWidth, this.height * parentHeight);
                    _classPrivateFieldSet2(this, _isCanvasInitialized, true);
                    _classPrivateMethodGet2(this, _setCanvasDims, _setCanvasDims2).call(this);
                    this.setDims(this.width * parentWidth, this.height * parentHeight);
                    _classPrivateMethodGet2(this, _redraw, _redraw2).call(this);
                    _classPrivateMethodGet2(this, _setMinDims, _setMinDims2).call(this);
                    this.div.classList.add("disabled");
                  } else {
                    this.div.classList.add("editing");
                    this.enableEditMode();
                  }
                  _classPrivateMethodGet2(this, _createObserver, _createObserver2).call(this);
                  return this.div;
                }
                setDimensions(width, height) {
                  const roundedWidth = Math.round(width);
                  const roundedHeight = Math.round(height);
                  if (_classPrivateFieldGet2(this, _realWidth) === roundedWidth && _classPrivateFieldGet2(this, _realHeight) === roundedHeight) {
                    return;
                  }
                  _classPrivateFieldSet2(this, _realWidth, roundedWidth);
                  _classPrivateFieldSet2(this, _realHeight, roundedHeight);
                  this.canvas.style.visibility = "hidden";
                  if (_classPrivateFieldGet2(this, _aspectRatio) && Math.abs(_classPrivateFieldGet2(this, _aspectRatio) - width / height) > 0.01) {
                    height = Math.ceil(width / _classPrivateFieldGet2(this, _aspectRatio));
                    this.setDims(width, height);
                  }
                  const [parentWidth, parentHeight] = this.parent.viewportBaseDimensions;
                  this.width = width / parentWidth;
                  this.height = height / parentHeight;
                  if (_classPrivateFieldGet2(this, _disableEditing)) {
                    _classPrivateMethodGet2(this, _setScaleFactor, _setScaleFactor2).call(this, width, height);
                  }
                  _classPrivateMethodGet2(this, _setCanvasDims, _setCanvasDims2).call(this);
                  _classPrivateMethodGet2(this, _redraw, _redraw2).call(this);
                  this.canvas.style.visibility = "visible";
                }
                static deserialize(data, parent) {
                  const editor = super.deserialize(data, parent);
                  editor.thickness = data.thickness;
                  editor.color = _util2.Util.makeHexColor(...data.color);
                  editor.opacity = data.opacity;
                  const [pageWidth, pageHeight] = parent.pageDimensions;
                  const width = editor.width * pageWidth;
                  const height = editor.height * pageHeight;
                  const scaleFactor = parent.scaleFactor;
                  const padding = data.thickness / 2;
                  _classPrivateFieldSet2(editor, _aspectRatio, width / height);
                  _classPrivateFieldSet2(editor, _disableEditing, true);
                  _classPrivateFieldSet2(editor, _realWidth, Math.round(width));
                  _classPrivateFieldSet2(editor, _realHeight, Math.round(height));
                  for (const {
                    bezier
                  } of data.paths) {
                    const path = [];
                    editor.paths.push(path);
                    let p0 = scaleFactor * (bezier[0] - padding);
                    let p1 = scaleFactor * (height - bezier[1] - padding);
                    for (let i = 2, ii = bezier.length; i < ii; i += 6) {
                      const p10 = scaleFactor * (bezier[i] - padding);
                      const p11 = scaleFactor * (height - bezier[i + 1] - padding);
                      const p20 = scaleFactor * (bezier[i + 2] - padding);
                      const p21 = scaleFactor * (height - bezier[i + 3] - padding);
                      const p30 = scaleFactor * (bezier[i + 4] - padding);
                      const p31 = scaleFactor * (height - bezier[i + 5] - padding);
                      path.push([[p0, p1], [p10, p11], [p20, p21], [p30, p31]]);
                      p0 = p30;
                      p1 = p31;
                    }
                    const path2D = _classStaticPrivateMethodGet(this, InkEditor, _buildPath2D).call(this, path);
                    editor.bezierPath2D.push(path2D);
                  }
                  const bbox = _classPrivateMethodGet2(editor, _getBbox, _getBbox2).call(editor);
                  _classPrivateFieldSet2(editor, _baseWidth, Math.max(RESIZER_SIZE, bbox[2] - bbox[0]));
                  _classPrivateFieldSet2(editor, _baseHeight, Math.max(RESIZER_SIZE, bbox[3] - bbox[1]));
                  _classPrivateMethodGet2(editor, _setScaleFactor, _setScaleFactor2).call(editor, width, height);
                  return editor;
                }
                serialize() {
                  if (this.isEmpty()) {
                    return null;
                  }
                  const rect = this.getRect(0, 0);
                  const height = this.rotation % 180 === 0 ? rect[3] - rect[1] : rect[2] - rect[0];
                  const color = _editor.AnnotationEditor._colorManager.convert(this.ctx.strokeStyle);
                  return {
                    annotationType: _util2.AnnotationEditorType.INK,
                    color,
                    thickness: this.thickness,
                    opacity: this.opacity,
                    paths: _classPrivateMethodGet2(this, _serializePaths, _serializePaths2).call(this, this.scaleFactor / this.parent.scaleFactor, this.translationX, this.translationY, height),
                    pageIndex: this.parent.pageIndex,
                    rect,
                    rotation: this.rotation
                  };
                }
              }
              exports2.InkEditor = InkEditor;
              function _updateThickness2(thickness) {
                const savedThickness = this.thickness;
                this.parent.addCommands({
                  cmd: () => {
                    this.thickness = thickness;
                    _classPrivateMethodGet2(this, _fitToContent, _fitToContent2).call(this);
                  },
                  undo: () => {
                    this.thickness = savedThickness;
                    _classPrivateMethodGet2(this, _fitToContent, _fitToContent2).call(this);
                  },
                  mustExec: true,
                  type: _util2.AnnotationEditorParamsType.INK_THICKNESS,
                  overwriteIfSameType: true,
                  keepUndo: true
                });
              }
              function _updateColor2(color) {
                const savedColor = this.color;
                this.parent.addCommands({
                  cmd: () => {
                    this.color = color;
                    _classPrivateMethodGet2(this, _redraw, _redraw2).call(this);
                  },
                  undo: () => {
                    this.color = savedColor;
                    _classPrivateMethodGet2(this, _redraw, _redraw2).call(this);
                  },
                  mustExec: true,
                  type: _util2.AnnotationEditorParamsType.INK_COLOR,
                  overwriteIfSameType: true,
                  keepUndo: true
                });
              }
              function _updateOpacity2(opacity) {
                opacity /= 100;
                const savedOpacity = this.opacity;
                this.parent.addCommands({
                  cmd: () => {
                    this.opacity = opacity;
                    _classPrivateMethodGet2(this, _redraw, _redraw2).call(this);
                  },
                  undo: () => {
                    this.opacity = savedOpacity;
                    _classPrivateMethodGet2(this, _redraw, _redraw2).call(this);
                  },
                  mustExec: true,
                  type: _util2.AnnotationEditorParamsType.INK_OPACITY,
                  overwriteIfSameType: true,
                  keepUndo: true
                });
              }
              function _getInitialBBox2() {
                const {
                  width,
                  height,
                  rotation
                } = this.parent.viewport;
                switch (rotation) {
                  case 90:
                    return [0, width, width, height];
                  case 180:
                    return [width, height, width, height];
                  case 270:
                    return [height, 0, width, height];
                  default:
                    return [0, 0, width, height];
                }
              }
              function _setStroke2() {
                this.ctx.lineWidth = this.thickness * this.parent.scaleFactor / this.scaleFactor;
                this.ctx.lineCap = "round";
                this.ctx.lineJoin = "round";
                this.ctx.miterLimit = 10;
                this.ctx.strokeStyle = `${this.color}${(0, _tools.opacityToHex)(this.opacity)}`;
              }
              function _startDrawing2(x, y) {
                this.isEditing = true;
                if (!_classPrivateFieldGet2(this, _isCanvasInitialized)) {
                  var _this$opacity2;
                  _classPrivateFieldSet2(this, _isCanvasInitialized, true);
                  _classPrivateMethodGet2(this, _setCanvasDims, _setCanvasDims2).call(this);
                  this.thickness || (this.thickness = InkEditor._defaultThickness);
                  this.color || (this.color = InkEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor);
                  (_this$opacity2 = this.opacity) !== null && _this$opacity2 !== void 0 ? _this$opacity2 : this.opacity = InkEditor._defaultOpacity;
                }
                this.currentPath.push([x, y]);
                _classPrivateFieldSet2(this, _lastPoint, null);
                _classPrivateMethodGet2(this, _setStroke, _setStroke2).call(this);
                this.ctx.beginPath();
                this.ctx.moveTo(x, y);
                _classPrivateFieldSet2(this, _requestFrameCallback, () => {
                  if (!_classPrivateFieldGet2(this, _requestFrameCallback)) {
                    return;
                  }
                  if (_classPrivateFieldGet2(this, _lastPoint)) {
                    if (this.isEmpty()) {
                      this.ctx.setTransform(1, 0, 0, 1, 0, 0);
                      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                    } else {
                      _classPrivateMethodGet2(this, _redraw, _redraw2).call(this);
                    }
                    this.ctx.lineTo(..._classPrivateFieldGet2(this, _lastPoint));
                    _classPrivateFieldSet2(this, _lastPoint, null);
                    this.ctx.stroke();
                  }
                  window.requestAnimationFrame(_classPrivateFieldGet2(this, _requestFrameCallback));
                });
                window.requestAnimationFrame(_classPrivateFieldGet2(this, _requestFrameCallback));
              }
              function _draw2(x, y) {
                const [lastX, lastY] = this.currentPath.at(-1);
                if (x === lastX && y === lastY) {
                  return;
                }
                this.currentPath.push([x, y]);
                _classPrivateFieldSet2(this, _lastPoint, [x, y]);
              }
              function _stopDrawing2(x, y) {
                this.ctx.closePath();
                _classPrivateFieldSet2(this, _requestFrameCallback, null);
                x = Math.min(Math.max(x, 0), this.canvas.width);
                y = Math.min(Math.max(y, 0), this.canvas.height);
                const [lastX, lastY] = this.currentPath.at(-1);
                if (x !== lastX || y !== lastY) {
                  this.currentPath.push([x, y]);
                }
                let bezier;
                if (this.currentPath.length !== 1) {
                  bezier = (0, _pdfjsFitCurve.fitCurve)(this.currentPath, 30, null);
                } else {
                  const xy = [x, y];
                  bezier = [[xy, xy.slice(), xy.slice(), xy]];
                }
                const path2D = _classStaticPrivateMethodGet(InkEditor, InkEditor, _buildPath2D).call(InkEditor, bezier);
                this.currentPath.length = 0;
                const cmd = () => {
                  this.paths.push(bezier);
                  this.bezierPath2D.push(path2D);
                  this.rebuild();
                };
                const undo = () => {
                  this.paths.pop();
                  this.bezierPath2D.pop();
                  if (this.paths.length === 0) {
                    this.remove();
                  } else {
                    if (!this.canvas) {
                      _classPrivateMethodGet2(this, _createCanvas, _createCanvas2).call(this);
                      _classPrivateMethodGet2(this, _createObserver, _createObserver2).call(this);
                    }
                    _classPrivateMethodGet2(this, _fitToContent, _fitToContent2).call(this);
                  }
                };
                this.parent.addCommands({
                  cmd,
                  undo,
                  mustExec: true
                });
              }
              function _redraw2() {
                if (this.isEmpty()) {
                  _classPrivateMethodGet2(this, _updateTransform, _updateTransform2).call(this);
                  return;
                }
                _classPrivateMethodGet2(this, _setStroke, _setStroke2).call(this);
                const {
                  canvas,
                  ctx
                } = this;
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                _classPrivateMethodGet2(this, _updateTransform, _updateTransform2).call(this);
                for (const path of this.bezierPath2D) {
                  ctx.stroke(path);
                }
              }
              function _endDrawing2(event) {
                _classPrivateMethodGet2(this, _stopDrawing, _stopDrawing2).call(this, event.offsetX, event.offsetY);
                this.canvas.removeEventListener("pointerleave", _classPrivateFieldGet2(this, _boundCanvasPointerleave));
                this.canvas.removeEventListener("pointermove", _classPrivateFieldGet2(this, _boundCanvasPointermove));
                this.parent.addToAnnotationStorage(this);
              }
              function _createCanvas2() {
                this.canvas = document.createElement("canvas");
                this.canvas.width = this.canvas.height = 0;
                this.canvas.className = "inkEditorCanvas";
                InkEditor._l10nPromise.get("editor_ink_canvas_aria_label").then((msg) => {
                  var _this$canvas;
                  return (_this$canvas = this.canvas) === null || _this$canvas === void 0 ? void 0 : _this$canvas.setAttribute("aria-label", msg);
                });
                this.div.append(this.canvas);
                this.ctx = this.canvas.getContext("2d");
              }
              function _createObserver2() {
                _classPrivateFieldSet2(this, _observer, new ResizeObserver((entries) => {
                  const rect = entries[0].contentRect;
                  if (rect.width && rect.height) {
                    this.setDimensions(rect.width, rect.height);
                  }
                }));
                _classPrivateFieldGet2(this, _observer).observe(this.div);
              }
              function _setCanvasDims2() {
                if (!_classPrivateFieldGet2(this, _isCanvasInitialized)) {
                  return;
                }
                const [parentWidth, parentHeight] = this.parent.viewportBaseDimensions;
                this.canvas.width = Math.ceil(this.width * parentWidth);
                this.canvas.height = Math.ceil(this.height * parentHeight);
                _classPrivateMethodGet2(this, _updateTransform, _updateTransform2).call(this);
              }
              function _setScaleFactor2(width, height) {
                const padding = _classPrivateMethodGet2(this, _getPadding, _getPadding2).call(this);
                const scaleFactorW = (width - padding) / _classPrivateFieldGet2(this, _baseWidth);
                const scaleFactorH = (height - padding) / _classPrivateFieldGet2(this, _baseHeight);
                this.scaleFactor = Math.min(scaleFactorW, scaleFactorH);
              }
              function _updateTransform2() {
                const padding = _classPrivateMethodGet2(this, _getPadding, _getPadding2).call(this) / 2;
                this.ctx.setTransform(this.scaleFactor, 0, 0, this.scaleFactor, this.translationX * this.scaleFactor + padding, this.translationY * this.scaleFactor + padding);
              }
              function _buildPath2D(bezier) {
                const path2D = new Path2D();
                for (let i = 0, ii = bezier.length; i < ii; i++) {
                  const [first, control1, control2, second] = bezier[i];
                  if (i === 0) {
                    path2D.moveTo(...first);
                  }
                  path2D.bezierCurveTo(control1[0], control1[1], control2[0], control2[1], second[0], second[1]);
                }
                return path2D;
              }
              function _serializePaths2(s, tx, ty, h) {
                const NUMBER_OF_POINTS_ON_BEZIER_CURVE = 4;
                const paths = [];
                const padding = this.thickness / 2;
                let buffer, points;
                for (const bezier of this.paths) {
                  buffer = [];
                  points = [];
                  for (let i = 0, ii = bezier.length; i < ii; i++) {
                    const [first, control1, control2, second] = bezier[i];
                    const p10 = s * (first[0] + tx) + padding;
                    const p11 = h - s * (first[1] + ty) - padding;
                    const p20 = s * (control1[0] + tx) + padding;
                    const p21 = h - s * (control1[1] + ty) - padding;
                    const p30 = s * (control2[0] + tx) + padding;
                    const p31 = h - s * (control2[1] + ty) - padding;
                    const p40 = s * (second[0] + tx) + padding;
                    const p41 = h - s * (second[1] + ty) - padding;
                    if (i === 0) {
                      buffer.push(p10, p11);
                      points.push(p10, p11);
                    }
                    buffer.push(p20, p21, p30, p31, p40, p41);
                    _classPrivateMethodGet2(this, _extractPointsOnBezier, _extractPointsOnBezier2).call(this, p10, p11, p20, p21, p30, p31, p40, p41, NUMBER_OF_POINTS_ON_BEZIER_CURVE, points);
                  }
                  paths.push({
                    bezier: buffer,
                    points
                  });
                }
                return paths;
              }
              function _extractPointsOnBezier2(p10, p11, p20, p21, p30, p31, p40, p41, n, points) {
                if (_classPrivateMethodGet2(this, _isAlmostFlat, _isAlmostFlat2).call(this, p10, p11, p20, p21, p30, p31, p40, p41)) {
                  points.push(p40, p41);
                  return;
                }
                for (let i = 1; i < n - 1; i++) {
                  const t = i / n;
                  const mt = 1 - t;
                  let q10 = t * p10 + mt * p20;
                  let q11 = t * p11 + mt * p21;
                  let q20 = t * p20 + mt * p30;
                  let q21 = t * p21 + mt * p31;
                  const q30 = t * p30 + mt * p40;
                  const q31 = t * p31 + mt * p41;
                  q10 = t * q10 + mt * q20;
                  q11 = t * q11 + mt * q21;
                  q20 = t * q20 + mt * q30;
                  q21 = t * q21 + mt * q31;
                  q10 = t * q10 + mt * q20;
                  q11 = t * q11 + mt * q21;
                  points.push(q10, q11);
                }
                points.push(p40, p41);
              }
              function _isAlmostFlat2(p10, p11, p20, p21, p30, p31, p40, p41) {
                const tol = 10;
                const ax = (3 * p20 - 2 * p10 - p40) ** 2;
                const ay = (3 * p21 - 2 * p11 - p41) ** 2;
                const bx = (3 * p30 - p10 - 2 * p40) ** 2;
                const by = (3 * p31 - p11 - 2 * p41) ** 2;
                return Math.max(ax, bx) + Math.max(ay, by) <= tol;
              }
              function _getBbox2() {
                let xMin = Infinity;
                let xMax = -Infinity;
                let yMin = Infinity;
                let yMax = -Infinity;
                for (const path of this.paths) {
                  for (const [first, control1, control2, second] of path) {
                    const bbox = _util2.Util.bezierBoundingBox(...first, ...control1, ...control2, ...second);
                    xMin = Math.min(xMin, bbox[0]);
                    yMin = Math.min(yMin, bbox[1]);
                    xMax = Math.max(xMax, bbox[2]);
                    yMax = Math.max(yMax, bbox[3]);
                  }
                }
                return [xMin, yMin, xMax, yMax];
              }
              function _getPadding2() {
                return _classPrivateFieldGet2(this, _disableEditing) ? Math.ceil(this.thickness * this.parent.scaleFactor) : 0;
              }
              function _fitToContent2() {
                let firstTime = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
                if (this.isEmpty()) {
                  return;
                }
                if (!_classPrivateFieldGet2(this, _disableEditing)) {
                  _classPrivateMethodGet2(this, _redraw, _redraw2).call(this);
                  return;
                }
                const bbox = _classPrivateMethodGet2(this, _getBbox, _getBbox2).call(this);
                const padding = _classPrivateMethodGet2(this, _getPadding, _getPadding2).call(this);
                _classPrivateFieldSet2(this, _baseWidth, Math.max(RESIZER_SIZE, bbox[2] - bbox[0]));
                _classPrivateFieldSet2(this, _baseHeight, Math.max(RESIZER_SIZE, bbox[3] - bbox[1]));
                const width = Math.ceil(padding + _classPrivateFieldGet2(this, _baseWidth) * this.scaleFactor);
                const height = Math.ceil(padding + _classPrivateFieldGet2(this, _baseHeight) * this.scaleFactor);
                const [parentWidth, parentHeight] = this.parent.viewportBaseDimensions;
                this.width = width / parentWidth;
                this.height = height / parentHeight;
                _classPrivateFieldSet2(this, _aspectRatio, width / height);
                _classPrivateMethodGet2(this, _setMinDims, _setMinDims2).call(this);
                const prevTranslationX = this.translationX;
                const prevTranslationY = this.translationY;
                this.translationX = -bbox[0];
                this.translationY = -bbox[1];
                _classPrivateMethodGet2(this, _setCanvasDims, _setCanvasDims2).call(this);
                _classPrivateMethodGet2(this, _redraw, _redraw2).call(this);
                _classPrivateFieldSet2(this, _realWidth, width);
                _classPrivateFieldSet2(this, _realHeight, height);
                this.setDims(width, height);
                const unscaledPadding = firstTime ? padding / this.scaleFactor / 2 : 0;
                this.translate(prevTranslationX - this.translationX - unscaledPadding, prevTranslationY - this.translationY - unscaledPadding);
              }
              function _setMinDims2() {
                const {
                  style
                } = this.div;
                if (_classPrivateFieldGet2(this, _aspectRatio) >= 1) {
                  style.minHeight = `${RESIZER_SIZE}px`;
                  style.minWidth = `${Math.round(_classPrivateFieldGet2(this, _aspectRatio) * RESIZER_SIZE)}px`;
                } else {
                  style.minWidth = `${RESIZER_SIZE}px`;
                  style.minHeight = `${Math.round(RESIZER_SIZE / _classPrivateFieldGet2(this, _aspectRatio))}px`;
                }
              }
              _defineProperty(InkEditor, "_defaultColor", null);
              _defineProperty(InkEditor, "_defaultOpacity", 1);
              _defineProperty(InkEditor, "_defaultThickness", 1);
              _defineProperty(InkEditor, "_l10nPromise", void 0);
              _defineProperty(InkEditor, "_type", "ink");
            },
            /* 150 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.fitCurve = void 0;
              const fitCurve = __w_pdfjs_require__2(151);
              exports2.fitCurve = fitCurve;
            },
            /* 151 */
            /***/
            (module2) => {
              "use strict";
              function fitCurve(points, maxError, progressCallback) {
                if (!Array.isArray(points)) {
                  throw new TypeError("First argument should be an array");
                }
                points.forEach((point) => {
                  if (!Array.isArray(point) || point.some((item) => typeof item !== "number") || point.length !== points[0].length) {
                    throw Error("Each point should be an array of numbers. Each point should have the same amount of numbers.");
                  }
                });
                points = points.filter((point, i) => i === 0 || !point.every((val, j) => val === points[i - 1][j]));
                if (points.length < 2) {
                  return [];
                }
                const len = points.length;
                const leftTangent = createTangent(points[1], points[0]);
                const rightTangent = createTangent(points[len - 2], points[len - 1]);
                return fitCubic(points, leftTangent, rightTangent, maxError, progressCallback);
              }
              function fitCubic(points, leftTangent, rightTangent, error, progressCallback) {
                const MaxIterations = 20;
                var bezCurve, u, uPrime, maxError, prevErr, splitPoint, prevSplit, centerVector, toCenterTangent, fromCenterTangent, beziers, dist, i;
                if (points.length === 2) {
                  dist = maths.vectorLen(maths.subtract(points[0], points[1])) / 3;
                  bezCurve = [points[0], maths.addArrays(points[0], maths.mulItems(leftTangent, dist)), maths.addArrays(points[1], maths.mulItems(rightTangent, dist)), points[1]];
                  return [bezCurve];
                }
                u = chordLengthParameterize(points);
                [bezCurve, maxError, splitPoint] = generateAndReport(points, u, u, leftTangent, rightTangent, progressCallback);
                if (maxError === 0 || maxError < error) {
                  return [bezCurve];
                }
                if (maxError < error * error) {
                  uPrime = u;
                  prevErr = maxError;
                  prevSplit = splitPoint;
                  for (i = 0; i < MaxIterations; i++) {
                    uPrime = reparameterize(bezCurve, points, uPrime);
                    [bezCurve, maxError, splitPoint] = generateAndReport(points, u, uPrime, leftTangent, rightTangent, progressCallback);
                    if (maxError < error) {
                      return [bezCurve];
                    } else if (splitPoint === prevSplit) {
                      let errChange = maxError / prevErr;
                      if (errChange > 0.9999 && errChange < 1.0001) {
                        break;
                      }
                    }
                    prevErr = maxError;
                    prevSplit = splitPoint;
                  }
                }
                beziers = [];
                centerVector = maths.subtract(points[splitPoint - 1], points[splitPoint + 1]);
                if (centerVector.every((val) => val === 0)) {
                  centerVector = maths.subtract(points[splitPoint - 1], points[splitPoint]);
                  [centerVector[0], centerVector[1]] = [-centerVector[1], centerVector[0]];
                }
                toCenterTangent = maths.normalize(centerVector);
                fromCenterTangent = maths.mulItems(toCenterTangent, -1);
                beziers = beziers.concat(fitCubic(points.slice(0, splitPoint + 1), leftTangent, toCenterTangent, error, progressCallback));
                beziers = beziers.concat(fitCubic(points.slice(splitPoint), fromCenterTangent, rightTangent, error, progressCallback));
                return beziers;
              }
              ;
              function generateAndReport(points, paramsOrig, paramsPrime, leftTangent, rightTangent, progressCallback) {
                var bezCurve, maxError, splitPoint;
                bezCurve = generateBezier(points, paramsPrime, leftTangent, rightTangent, progressCallback);
                [maxError, splitPoint] = computeMaxError(points, bezCurve, paramsOrig);
                if (progressCallback) {
                  progressCallback({
                    bez: bezCurve,
                    points,
                    params: paramsOrig,
                    maxErr: maxError,
                    maxPoint: splitPoint
                  });
                }
                return [bezCurve, maxError, splitPoint];
              }
              function generateBezier(points, parameters, leftTangent, rightTangent) {
                var bezCurve, A, a, C, X, det_C0_C1, det_C0_X, det_X_C1, alpha_l, alpha_r, epsilon, segLength, i, len, tmp, u, ux, firstPoint = points[0], lastPoint = points[points.length - 1];
                bezCurve = [firstPoint, null, null, lastPoint];
                A = maths.zeros_Xx2x2(parameters.length);
                for (i = 0, len = parameters.length; i < len; i++) {
                  u = parameters[i];
                  ux = 1 - u;
                  a = A[i];
                  a[0] = maths.mulItems(leftTangent, 3 * u * (ux * ux));
                  a[1] = maths.mulItems(rightTangent, 3 * ux * (u * u));
                }
                C = [[0, 0], [0, 0]];
                X = [0, 0];
                for (i = 0, len = points.length; i < len; i++) {
                  u = parameters[i];
                  a = A[i];
                  C[0][0] += maths.dot(a[0], a[0]);
                  C[0][1] += maths.dot(a[0], a[1]);
                  C[1][0] += maths.dot(a[0], a[1]);
                  C[1][1] += maths.dot(a[1], a[1]);
                  tmp = maths.subtract(points[i], bezier.q([firstPoint, firstPoint, lastPoint, lastPoint], u));
                  X[0] += maths.dot(a[0], tmp);
                  X[1] += maths.dot(a[1], tmp);
                }
                det_C0_C1 = C[0][0] * C[1][1] - C[1][0] * C[0][1];
                det_C0_X = C[0][0] * X[1] - C[1][0] * X[0];
                det_X_C1 = X[0] * C[1][1] - X[1] * C[0][1];
                alpha_l = det_C0_C1 === 0 ? 0 : det_X_C1 / det_C0_C1;
                alpha_r = det_C0_C1 === 0 ? 0 : det_C0_X / det_C0_C1;
                segLength = maths.vectorLen(maths.subtract(firstPoint, lastPoint));
                epsilon = 1e-6 * segLength;
                if (alpha_l < epsilon || alpha_r < epsilon) {
                  bezCurve[1] = maths.addArrays(firstPoint, maths.mulItems(leftTangent, segLength / 3));
                  bezCurve[2] = maths.addArrays(lastPoint, maths.mulItems(rightTangent, segLength / 3));
                } else {
                  bezCurve[1] = maths.addArrays(firstPoint, maths.mulItems(leftTangent, alpha_l));
                  bezCurve[2] = maths.addArrays(lastPoint, maths.mulItems(rightTangent, alpha_r));
                }
                return bezCurve;
              }
              ;
              function reparameterize(bezier2, points, parameters) {
                return parameters.map((p, i) => newtonRaphsonRootFind(bezier2, points[i], p));
              }
              ;
              function newtonRaphsonRootFind(bez, point, u) {
                var d = maths.subtract(bezier.q(bez, u), point), qprime = bezier.qprime(bez, u), numerator = maths.mulMatrix(d, qprime), denominator = maths.sum(maths.squareItems(qprime)) + 2 * maths.mulMatrix(d, bezier.qprimeprime(bez, u));
                if (denominator === 0) {
                  return u;
                } else {
                  return u - numerator / denominator;
                }
              }
              ;
              function chordLengthParameterize(points) {
                var u = [], currU, prevU, prevP;
                points.forEach((p, i) => {
                  currU = i ? prevU + maths.vectorLen(maths.subtract(p, prevP)) : 0;
                  u.push(currU);
                  prevU = currU;
                  prevP = p;
                });
                u = u.map((x) => x / prevU);
                return u;
              }
              ;
              function computeMaxError(points, bez, parameters) {
                var dist, maxDist, splitPoint, v, i, count, point, t;
                maxDist = 0;
                splitPoint = Math.floor(points.length / 2);
                const t_distMap = mapTtoRelativeDistances(bez, 10);
                for (i = 0, count = points.length; i < count; i++) {
                  point = points[i];
                  t = find_t(bez, parameters[i], t_distMap, 10);
                  v = maths.subtract(bezier.q(bez, t), point);
                  dist = v[0] * v[0] + v[1] * v[1];
                  if (dist > maxDist) {
                    maxDist = dist;
                    splitPoint = i;
                  }
                }
                return [maxDist, splitPoint];
              }
              ;
              var mapTtoRelativeDistances = function(bez, B_parts) {
                var B_t_curr;
                var B_t_dist = [0];
                var B_t_prev = bez[0];
                var sumLen = 0;
                for (var i = 1; i <= B_parts; i++) {
                  B_t_curr = bezier.q(bez, i / B_parts);
                  sumLen += maths.vectorLen(maths.subtract(B_t_curr, B_t_prev));
                  B_t_dist.push(sumLen);
                  B_t_prev = B_t_curr;
                }
                B_t_dist = B_t_dist.map((x) => x / sumLen);
                return B_t_dist;
              };
              function find_t(bez, param, t_distMap, B_parts) {
                if (param < 0) {
                  return 0;
                }
                if (param > 1) {
                  return 1;
                }
                var lenMax, lenMin, tMax, tMin, t;
                for (var i = 1; i <= B_parts; i++) {
                  if (param <= t_distMap[i]) {
                    tMin = (i - 1) / B_parts;
                    tMax = i / B_parts;
                    lenMin = t_distMap[i - 1];
                    lenMax = t_distMap[i];
                    t = (param - lenMin) / (lenMax - lenMin) * (tMax - tMin) + tMin;
                    break;
                  }
                }
                return t;
              }
              function createTangent(pointA, pointB) {
                return maths.normalize(maths.subtract(pointA, pointB));
              }
              class maths {
                static zeros_Xx2x2(x) {
                  var zs = [];
                  while (x--) {
                    zs.push([0, 0]);
                  }
                  return zs;
                }
                static mulItems(items, multiplier) {
                  return items.map((x) => x * multiplier);
                }
                static mulMatrix(m1, m2) {
                  return m1.reduce((sum, x1, i) => sum + x1 * m2[i], 0);
                }
                static subtract(arr1, arr2) {
                  return arr1.map((x1, i) => x1 - arr2[i]);
                }
                static addArrays(arr1, arr2) {
                  return arr1.map((x1, i) => x1 + arr2[i]);
                }
                static addItems(items, addition) {
                  return items.map((x) => x + addition);
                }
                static sum(items) {
                  return items.reduce((sum, x) => sum + x);
                }
                static dot(m1, m2) {
                  return maths.mulMatrix(m1, m2);
                }
                static vectorLen(v) {
                  return Math.hypot(...v);
                }
                static divItems(items, divisor) {
                  return items.map((x) => x / divisor);
                }
                static squareItems(items) {
                  return items.map((x) => x * x);
                }
                static normalize(v) {
                  return this.divItems(v, this.vectorLen(v));
                }
              }
              class bezier {
                static q(ctrlPoly, t) {
                  var tx = 1 - t;
                  var pA = maths.mulItems(ctrlPoly[0], tx * tx * tx), pB = maths.mulItems(ctrlPoly[1], 3 * tx * tx * t), pC = maths.mulItems(ctrlPoly[2], 3 * tx * t * t), pD = maths.mulItems(ctrlPoly[3], t * t * t);
                  return maths.addArrays(maths.addArrays(pA, pB), maths.addArrays(pC, pD));
                }
                static qprime(ctrlPoly, t) {
                  var tx = 1 - t;
                  var pA = maths.mulItems(maths.subtract(ctrlPoly[1], ctrlPoly[0]), 3 * tx * tx), pB = maths.mulItems(maths.subtract(ctrlPoly[2], ctrlPoly[1]), 6 * tx * t), pC = maths.mulItems(maths.subtract(ctrlPoly[3], ctrlPoly[2]), 3 * t * t);
                  return maths.addArrays(maths.addArrays(pA, pB), pC);
                }
                static qprimeprime(ctrlPoly, t) {
                  return maths.addArrays(maths.mulItems(maths.addArrays(maths.subtract(ctrlPoly[2], maths.mulItems(ctrlPoly[1], 2)), ctrlPoly[0]), 6 * (1 - t)), maths.mulItems(maths.addArrays(maths.subtract(ctrlPoly[3], maths.mulItems(ctrlPoly[2], 2)), ctrlPoly[1]), 6 * t));
                }
              }
              module2.exports = fitCurve;
              module2.exports.fitCubic = fitCubic;
              module2.exports.createTangent = createTangent;
            },
            /* 152 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.AnnotationLayer = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              var _display_utils2 = __w_pdfjs_require__2(133);
              var _annotation_storage2 = __w_pdfjs_require__2(130);
              var _scripting_utils = __w_pdfjs_require__2(153);
              var _xfa_layer = __w_pdfjs_require__2(154);
              function _classStaticPrivateMethodGet(receiver, classConstructor, method) {
                _classCheckPrivateStaticAccess2(receiver, classConstructor);
                return method;
              }
              function _classCheckPrivateStaticAccess2(receiver, classConstructor) {
                if (receiver !== classConstructor) {
                  throw new TypeError("Private static access of wrong provenance");
                }
              }
              const DEFAULT_TAB_INDEX = 1e3;
              const DEFAULT_FONT_SIZE = 9;
              const GetElementsByNameSet = /* @__PURE__ */ new WeakSet();
              function getRectDims(rect) {
                return {
                  width: rect[2] - rect[0],
                  height: rect[3] - rect[1]
                };
              }
              class AnnotationElementFactory {
                static create(parameters) {
                  const subtype = parameters.data.annotationType;
                  switch (subtype) {
                    case _util2.AnnotationType.LINK:
                      return new LinkAnnotationElement(parameters);
                    case _util2.AnnotationType.TEXT:
                      return new TextAnnotationElement(parameters);
                    case _util2.AnnotationType.WIDGET:
                      const fieldType = parameters.data.fieldType;
                      switch (fieldType) {
                        case "Tx":
                          return new TextWidgetAnnotationElement(parameters);
                        case "Btn":
                          if (parameters.data.radioButton) {
                            return new RadioButtonWidgetAnnotationElement(parameters);
                          } else if (parameters.data.checkBox) {
                            return new CheckboxWidgetAnnotationElement(parameters);
                          }
                          return new PushButtonWidgetAnnotationElement(parameters);
                        case "Ch":
                          return new ChoiceWidgetAnnotationElement(parameters);
                      }
                      return new WidgetAnnotationElement(parameters);
                    case _util2.AnnotationType.POPUP:
                      return new PopupAnnotationElement(parameters);
                    case _util2.AnnotationType.FREETEXT:
                      return new FreeTextAnnotationElement(parameters);
                    case _util2.AnnotationType.LINE:
                      return new LineAnnotationElement(parameters);
                    case _util2.AnnotationType.SQUARE:
                      return new SquareAnnotationElement(parameters);
                    case _util2.AnnotationType.CIRCLE:
                      return new CircleAnnotationElement(parameters);
                    case _util2.AnnotationType.POLYLINE:
                      return new PolylineAnnotationElement(parameters);
                    case _util2.AnnotationType.CARET:
                      return new CaretAnnotationElement(parameters);
                    case _util2.AnnotationType.INK:
                      return new InkAnnotationElement(parameters);
                    case _util2.AnnotationType.POLYGON:
                      return new PolygonAnnotationElement(parameters);
                    case _util2.AnnotationType.HIGHLIGHT:
                      return new HighlightAnnotationElement(parameters);
                    case _util2.AnnotationType.UNDERLINE:
                      return new UnderlineAnnotationElement(parameters);
                    case _util2.AnnotationType.SQUIGGLY:
                      return new SquigglyAnnotationElement(parameters);
                    case _util2.AnnotationType.STRIKEOUT:
                      return new StrikeOutAnnotationElement(parameters);
                    case _util2.AnnotationType.STAMP:
                      return new StampAnnotationElement(parameters);
                    case _util2.AnnotationType.FILEATTACHMENT:
                      return new FileAttachmentAnnotationElement(parameters);
                    default:
                      return new AnnotationElement(parameters);
                  }
                }
              }
              class AnnotationElement {
                constructor(parameters) {
                  let {
                    isRenderable = false,
                    ignoreBorder = false,
                    createQuadrilaterals = false
                  } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                  this.isRenderable = isRenderable;
                  this.data = parameters.data;
                  this.layer = parameters.layer;
                  this.page = parameters.page;
                  this.viewport = parameters.viewport;
                  this.linkService = parameters.linkService;
                  this.downloadManager = parameters.downloadManager;
                  this.imageResourcesPath = parameters.imageResourcesPath;
                  this.renderForms = parameters.renderForms;
                  this.svgFactory = parameters.svgFactory;
                  this.annotationStorage = parameters.annotationStorage;
                  this.enableScripting = parameters.enableScripting;
                  this.hasJSActions = parameters.hasJSActions;
                  this._fieldObjects = parameters.fieldObjects;
                  this._mouseState = parameters.mouseState;
                  if (isRenderable) {
                    this.container = this._createContainer(ignoreBorder);
                  }
                  if (createQuadrilaterals) {
                    this.quadrilaterals = this._createQuadrilaterals(ignoreBorder);
                  }
                }
                _createContainer() {
                  let ignoreBorder = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
                  const data = this.data, page = this.page, viewport = this.viewport;
                  const container = document.createElement("section");
                  const {
                    width,
                    height
                  } = getRectDims(data.rect);
                  const [pageLLx, pageLLy, pageURx, pageURy] = viewport.viewBox;
                  const pageWidth = pageURx - pageLLx;
                  const pageHeight = pageURy - pageLLy;
                  container.setAttribute("data-annotation-id", data.id);
                  const rect = _util2.Util.normalizeRect([data.rect[0], page.view[3] - data.rect[1] + page.view[1], data.rect[2], page.view[3] - data.rect[3] + page.view[1]]);
                  if (!ignoreBorder && data.borderStyle.width > 0) {
                    container.style.borderWidth = `${data.borderStyle.width}px`;
                    const horizontalRadius = data.borderStyle.horizontalCornerRadius;
                    const verticalRadius = data.borderStyle.verticalCornerRadius;
                    if (horizontalRadius > 0 || verticalRadius > 0) {
                      const radius = `calc(${horizontalRadius}px * var(--scale-factor)) / calc(${verticalRadius}px * var(--scale-factor))`;
                      container.style.borderRadius = radius;
                    } else if (this instanceof RadioButtonWidgetAnnotationElement) {
                      const radius = `calc(${width}px * var(--scale-factor)) / calc(${height}px * var(--scale-factor))`;
                      container.style.borderRadius = radius;
                    }
                    switch (data.borderStyle.style) {
                      case _util2.AnnotationBorderStyleType.SOLID:
                        container.style.borderStyle = "solid";
                        break;
                      case _util2.AnnotationBorderStyleType.DASHED:
                        container.style.borderStyle = "dashed";
                        break;
                      case _util2.AnnotationBorderStyleType.BEVELED:
                        (0, _util2.warn)("Unimplemented border style: beveled");
                        break;
                      case _util2.AnnotationBorderStyleType.INSET:
                        (0, _util2.warn)("Unimplemented border style: inset");
                        break;
                      case _util2.AnnotationBorderStyleType.UNDERLINE:
                        container.style.borderBottomStyle = "solid";
                        break;
                      default:
                        break;
                    }
                    const borderColor = data.borderColor || null;
                    if (borderColor) {
                      container.style.borderColor = _util2.Util.makeHexColor(borderColor[0] | 0, borderColor[1] | 0, borderColor[2] | 0);
                    } else {
                      container.style.borderWidth = 0;
                    }
                  }
                  container.style.left = `${100 * (rect[0] - pageLLx) / pageWidth}%`;
                  container.style.top = `${100 * (rect[1] - pageLLy) / pageHeight}%`;
                  const {
                    rotation
                  } = data;
                  if (data.hasOwnCanvas || rotation === 0) {
                    container.style.width = `${100 * width / pageWidth}%`;
                    container.style.height = `${100 * height / pageHeight}%`;
                  } else {
                    this.setRotation(rotation, container);
                  }
                  return container;
                }
                setRotation(angle) {
                  let container = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.container;
                  const [pageLLx, pageLLy, pageURx, pageURy] = this.viewport.viewBox;
                  const pageWidth = pageURx - pageLLx;
                  const pageHeight = pageURy - pageLLy;
                  const {
                    width,
                    height
                  } = getRectDims(this.data.rect);
                  let elementWidth, elementHeight;
                  if (angle % 180 === 0) {
                    elementWidth = 100 * width / pageWidth;
                    elementHeight = 100 * height / pageHeight;
                  } else {
                    elementWidth = 100 * height / pageWidth;
                    elementHeight = 100 * width / pageHeight;
                  }
                  container.style.width = `${elementWidth}%`;
                  container.style.height = `${elementHeight}%`;
                  container.setAttribute("data-main-rotation", (360 - angle) % 360);
                }
                get _commonActions() {
                  const setColor = (jsName, styleName, event) => {
                    const color = event.detail[jsName];
                    event.target.style[styleName] = _scripting_utils.ColorConverters[`${color[0]}_HTML`](color.slice(1));
                  };
                  return (0, _util2.shadow)(this, "_commonActions", {
                    display: (event) => {
                      const hidden = event.detail.display % 2 === 1;
                      this.container.style.visibility = hidden ? "hidden" : "visible";
                      this.annotationStorage.setValue(this.data.id, {
                        hidden,
                        print: event.detail.display === 0 || event.detail.display === 3
                      });
                    },
                    print: (event) => {
                      this.annotationStorage.setValue(this.data.id, {
                        print: event.detail.print
                      });
                    },
                    hidden: (event) => {
                      this.container.style.visibility = event.detail.hidden ? "hidden" : "visible";
                      this.annotationStorage.setValue(this.data.id, {
                        hidden: event.detail.hidden
                      });
                    },
                    focus: (event) => {
                      setTimeout(() => event.target.focus({
                        preventScroll: false
                      }), 0);
                    },
                    userName: (event) => {
                      event.target.title = event.detail.userName;
                    },
                    readonly: (event) => {
                      if (event.detail.readonly) {
                        event.target.setAttribute("readonly", "");
                      } else {
                        event.target.removeAttribute("readonly");
                      }
                    },
                    required: (event) => {
                      this._setRequired(event.target, event.detail.required);
                    },
                    bgColor: (event) => {
                      setColor("bgColor", "backgroundColor", event);
                    },
                    fillColor: (event) => {
                      setColor("fillColor", "backgroundColor", event);
                    },
                    fgColor: (event) => {
                      setColor("fgColor", "color", event);
                    },
                    textColor: (event) => {
                      setColor("textColor", "color", event);
                    },
                    borderColor: (event) => {
                      setColor("borderColor", "borderColor", event);
                    },
                    strokeColor: (event) => {
                      setColor("strokeColor", "borderColor", event);
                    },
                    rotation: (event) => {
                      const angle = event.detail.rotation;
                      this.setRotation(angle);
                      this.annotationStorage.setValue(this.data.id, {
                        rotation: angle
                      });
                    }
                  });
                }
                _dispatchEventFromSandbox(actions, jsEvent) {
                  const commonActions = this._commonActions;
                  for (const name of Object.keys(jsEvent.detail)) {
                    const action = actions[name] || commonActions[name];
                    if (action) {
                      action(jsEvent);
                    }
                  }
                }
                _setDefaultPropertiesFromJS(element) {
                  if (!this.enableScripting) {
                    return;
                  }
                  const storedData = this.annotationStorage.getRawValue(this.data.id);
                  if (!storedData) {
                    return;
                  }
                  const commonActions = this._commonActions;
                  for (const [actionName, detail] of Object.entries(storedData)) {
                    const action = commonActions[actionName];
                    if (action) {
                      const eventProxy = {
                        detail: {
                          [actionName]: detail
                        },
                        target: element
                      };
                      action(eventProxy);
                      delete storedData[actionName];
                    }
                  }
                }
                _createQuadrilaterals() {
                  let ignoreBorder = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
                  if (!this.data.quadPoints) {
                    return null;
                  }
                  const quadrilaterals = [];
                  const savedRect = this.data.rect;
                  for (const quadPoint of this.data.quadPoints) {
                    this.data.rect = [quadPoint[2].x, quadPoint[2].y, quadPoint[1].x, quadPoint[1].y];
                    quadrilaterals.push(this._createContainer(ignoreBorder));
                  }
                  this.data.rect = savedRect;
                  return quadrilaterals;
                }
                _createPopup(trigger, data) {
                  let container = this.container;
                  if (this.quadrilaterals) {
                    trigger = trigger || this.quadrilaterals;
                    container = this.quadrilaterals[0];
                  }
                  if (!trigger) {
                    trigger = document.createElement("div");
                    trigger.className = "popupTriggerArea";
                    container.append(trigger);
                  }
                  const popupElement = new PopupElement({
                    container,
                    trigger,
                    color: data.color,
                    titleObj: data.titleObj,
                    modificationDate: data.modificationDate,
                    contentsObj: data.contentsObj,
                    richText: data.richText,
                    hideWrapper: true
                  });
                  const popup = popupElement.render();
                  popup.style.left = "100%";
                  container.append(popup);
                }
                _renderQuadrilaterals(className) {
                  for (const quadrilateral of this.quadrilaterals) {
                    quadrilateral.className = className;
                  }
                  return this.quadrilaterals;
                }
                render() {
                  (0, _util2.unreachable)("Abstract method `AnnotationElement.render` called");
                }
                _getElementsByName(name) {
                  let skipId = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
                  const fields = [];
                  if (this._fieldObjects) {
                    const fieldObj = this._fieldObjects[name];
                    if (fieldObj) {
                      for (const {
                        page,
                        id,
                        exportValues
                      } of fieldObj) {
                        if (page === -1) {
                          continue;
                        }
                        if (id === skipId) {
                          continue;
                        }
                        const exportValue = typeof exportValues === "string" ? exportValues : null;
                        const domElement = document.querySelector(`[data-element-id="${id}"]`);
                        if (domElement && !GetElementsByNameSet.has(domElement)) {
                          (0, _util2.warn)(`_getElementsByName - element not allowed: ${id}`);
                          continue;
                        }
                        fields.push({
                          id,
                          exportValue,
                          domElement
                        });
                      }
                    }
                    return fields;
                  }
                  for (const domElement of document.getElementsByName(name)) {
                    const {
                      id,
                      exportValue
                    } = domElement;
                    if (id === skipId) {
                      continue;
                    }
                    if (!GetElementsByNameSet.has(domElement)) {
                      continue;
                    }
                    fields.push({
                      id,
                      exportValue,
                      domElement
                    });
                  }
                  return fields;
                }
                static get platform() {
                  const platform = typeof navigator !== "undefined" ? navigator.platform : "";
                  return (0, _util2.shadow)(this, "platform", {
                    isWin: platform.includes("Win"),
                    isMac: platform.includes("Mac")
                  });
                }
              }
              class LinkAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
                  super(parameters, {
                    isRenderable: true,
                    ignoreBorder: !!(options !== null && options !== void 0 && options.ignoreBorder),
                    createQuadrilaterals: true
                  });
                  this.isTooltipOnly = parameters.data.isTooltipOnly;
                }
                render() {
                  const {
                    data,
                    linkService
                  } = this;
                  const link = document.createElement("a");
                  link.setAttribute("data-element-id", data.id);
                  let isBound = false;
                  if (data.url) {
                    linkService.addLinkAttributes(link, data.url, data.newWindow);
                    isBound = true;
                  } else if (data.action) {
                    this._bindNamedAction(link, data.action);
                    isBound = true;
                  } else if (data.dest) {
                    this._bindLink(link, data.dest);
                    isBound = true;
                  } else {
                    if (data.actions && (data.actions.Action || data.actions["Mouse Up"] || data.actions["Mouse Down"]) && this.enableScripting && this.hasJSActions) {
                      this._bindJSAction(link, data);
                      isBound = true;
                    }
                    if (data.resetForm) {
                      this._bindResetFormAction(link, data.resetForm);
                      isBound = true;
                    } else if (this.isTooltipOnly && !isBound) {
                      this._bindLink(link, "");
                      isBound = true;
                    }
                  }
                  if (this.quadrilaterals) {
                    return this._renderQuadrilaterals("linkAnnotation").map((quadrilateral, index) => {
                      const linkElement = index === 0 ? link : link.cloneNode();
                      quadrilateral.append(linkElement);
                      return quadrilateral;
                    });
                  }
                  this.container.className = "linkAnnotation";
                  if (isBound) {
                    this.container.append(link);
                  }
                  return this.container;
                }
                _bindLink(link, destination) {
                  link.href = this.linkService.getDestinationHash(destination);
                  link.onclick = () => {
                    if (destination) {
                      this.linkService.goToDestination(destination);
                    }
                    return false;
                  };
                  if (destination || destination === "") {
                    link.className = "internalLink";
                  }
                }
                _bindNamedAction(link, action) {
                  link.href = this.linkService.getAnchorUrl("");
                  link.onclick = () => {
                    this.linkService.executeNamedAction(action);
                    return false;
                  };
                  link.className = "internalLink";
                }
                _bindJSAction(link, data) {
                  link.href = this.linkService.getAnchorUrl("");
                  const map = /* @__PURE__ */ new Map([["Action", "onclick"], ["Mouse Up", "onmouseup"], ["Mouse Down", "onmousedown"]]);
                  for (const name of Object.keys(data.actions)) {
                    const jsName = map.get(name);
                    if (!jsName) {
                      continue;
                    }
                    link[jsName] = () => {
                      var _this$linkService$eve;
                      (_this$linkService$eve = this.linkService.eventBus) === null || _this$linkService$eve === void 0 ? void 0 : _this$linkService$eve.dispatch("dispatcheventinsandbox", {
                        source: this,
                        detail: {
                          id: data.id,
                          name
                        }
                      });
                      return false;
                    };
                  }
                  if (!link.onclick) {
                    link.onclick = () => false;
                  }
                  link.className = "internalLink";
                }
                _bindResetFormAction(link, resetForm) {
                  const otherClickAction = link.onclick;
                  if (!otherClickAction) {
                    link.href = this.linkService.getAnchorUrl("");
                  }
                  link.className = "internalLink";
                  if (!this._fieldObjects) {
                    (0, _util2.warn)(`_bindResetFormAction - "resetForm" action not supported, ensure that the \`fieldObjects\` parameter is provided.`);
                    if (!otherClickAction) {
                      link.onclick = () => false;
                    }
                    return;
                  }
                  link.onclick = () => {
                    if (otherClickAction) {
                      otherClickAction();
                    }
                    const {
                      fields: resetFormFields,
                      refs: resetFormRefs,
                      include
                    } = resetForm;
                    const allFields = [];
                    if (resetFormFields.length !== 0 || resetFormRefs.length !== 0) {
                      const fieldIds = new Set(resetFormRefs);
                      for (const fieldName of resetFormFields) {
                        const fields = this._fieldObjects[fieldName] || [];
                        for (const {
                          id
                        } of fields) {
                          fieldIds.add(id);
                        }
                      }
                      for (const fields of Object.values(this._fieldObjects)) {
                        for (const field of fields) {
                          if (fieldIds.has(field.id) === include) {
                            allFields.push(field);
                          }
                        }
                      }
                    } else {
                      for (const fields of Object.values(this._fieldObjects)) {
                        allFields.push(...fields);
                      }
                    }
                    const storage = this.annotationStorage;
                    const allIds = [];
                    for (const field of allFields) {
                      const {
                        id
                      } = field;
                      allIds.push(id);
                      switch (field.type) {
                        case "text": {
                          const value = field.defaultValue || "";
                          storage.setValue(id, {
                            value
                          });
                          break;
                        }
                        case "checkbox":
                        case "radiobutton": {
                          const value = field.defaultValue === field.exportValues;
                          storage.setValue(id, {
                            value
                          });
                          break;
                        }
                        case "combobox":
                        case "listbox": {
                          const value = field.defaultValue || "";
                          storage.setValue(id, {
                            value
                          });
                          break;
                        }
                        default:
                          continue;
                      }
                      const domElement = document.querySelector(`[data-element-id="${id}"]`);
                      if (!domElement) {
                        continue;
                      } else if (!GetElementsByNameSet.has(domElement)) {
                        (0, _util2.warn)(`_bindResetFormAction - element not allowed: ${id}`);
                        continue;
                      }
                      domElement.dispatchEvent(new Event("resetform"));
                    }
                    if (this.enableScripting) {
                      var _this$linkService$eve2;
                      (_this$linkService$eve2 = this.linkService.eventBus) === null || _this$linkService$eve2 === void 0 ? void 0 : _this$linkService$eve2.dispatch("dispatcheventinsandbox", {
                        source: this,
                        detail: {
                          id: "app",
                          ids: allIds,
                          name: "ResetForm"
                        }
                      });
                    }
                    return false;
                  };
                }
              }
              class TextAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  var _parameters$data$titl, _parameters$data$cont, _parameters$data$rich;
                  const isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl = parameters.data.titleObj) !== null && _parameters$data$titl !== void 0 && _parameters$data$titl.str || (_parameters$data$cont = parameters.data.contentsObj) !== null && _parameters$data$cont !== void 0 && _parameters$data$cont.str || (_parameters$data$rich = parameters.data.richText) !== null && _parameters$data$rich !== void 0 && _parameters$data$rich.str);
                  super(parameters, {
                    isRenderable
                  });
                }
                render() {
                  this.container.className = "textAnnotation";
                  const image = document.createElement("img");
                  image.src = this.imageResourcesPath + "annotation-" + this.data.name.toLowerCase() + ".svg";
                  image.alt = "[{{type}} Annotation]";
                  image.dataset.l10nId = "text_annotation_type";
                  image.dataset.l10nArgs = JSON.stringify({
                    type: this.data.name
                  });
                  if (!this.data.hasPopup) {
                    this._createPopup(image, this.data);
                  }
                  this.container.append(image);
                  return this.container;
                }
              }
              class WidgetAnnotationElement extends AnnotationElement {
                render() {
                  if (this.data.alternativeText) {
                    this.container.title = this.data.alternativeText;
                  }
                  return this.container;
                }
                _getKeyModifier(event) {
                  const {
                    isWin,
                    isMac
                  } = AnnotationElement.platform;
                  return isWin && event.ctrlKey || isMac && event.metaKey;
                }
                _setEventListener(element, baseName, eventName, valueGetter) {
                  if (baseName.includes("mouse")) {
                    element.addEventListener(baseName, (event) => {
                      var _this$linkService$eve3;
                      (_this$linkService$eve3 = this.linkService.eventBus) === null || _this$linkService$eve3 === void 0 ? void 0 : _this$linkService$eve3.dispatch("dispatcheventinsandbox", {
                        source: this,
                        detail: {
                          id: this.data.id,
                          name: eventName,
                          value: valueGetter(event),
                          shift: event.shiftKey,
                          modifier: this._getKeyModifier(event)
                        }
                      });
                    });
                  } else {
                    element.addEventListener(baseName, (event) => {
                      var _this$linkService$eve4;
                      (_this$linkService$eve4 = this.linkService.eventBus) === null || _this$linkService$eve4 === void 0 ? void 0 : _this$linkService$eve4.dispatch("dispatcheventinsandbox", {
                        source: this,
                        detail: {
                          id: this.data.id,
                          name: eventName,
                          value: valueGetter(event)
                        }
                      });
                    });
                  }
                }
                _setEventListeners(element, names, getter) {
                  for (const [baseName, eventName] of names) {
                    var _this$data$actions;
                    if (eventName === "Action" || (_this$data$actions = this.data.actions) !== null && _this$data$actions !== void 0 && _this$data$actions[eventName]) {
                      this._setEventListener(element, baseName, eventName, getter);
                    }
                  }
                }
                _setBackgroundColor(element) {
                  const color = this.data.backgroundColor || null;
                  element.style.backgroundColor = color === null ? "transparent" : _util2.Util.makeHexColor(color[0], color[1], color[2]);
                }
                _setTextStyle(element) {
                  const TEXT_ALIGNMENT = ["left", "center", "right"];
                  const {
                    fontColor
                  } = this.data.defaultAppearanceData;
                  const fontSize = this.data.defaultAppearanceData.fontSize || DEFAULT_FONT_SIZE;
                  const style = element.style;
                  let computedFontSize;
                  if (this.data.multiLine) {
                    const height = Math.abs(this.data.rect[3] - this.data.rect[1]);
                    const numberOfLines = Math.round(height / (_util2.LINE_FACTOR * fontSize)) || 1;
                    const lineHeight = height / numberOfLines;
                    computedFontSize = Math.min(fontSize, Math.round(lineHeight / _util2.LINE_FACTOR));
                  } else {
                    const height = Math.abs(this.data.rect[3] - this.data.rect[1]);
                    computedFontSize = Math.min(fontSize, Math.round(height / _util2.LINE_FACTOR));
                  }
                  style.fontSize = `calc(${computedFontSize}px * var(--scale-factor))`;
                  style.color = _util2.Util.makeHexColor(fontColor[0], fontColor[1], fontColor[2]);
                  if (this.data.textAlignment !== null) {
                    style.textAlign = TEXT_ALIGNMENT[this.data.textAlignment];
                  }
                }
                _setRequired(element, isRequired) {
                  if (isRequired) {
                    element.setAttribute("required", true);
                  } else {
                    element.removeAttribute("required");
                  }
                  element.setAttribute("aria-required", isRequired);
                }
              }
              class TextWidgetAnnotationElement extends WidgetAnnotationElement {
                constructor(parameters) {
                  const isRenderable = parameters.renderForms || !parameters.data.hasAppearance && !!parameters.data.fieldValue;
                  super(parameters, {
                    isRenderable
                  });
                }
                setPropertyOnSiblings(base, key, value, keyInStorage) {
                  const storage = this.annotationStorage;
                  for (const element of this._getElementsByName(base.name, base.id)) {
                    if (element.domElement) {
                      element.domElement[key] = value;
                    }
                    storage.setValue(element.id, {
                      [keyInStorage]: value
                    });
                  }
                }
                render() {
                  const storage = this.annotationStorage;
                  const id = this.data.id;
                  this.container.className = "textWidgetAnnotation";
                  let element = null;
                  if (this.renderForms) {
                    const storedData = storage.getValue(id, {
                      value: this.data.fieldValue
                    });
                    let textContent = storedData.formattedValue || storedData.value || "";
                    const maxLen = storage.getValue(id, {
                      charLimit: this.data.maxLen
                    }).charLimit;
                    if (maxLen && textContent.length > maxLen) {
                      textContent = textContent.slice(0, maxLen);
                    }
                    const elementData = {
                      userValue: textContent,
                      formattedValue: null,
                      valueOnFocus: ""
                    };
                    if (this.data.multiLine) {
                      element = document.createElement("textarea");
                      element.textContent = textContent;
                      if (this.data.doNotScroll) {
                        element.style.overflowY = "hidden";
                      }
                    } else {
                      element = document.createElement("input");
                      element.type = "text";
                      element.setAttribute("value", textContent);
                      if (this.data.doNotScroll) {
                        element.style.overflowX = "hidden";
                      }
                    }
                    GetElementsByNameSet.add(element);
                    element.setAttribute("data-element-id", id);
                    element.disabled = this.data.readOnly;
                    element.name = this.data.fieldName;
                    element.tabIndex = DEFAULT_TAB_INDEX;
                    this._setRequired(element, this.data.required);
                    if (maxLen) {
                      element.maxLength = maxLen;
                    }
                    element.addEventListener("input", (event) => {
                      storage.setValue(id, {
                        value: event.target.value
                      });
                      this.setPropertyOnSiblings(element, "value", event.target.value, "value");
                    });
                    element.addEventListener("resetform", (event) => {
                      var _this$data$defaultFie;
                      const defaultValue = (_this$data$defaultFie = this.data.defaultFieldValue) !== null && _this$data$defaultFie !== void 0 ? _this$data$defaultFie : "";
                      element.value = elementData.userValue = defaultValue;
                      elementData.formattedValue = null;
                    });
                    let blurListener = (event) => {
                      const {
                        formattedValue
                      } = elementData;
                      if (formattedValue !== null && formattedValue !== void 0) {
                        event.target.value = formattedValue;
                      }
                      event.target.scrollLeft = 0;
                    };
                    if (this.enableScripting && this.hasJSActions) {
                      var _this$data$actions2;
                      element.addEventListener("focus", (event) => {
                        if (elementData.userValue) {
                          event.target.value = elementData.userValue;
                        }
                        elementData.valueOnFocus = event.target.value;
                      });
                      element.addEventListener("updatefromsandbox", (jsEvent) => {
                        const actions = {
                          value(event) {
                            var _event$detail$value;
                            elementData.userValue = (_event$detail$value = event.detail.value) !== null && _event$detail$value !== void 0 ? _event$detail$value : "";
                            storage.setValue(id, {
                              value: elementData.userValue.toString()
                            });
                            event.target.value = elementData.userValue;
                          },
                          formattedValue(event) {
                            const {
                              formattedValue
                            } = event.detail;
                            elementData.formattedValue = formattedValue;
                            if (formattedValue !== null && formattedValue !== void 0 && event.target !== document.activeElement) {
                              event.target.value = formattedValue;
                            }
                            storage.setValue(id, {
                              formattedValue
                            });
                          },
                          selRange(event) {
                            event.target.setSelectionRange(...event.detail.selRange);
                          },
                          charLimit: (event) => {
                            var _this$linkService$eve5;
                            const {
                              charLimit
                            } = event.detail;
                            const {
                              target
                            } = event;
                            if (charLimit === 0) {
                              target.removeAttribute("maxLength");
                              return;
                            }
                            target.setAttribute("maxLength", charLimit);
                            let value = elementData.userValue;
                            if (!value || value.length <= charLimit) {
                              return;
                            }
                            value = value.slice(0, charLimit);
                            target.value = elementData.userValue = value;
                            storage.setValue(id, {
                              value
                            });
                            (_this$linkService$eve5 = this.linkService.eventBus) === null || _this$linkService$eve5 === void 0 ? void 0 : _this$linkService$eve5.dispatch("dispatcheventinsandbox", {
                              source: this,
                              detail: {
                                id,
                                name: "Keystroke",
                                value,
                                willCommit: true,
                                commitKey: 1,
                                selStart: target.selectionStart,
                                selEnd: target.selectionEnd
                              }
                            });
                          }
                        };
                        this._dispatchEventFromSandbox(actions, jsEvent);
                      });
                      element.addEventListener("keydown", (event) => {
                        var _this$linkService$eve6;
                        let commitKey = -1;
                        if (event.key === "Escape") {
                          commitKey = 0;
                        } else if (event.key === "Enter") {
                          commitKey = 2;
                        } else if (event.key === "Tab") {
                          commitKey = 3;
                        }
                        if (commitKey === -1) {
                          return;
                        }
                        const {
                          value
                        } = event.target;
                        if (elementData.valueOnFocus === value) {
                          return;
                        }
                        elementData.userValue = value;
                        (_this$linkService$eve6 = this.linkService.eventBus) === null || _this$linkService$eve6 === void 0 ? void 0 : _this$linkService$eve6.dispatch("dispatcheventinsandbox", {
                          source: this,
                          detail: {
                            id,
                            name: "Keystroke",
                            value,
                            willCommit: true,
                            commitKey,
                            selStart: event.target.selectionStart,
                            selEnd: event.target.selectionEnd
                          }
                        });
                      });
                      const _blurListener = blurListener;
                      blurListener = null;
                      element.addEventListener("blur", (event) => {
                        const {
                          value
                        } = event.target;
                        elementData.userValue = value;
                        if (this._mouseState.isDown && elementData.valueOnFocus !== value) {
                          var _this$linkService$eve7;
                          (_this$linkService$eve7 = this.linkService.eventBus) === null || _this$linkService$eve7 === void 0 ? void 0 : _this$linkService$eve7.dispatch("dispatcheventinsandbox", {
                            source: this,
                            detail: {
                              id,
                              name: "Keystroke",
                              value,
                              willCommit: true,
                              commitKey: 1,
                              selStart: event.target.selectionStart,
                              selEnd: event.target.selectionEnd
                            }
                          });
                        }
                        _blurListener(event);
                      });
                      if ((_this$data$actions2 = this.data.actions) !== null && _this$data$actions2 !== void 0 && _this$data$actions2.Keystroke) {
                        element.addEventListener("beforeinput", (event) => {
                          var _this$linkService$eve8;
                          const {
                            data,
                            target
                          } = event;
                          const {
                            value,
                            selectionStart,
                            selectionEnd
                          } = target;
                          let selStart = selectionStart, selEnd = selectionEnd;
                          switch (event.inputType) {
                            case "deleteWordBackward": {
                              const match = value.substring(0, selectionStart).match(/\w*[^\w]*$/);
                              if (match) {
                                selStart -= match[0].length;
                              }
                              break;
                            }
                            case "deleteWordForward": {
                              const match = value.substring(selectionStart).match(/^[^\w]*\w*/);
                              if (match) {
                                selEnd += match[0].length;
                              }
                              break;
                            }
                            case "deleteContentBackward":
                              if (selectionStart === selectionEnd) {
                                selStart -= 1;
                              }
                              break;
                            case "deleteContentForward":
                              if (selectionStart === selectionEnd) {
                                selEnd += 1;
                              }
                              break;
                          }
                          event.preventDefault();
                          (_this$linkService$eve8 = this.linkService.eventBus) === null || _this$linkService$eve8 === void 0 ? void 0 : _this$linkService$eve8.dispatch("dispatcheventinsandbox", {
                            source: this,
                            detail: {
                              id,
                              name: "Keystroke",
                              value,
                              change: data || "",
                              willCommit: false,
                              selStart,
                              selEnd
                            }
                          });
                        });
                      }
                      this._setEventListeners(element, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (event) => event.target.value);
                    }
                    if (blurListener) {
                      element.addEventListener("blur", blurListener);
                    }
                    if (this.data.comb) {
                      const fieldWidth = this.data.rect[2] - this.data.rect[0];
                      const combWidth = fieldWidth / maxLen;
                      element.classList.add("comb");
                      element.style.letterSpacing = `calc(${combWidth}px * var(--scale-factor) - 1ch)`;
                    }
                  } else {
                    element = document.createElement("div");
                    element.textContent = this.data.fieldValue;
                    element.style.verticalAlign = "middle";
                    element.style.display = "table-cell";
                  }
                  this._setTextStyle(element);
                  this._setBackgroundColor(element);
                  this._setDefaultPropertiesFromJS(element);
                  this.container.append(element);
                  return this.container;
                }
              }
              class CheckboxWidgetAnnotationElement extends WidgetAnnotationElement {
                constructor(parameters) {
                  super(parameters, {
                    isRenderable: parameters.renderForms
                  });
                }
                render() {
                  const storage = this.annotationStorage;
                  const data = this.data;
                  const id = data.id;
                  let value = storage.getValue(id, {
                    value: data.exportValue === data.fieldValue
                  }).value;
                  if (typeof value === "string") {
                    value = value !== "Off";
                    storage.setValue(id, {
                      value
                    });
                  }
                  this.container.className = "buttonWidgetAnnotation checkBox";
                  const element = document.createElement("input");
                  GetElementsByNameSet.add(element);
                  element.setAttribute("data-element-id", id);
                  element.disabled = data.readOnly;
                  this._setRequired(element, this.data.required);
                  element.type = "checkbox";
                  element.name = data.fieldName;
                  if (value) {
                    element.setAttribute("checked", true);
                  }
                  element.setAttribute("exportValue", data.exportValue);
                  element.tabIndex = DEFAULT_TAB_INDEX;
                  element.addEventListener("change", (event) => {
                    const {
                      name,
                      checked
                    } = event.target;
                    for (const checkbox of this._getElementsByName(name, id)) {
                      const curChecked = checked && checkbox.exportValue === data.exportValue;
                      if (checkbox.domElement) {
                        checkbox.domElement.checked = curChecked;
                      }
                      storage.setValue(checkbox.id, {
                        value: curChecked
                      });
                    }
                    storage.setValue(id, {
                      value: checked
                    });
                  });
                  element.addEventListener("resetform", (event) => {
                    const defaultValue = data.defaultFieldValue || "Off";
                    event.target.checked = defaultValue === data.exportValue;
                  });
                  if (this.enableScripting && this.hasJSActions) {
                    element.addEventListener("updatefromsandbox", (jsEvent) => {
                      const actions = {
                        value(event) {
                          event.target.checked = event.detail.value !== "Off";
                          storage.setValue(id, {
                            value: event.target.checked
                          });
                        }
                      };
                      this._dispatchEventFromSandbox(actions, jsEvent);
                    });
                    this._setEventListeners(element, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (event) => event.target.checked);
                  }
                  this._setBackgroundColor(element);
                  this._setDefaultPropertiesFromJS(element);
                  this.container.append(element);
                  return this.container;
                }
              }
              class RadioButtonWidgetAnnotationElement extends WidgetAnnotationElement {
                constructor(parameters) {
                  super(parameters, {
                    isRenderable: parameters.renderForms
                  });
                }
                render() {
                  this.container.className = "buttonWidgetAnnotation radioButton";
                  const storage = this.annotationStorage;
                  const data = this.data;
                  const id = data.id;
                  let value = storage.getValue(id, {
                    value: data.fieldValue === data.buttonValue
                  }).value;
                  if (typeof value === "string") {
                    value = value !== data.buttonValue;
                    storage.setValue(id, {
                      value
                    });
                  }
                  const element = document.createElement("input");
                  GetElementsByNameSet.add(element);
                  element.setAttribute("data-element-id", id);
                  element.disabled = data.readOnly;
                  this._setRequired(element, this.data.required);
                  element.type = "radio";
                  element.name = data.fieldName;
                  if (value) {
                    element.setAttribute("checked", true);
                  }
                  element.tabIndex = DEFAULT_TAB_INDEX;
                  element.addEventListener("change", (event) => {
                    const {
                      name,
                      checked
                    } = event.target;
                    for (const radio of this._getElementsByName(name, id)) {
                      storage.setValue(radio.id, {
                        value: false
                      });
                    }
                    storage.setValue(id, {
                      value: checked
                    });
                  });
                  element.addEventListener("resetform", (event) => {
                    const defaultValue = data.defaultFieldValue;
                    event.target.checked = defaultValue !== null && defaultValue !== void 0 && defaultValue === data.buttonValue;
                  });
                  if (this.enableScripting && this.hasJSActions) {
                    const pdfButtonValue = data.buttonValue;
                    element.addEventListener("updatefromsandbox", (jsEvent) => {
                      const actions = {
                        value: (event) => {
                          const checked = pdfButtonValue === event.detail.value;
                          for (const radio of this._getElementsByName(event.target.name)) {
                            const curChecked = checked && radio.id === id;
                            if (radio.domElement) {
                              radio.domElement.checked = curChecked;
                            }
                            storage.setValue(radio.id, {
                              value: curChecked
                            });
                          }
                        }
                      };
                      this._dispatchEventFromSandbox(actions, jsEvent);
                    });
                    this._setEventListeners(element, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (event) => event.target.checked);
                  }
                  this._setBackgroundColor(element);
                  this._setDefaultPropertiesFromJS(element);
                  this.container.append(element);
                  return this.container;
                }
              }
              class PushButtonWidgetAnnotationElement extends LinkAnnotationElement {
                constructor(parameters) {
                  super(parameters, {
                    ignoreBorder: parameters.data.hasAppearance
                  });
                }
                render() {
                  const container = super.render();
                  container.className = "buttonWidgetAnnotation pushButton";
                  if (this.data.alternativeText) {
                    container.title = this.data.alternativeText;
                  }
                  const linkElement = container.lastChild;
                  if (this.enableScripting && this.hasJSActions && linkElement) {
                    this._setDefaultPropertiesFromJS(linkElement);
                    linkElement.addEventListener("updatefromsandbox", (jsEvent) => {
                      this._dispatchEventFromSandbox({}, jsEvent);
                    });
                  }
                  return container;
                }
              }
              class ChoiceWidgetAnnotationElement extends WidgetAnnotationElement {
                constructor(parameters) {
                  super(parameters, {
                    isRenderable: parameters.renderForms
                  });
                }
                render() {
                  this.container.className = "choiceWidgetAnnotation";
                  const storage = this.annotationStorage;
                  const id = this.data.id;
                  const storedData = storage.getValue(id, {
                    value: this.data.fieldValue
                  });
                  const selectElement = document.createElement("select");
                  GetElementsByNameSet.add(selectElement);
                  selectElement.setAttribute("data-element-id", id);
                  selectElement.disabled = this.data.readOnly;
                  this._setRequired(selectElement, this.data.required);
                  selectElement.name = this.data.fieldName;
                  selectElement.tabIndex = DEFAULT_TAB_INDEX;
                  let addAnEmptyEntry = this.data.combo && this.data.options.length > 0;
                  if (!this.data.combo) {
                    selectElement.size = this.data.options.length;
                    if (this.data.multiSelect) {
                      selectElement.multiple = true;
                    }
                  }
                  selectElement.addEventListener("resetform", (event) => {
                    const defaultValue = this.data.defaultFieldValue;
                    for (const option of selectElement.options) {
                      option.selected = option.value === defaultValue;
                    }
                  });
                  for (const option of this.data.options) {
                    const optionElement = document.createElement("option");
                    optionElement.textContent = option.displayValue;
                    optionElement.value = option.exportValue;
                    if (storedData.value.includes(option.exportValue)) {
                      optionElement.setAttribute("selected", true);
                      addAnEmptyEntry = false;
                    }
                    selectElement.append(optionElement);
                  }
                  let removeEmptyEntry = null;
                  if (addAnEmptyEntry) {
                    const noneOptionElement = document.createElement("option");
                    noneOptionElement.value = " ";
                    noneOptionElement.setAttribute("hidden", true);
                    noneOptionElement.setAttribute("selected", true);
                    selectElement.prepend(noneOptionElement);
                    removeEmptyEntry = () => {
                      noneOptionElement.remove();
                      selectElement.removeEventListener("input", removeEmptyEntry);
                      removeEmptyEntry = null;
                    };
                    selectElement.addEventListener("input", removeEmptyEntry);
                  }
                  const getValue = (event, isExport) => {
                    const name = isExport ? "value" : "textContent";
                    const options = event.target.options;
                    if (!event.target.multiple) {
                      return options.selectedIndex === -1 ? null : options[options.selectedIndex][name];
                    }
                    return Array.prototype.filter.call(options, (option) => option.selected).map((option) => option[name]);
                  };
                  const getItems = (event) => {
                    const options = event.target.options;
                    return Array.prototype.map.call(options, (option) => {
                      return {
                        displayValue: option.textContent,
                        exportValue: option.value
                      };
                    });
                  };
                  if (this.enableScripting && this.hasJSActions) {
                    selectElement.addEventListener("updatefromsandbox", (jsEvent) => {
                      const actions = {
                        value(event) {
                          var _removeEmptyEntry;
                          (_removeEmptyEntry = removeEmptyEntry) === null || _removeEmptyEntry === void 0 ? void 0 : _removeEmptyEntry();
                          const value = event.detail.value;
                          const values = new Set(Array.isArray(value) ? value : [value]);
                          for (const option of selectElement.options) {
                            option.selected = values.has(option.value);
                          }
                          storage.setValue(id, {
                            value: getValue(event, true)
                          });
                        },
                        multipleSelection(event) {
                          selectElement.multiple = true;
                        },
                        remove(event) {
                          const options = selectElement.options;
                          const index = event.detail.remove;
                          options[index].selected = false;
                          selectElement.remove(index);
                          if (options.length > 0) {
                            const i = Array.prototype.findIndex.call(options, (option) => option.selected);
                            if (i === -1) {
                              options[0].selected = true;
                            }
                          }
                          storage.setValue(id, {
                            value: getValue(event, true),
                            items: getItems(event)
                          });
                        },
                        clear(event) {
                          while (selectElement.length !== 0) {
                            selectElement.remove(0);
                          }
                          storage.setValue(id, {
                            value: null,
                            items: []
                          });
                        },
                        insert(event) {
                          const {
                            index,
                            displayValue,
                            exportValue
                          } = event.detail.insert;
                          const selectChild = selectElement.children[index];
                          const optionElement = document.createElement("option");
                          optionElement.textContent = displayValue;
                          optionElement.value = exportValue;
                          if (selectChild) {
                            selectChild.before(optionElement);
                          } else {
                            selectElement.append(optionElement);
                          }
                          storage.setValue(id, {
                            value: getValue(event, true),
                            items: getItems(event)
                          });
                        },
                        items(event) {
                          const {
                            items
                          } = event.detail;
                          while (selectElement.length !== 0) {
                            selectElement.remove(0);
                          }
                          for (const item of items) {
                            const {
                              displayValue,
                              exportValue
                            } = item;
                            const optionElement = document.createElement("option");
                            optionElement.textContent = displayValue;
                            optionElement.value = exportValue;
                            selectElement.append(optionElement);
                          }
                          if (selectElement.options.length > 0) {
                            selectElement.options[0].selected = true;
                          }
                          storage.setValue(id, {
                            value: getValue(event, true),
                            items: getItems(event)
                          });
                        },
                        indices(event) {
                          const indices = new Set(event.detail.indices);
                          for (const option of event.target.options) {
                            option.selected = indices.has(option.index);
                          }
                          storage.setValue(id, {
                            value: getValue(event, true)
                          });
                        },
                        editable(event) {
                          event.target.disabled = !event.detail.editable;
                        }
                      };
                      this._dispatchEventFromSandbox(actions, jsEvent);
                    });
                    selectElement.addEventListener("input", (event) => {
                      var _this$linkService$eve9;
                      const exportValue = getValue(event, true);
                      const value = getValue(event, false);
                      storage.setValue(id, {
                        value: exportValue
                      });
                      (_this$linkService$eve9 = this.linkService.eventBus) === null || _this$linkService$eve9 === void 0 ? void 0 : _this$linkService$eve9.dispatch("dispatcheventinsandbox", {
                        source: this,
                        detail: {
                          id,
                          name: "Keystroke",
                          value,
                          changeEx: exportValue,
                          willCommit: true,
                          commitKey: 1,
                          keyDown: false
                        }
                      });
                    });
                    this._setEventListeners(selectElement, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"], ["input", "Action"]], (event) => event.target.checked);
                  } else {
                    selectElement.addEventListener("input", function(event) {
                      storage.setValue(id, {
                        value: getValue(event, true)
                      });
                    });
                  }
                  if (this.data.combo) {
                    this._setTextStyle(selectElement);
                  } else {
                  }
                  this._setBackgroundColor(selectElement);
                  this._setDefaultPropertiesFromJS(selectElement);
                  this.container.append(selectElement);
                  return this.container;
                }
              }
              class PopupAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  var _parameters$data$titl2, _parameters$data$cont2, _parameters$data$rich2;
                  const isRenderable = !!((_parameters$data$titl2 = parameters.data.titleObj) !== null && _parameters$data$titl2 !== void 0 && _parameters$data$titl2.str || (_parameters$data$cont2 = parameters.data.contentsObj) !== null && _parameters$data$cont2 !== void 0 && _parameters$data$cont2.str || (_parameters$data$rich2 = parameters.data.richText) !== null && _parameters$data$rich2 !== void 0 && _parameters$data$rich2.str);
                  super(parameters, {
                    isRenderable
                  });
                }
                render() {
                  const IGNORE_TYPES = ["Line", "Square", "Circle", "PolyLine", "Polygon", "Ink"];
                  this.container.className = "popupAnnotation";
                  if (IGNORE_TYPES.includes(this.data.parentType)) {
                    return this.container;
                  }
                  const selector = `[data-annotation-id="${this.data.parentId}"]`;
                  const parentElements = this.layer.querySelectorAll(selector);
                  if (parentElements.length === 0) {
                    return this.container;
                  }
                  const popup = new PopupElement({
                    container: this.container,
                    trigger: Array.from(parentElements),
                    color: this.data.color,
                    titleObj: this.data.titleObj,
                    modificationDate: this.data.modificationDate,
                    contentsObj: this.data.contentsObj,
                    richText: this.data.richText
                  });
                  const page = this.page;
                  const rect = _util2.Util.normalizeRect([this.data.parentRect[0], page.view[3] - this.data.parentRect[1] + page.view[1], this.data.parentRect[2], page.view[3] - this.data.parentRect[3] + page.view[1]]);
                  const popupLeft = rect[0] + this.data.parentRect[2] - this.data.parentRect[0];
                  const popupTop = rect[1];
                  const [pageLLx, pageLLy, pageURx, pageURy] = this.viewport.viewBox;
                  const pageWidth = pageURx - pageLLx;
                  const pageHeight = pageURy - pageLLy;
                  this.container.style.left = `${100 * (popupLeft - pageLLx) / pageWidth}%`;
                  this.container.style.top = `${100 * (popupTop - pageLLy) / pageHeight}%`;
                  this.container.append(popup.render());
                  return this.container;
                }
              }
              class PopupElement {
                constructor(parameters) {
                  this.container = parameters.container;
                  this.trigger = parameters.trigger;
                  this.color = parameters.color;
                  this.titleObj = parameters.titleObj;
                  this.modificationDate = parameters.modificationDate;
                  this.contentsObj = parameters.contentsObj;
                  this.richText = parameters.richText;
                  this.hideWrapper = parameters.hideWrapper || false;
                  this.pinned = false;
                }
                render() {
                  var _this$richText, _this$contentsObj;
                  const BACKGROUND_ENLIGHT = 0.7;
                  const wrapper = document.createElement("div");
                  wrapper.className = "popupWrapper";
                  this.hideElement = this.hideWrapper ? wrapper : this.container;
                  this.hideElement.hidden = true;
                  const popup = document.createElement("div");
                  popup.className = "popup";
                  const color = this.color;
                  if (color) {
                    const r2 = BACKGROUND_ENLIGHT * (255 - color[0]) + color[0];
                    const g = BACKGROUND_ENLIGHT * (255 - color[1]) + color[1];
                    const b = BACKGROUND_ENLIGHT * (255 - color[2]) + color[2];
                    popup.style.backgroundColor = _util2.Util.makeHexColor(r2 | 0, g | 0, b | 0);
                  }
                  const title = document.createElement("h1");
                  title.dir = this.titleObj.dir;
                  title.textContent = this.titleObj.str;
                  popup.append(title);
                  const dateObject = _display_utils2.PDFDateString.toDateObject(this.modificationDate);
                  if (dateObject) {
                    const modificationDate = document.createElement("span");
                    modificationDate.className = "popupDate";
                    modificationDate.textContent = "{{date}}, {{time}}";
                    modificationDate.dataset.l10nId = "annotation_date_string";
                    modificationDate.dataset.l10nArgs = JSON.stringify({
                      date: dateObject.toLocaleDateString(),
                      time: dateObject.toLocaleTimeString()
                    });
                    popup.append(modificationDate);
                  }
                  if ((_this$richText = this.richText) !== null && _this$richText !== void 0 && _this$richText.str && (!((_this$contentsObj = this.contentsObj) !== null && _this$contentsObj !== void 0 && _this$contentsObj.str) || this.contentsObj.str === this.richText.str)) {
                    _xfa_layer.XfaLayer.render({
                      xfaHtml: this.richText.html,
                      intent: "richText",
                      div: popup
                    });
                    popup.lastChild.className = "richText popupContent";
                  } else {
                    const contents = this._formatContents(this.contentsObj);
                    popup.append(contents);
                  }
                  if (!Array.isArray(this.trigger)) {
                    this.trigger = [this.trigger];
                  }
                  for (const element of this.trigger) {
                    element.addEventListener("click", this._toggle.bind(this));
                    element.addEventListener("mouseover", this._show.bind(this, false));
                    element.addEventListener("mouseout", this._hide.bind(this, false));
                  }
                  popup.addEventListener("click", this._hide.bind(this, true));
                  wrapper.append(popup);
                  return wrapper;
                }
                _formatContents(_ref) {
                  let {
                    str,
                    dir
                  } = _ref;
                  const p = document.createElement("p");
                  p.className = "popupContent";
                  p.dir = dir;
                  const lines = str.split(/(?:\r\n?|\n)/);
                  for (let i = 0, ii = lines.length; i < ii; ++i) {
                    const line = lines[i];
                    p.append(document.createTextNode(line));
                    if (i < ii - 1) {
                      p.append(document.createElement("br"));
                    }
                  }
                  return p;
                }
                _toggle() {
                  if (this.pinned) {
                    this._hide(true);
                  } else {
                    this._show(true);
                  }
                }
                _show() {
                  let pin = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
                  if (pin) {
                    this.pinned = true;
                  }
                  if (this.hideElement.hidden) {
                    this.hideElement.hidden = false;
                    this.container.style.zIndex = parseInt(this.container.style.zIndex) + 1e3;
                  }
                }
                _hide() {
                  let unpin = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
                  if (unpin) {
                    this.pinned = false;
                  }
                  if (!this.hideElement.hidden && !this.pinned) {
                    this.hideElement.hidden = true;
                    this.container.style.zIndex = parseInt(this.container.style.zIndex) - 1e3;
                  }
                }
              }
              class FreeTextAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  var _parameters$data$titl3, _parameters$data$cont3, _parameters$data$rich3;
                  const isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl3 = parameters.data.titleObj) !== null && _parameters$data$titl3 !== void 0 && _parameters$data$titl3.str || (_parameters$data$cont3 = parameters.data.contentsObj) !== null && _parameters$data$cont3 !== void 0 && _parameters$data$cont3.str || (_parameters$data$rich3 = parameters.data.richText) !== null && _parameters$data$rich3 !== void 0 && _parameters$data$rich3.str);
                  super(parameters, {
                    isRenderable,
                    ignoreBorder: true
                  });
                  this.textContent = parameters.data.textContent;
                }
                render() {
                  this.container.className = "freeTextAnnotation";
                  if (this.textContent) {
                    const content = document.createElement("div");
                    content.className = "annotationTextContent";
                    content.setAttribute("role", "comment");
                    for (const line of this.textContent) {
                      const lineSpan = document.createElement("span");
                      lineSpan.textContent = line;
                      content.append(lineSpan);
                    }
                    this.container.append(content);
                  }
                  if (!this.data.hasPopup) {
                    this._createPopup(null, this.data);
                  }
                  return this.container;
                }
              }
              class LineAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  var _parameters$data$titl4, _parameters$data$cont4, _parameters$data$rich4;
                  const isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl4 = parameters.data.titleObj) !== null && _parameters$data$titl4 !== void 0 && _parameters$data$titl4.str || (_parameters$data$cont4 = parameters.data.contentsObj) !== null && _parameters$data$cont4 !== void 0 && _parameters$data$cont4.str || (_parameters$data$rich4 = parameters.data.richText) !== null && _parameters$data$rich4 !== void 0 && _parameters$data$rich4.str);
                  super(parameters, {
                    isRenderable,
                    ignoreBorder: true
                  });
                }
                render() {
                  this.container.className = "lineAnnotation";
                  const data = this.data;
                  const {
                    width,
                    height
                  } = getRectDims(data.rect);
                  const svg = this.svgFactory.create(width, height, true);
                  const line = this.svgFactory.createElement("svg:line");
                  line.setAttribute("x1", data.rect[2] - data.lineCoordinates[0]);
                  line.setAttribute("y1", data.rect[3] - data.lineCoordinates[1]);
                  line.setAttribute("x2", data.rect[2] - data.lineCoordinates[2]);
                  line.setAttribute("y2", data.rect[3] - data.lineCoordinates[3]);
                  line.setAttribute("stroke-width", data.borderStyle.width || 1);
                  line.setAttribute("stroke", "transparent");
                  line.setAttribute("fill", "transparent");
                  svg.append(line);
                  this.container.append(svg);
                  this._createPopup(line, data);
                  return this.container;
                }
              }
              class SquareAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  var _parameters$data$titl5, _parameters$data$cont5, _parameters$data$rich5;
                  const isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl5 = parameters.data.titleObj) !== null && _parameters$data$titl5 !== void 0 && _parameters$data$titl5.str || (_parameters$data$cont5 = parameters.data.contentsObj) !== null && _parameters$data$cont5 !== void 0 && _parameters$data$cont5.str || (_parameters$data$rich5 = parameters.data.richText) !== null && _parameters$data$rich5 !== void 0 && _parameters$data$rich5.str);
                  super(parameters, {
                    isRenderable,
                    ignoreBorder: true
                  });
                }
                render() {
                  this.container.className = "squareAnnotation";
                  const data = this.data;
                  const {
                    width,
                    height
                  } = getRectDims(data.rect);
                  const svg = this.svgFactory.create(width, height, true);
                  const borderWidth = data.borderStyle.width;
                  const square = this.svgFactory.createElement("svg:rect");
                  square.setAttribute("x", borderWidth / 2);
                  square.setAttribute("y", borderWidth / 2);
                  square.setAttribute("width", width - borderWidth);
                  square.setAttribute("height", height - borderWidth);
                  square.setAttribute("stroke-width", borderWidth || 1);
                  square.setAttribute("stroke", "transparent");
                  square.setAttribute("fill", "transparent");
                  svg.append(square);
                  this.container.append(svg);
                  this._createPopup(square, data);
                  return this.container;
                }
              }
              class CircleAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  var _parameters$data$titl6, _parameters$data$cont6, _parameters$data$rich6;
                  const isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl6 = parameters.data.titleObj) !== null && _parameters$data$titl6 !== void 0 && _parameters$data$titl6.str || (_parameters$data$cont6 = parameters.data.contentsObj) !== null && _parameters$data$cont6 !== void 0 && _parameters$data$cont6.str || (_parameters$data$rich6 = parameters.data.richText) !== null && _parameters$data$rich6 !== void 0 && _parameters$data$rich6.str);
                  super(parameters, {
                    isRenderable,
                    ignoreBorder: true
                  });
                }
                render() {
                  this.container.className = "circleAnnotation";
                  const data = this.data;
                  const {
                    width,
                    height
                  } = getRectDims(data.rect);
                  const svg = this.svgFactory.create(width, height, true);
                  const borderWidth = data.borderStyle.width;
                  const circle = this.svgFactory.createElement("svg:ellipse");
                  circle.setAttribute("cx", width / 2);
                  circle.setAttribute("cy", height / 2);
                  circle.setAttribute("rx", width / 2 - borderWidth / 2);
                  circle.setAttribute("ry", height / 2 - borderWidth / 2);
                  circle.setAttribute("stroke-width", borderWidth || 1);
                  circle.setAttribute("stroke", "transparent");
                  circle.setAttribute("fill", "transparent");
                  svg.append(circle);
                  this.container.append(svg);
                  this._createPopup(circle, data);
                  return this.container;
                }
              }
              class PolylineAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  var _parameters$data$titl7, _parameters$data$cont7, _parameters$data$rich7;
                  const isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl7 = parameters.data.titleObj) !== null && _parameters$data$titl7 !== void 0 && _parameters$data$titl7.str || (_parameters$data$cont7 = parameters.data.contentsObj) !== null && _parameters$data$cont7 !== void 0 && _parameters$data$cont7.str || (_parameters$data$rich7 = parameters.data.richText) !== null && _parameters$data$rich7 !== void 0 && _parameters$data$rich7.str);
                  super(parameters, {
                    isRenderable,
                    ignoreBorder: true
                  });
                  this.containerClassName = "polylineAnnotation";
                  this.svgElementName = "svg:polyline";
                }
                render() {
                  this.container.className = this.containerClassName;
                  const data = this.data;
                  const {
                    width,
                    height
                  } = getRectDims(data.rect);
                  const svg = this.svgFactory.create(width, height, true);
                  let points = [];
                  for (const coordinate of data.vertices) {
                    const x = coordinate.x - data.rect[0];
                    const y = data.rect[3] - coordinate.y;
                    points.push(x + "," + y);
                  }
                  points = points.join(" ");
                  const polyline = this.svgFactory.createElement(this.svgElementName);
                  polyline.setAttribute("points", points);
                  polyline.setAttribute("stroke-width", data.borderStyle.width || 1);
                  polyline.setAttribute("stroke", "transparent");
                  polyline.setAttribute("fill", "transparent");
                  svg.append(polyline);
                  this.container.append(svg);
                  this._createPopup(polyline, data);
                  return this.container;
                }
              }
              class PolygonAnnotationElement extends PolylineAnnotationElement {
                constructor(parameters) {
                  super(parameters);
                  this.containerClassName = "polygonAnnotation";
                  this.svgElementName = "svg:polygon";
                }
              }
              class CaretAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  var _parameters$data$titl8, _parameters$data$cont8, _parameters$data$rich8;
                  const isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl8 = parameters.data.titleObj) !== null && _parameters$data$titl8 !== void 0 && _parameters$data$titl8.str || (_parameters$data$cont8 = parameters.data.contentsObj) !== null && _parameters$data$cont8 !== void 0 && _parameters$data$cont8.str || (_parameters$data$rich8 = parameters.data.richText) !== null && _parameters$data$rich8 !== void 0 && _parameters$data$rich8.str);
                  super(parameters, {
                    isRenderable,
                    ignoreBorder: true
                  });
                }
                render() {
                  this.container.className = "caretAnnotation";
                  if (!this.data.hasPopup) {
                    this._createPopup(null, this.data);
                  }
                  return this.container;
                }
              }
              class InkAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  var _parameters$data$titl9, _parameters$data$cont9, _parameters$data$rich9;
                  const isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl9 = parameters.data.titleObj) !== null && _parameters$data$titl9 !== void 0 && _parameters$data$titl9.str || (_parameters$data$cont9 = parameters.data.contentsObj) !== null && _parameters$data$cont9 !== void 0 && _parameters$data$cont9.str || (_parameters$data$rich9 = parameters.data.richText) !== null && _parameters$data$rich9 !== void 0 && _parameters$data$rich9.str);
                  super(parameters, {
                    isRenderable,
                    ignoreBorder: true
                  });
                  this.containerClassName = "inkAnnotation";
                  this.svgElementName = "svg:polyline";
                }
                render() {
                  this.container.className = this.containerClassName;
                  const data = this.data;
                  const {
                    width,
                    height
                  } = getRectDims(data.rect);
                  const svg = this.svgFactory.create(width, height, true);
                  for (const inkList of data.inkLists) {
                    let points = [];
                    for (const coordinate of inkList) {
                      const x = coordinate.x - data.rect[0];
                      const y = data.rect[3] - coordinate.y;
                      points.push(`${x},${y}`);
                    }
                    points = points.join(" ");
                    const polyline = this.svgFactory.createElement(this.svgElementName);
                    polyline.setAttribute("points", points);
                    polyline.setAttribute("stroke-width", data.borderStyle.width || 1);
                    polyline.setAttribute("stroke", "transparent");
                    polyline.setAttribute("fill", "transparent");
                    this._createPopup(polyline, data);
                    svg.append(polyline);
                  }
                  this.container.append(svg);
                  return this.container;
                }
              }
              class HighlightAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  var _parameters$data$titl10, _parameters$data$cont10, _parameters$data$rich10;
                  const isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl10 = parameters.data.titleObj) !== null && _parameters$data$titl10 !== void 0 && _parameters$data$titl10.str || (_parameters$data$cont10 = parameters.data.contentsObj) !== null && _parameters$data$cont10 !== void 0 && _parameters$data$cont10.str || (_parameters$data$rich10 = parameters.data.richText) !== null && _parameters$data$rich10 !== void 0 && _parameters$data$rich10.str);
                  super(parameters, {
                    isRenderable,
                    ignoreBorder: true,
                    createQuadrilaterals: true
                  });
                }
                render() {
                  if (!this.data.hasPopup) {
                    this._createPopup(null, this.data);
                  }
                  if (this.quadrilaterals) {
                    return this._renderQuadrilaterals("highlightAnnotation");
                  }
                  this.container.className = "highlightAnnotation";
                  return this.container;
                }
              }
              class UnderlineAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  var _parameters$data$titl11, _parameters$data$cont11, _parameters$data$rich11;
                  const isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl11 = parameters.data.titleObj) !== null && _parameters$data$titl11 !== void 0 && _parameters$data$titl11.str || (_parameters$data$cont11 = parameters.data.contentsObj) !== null && _parameters$data$cont11 !== void 0 && _parameters$data$cont11.str || (_parameters$data$rich11 = parameters.data.richText) !== null && _parameters$data$rich11 !== void 0 && _parameters$data$rich11.str);
                  super(parameters, {
                    isRenderable,
                    ignoreBorder: true,
                    createQuadrilaterals: true
                  });
                }
                render() {
                  if (!this.data.hasPopup) {
                    this._createPopup(null, this.data);
                  }
                  if (this.quadrilaterals) {
                    return this._renderQuadrilaterals("underlineAnnotation");
                  }
                  this.container.className = "underlineAnnotation";
                  return this.container;
                }
              }
              class SquigglyAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  var _parameters$data$titl12, _parameters$data$cont12, _parameters$data$rich12;
                  const isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl12 = parameters.data.titleObj) !== null && _parameters$data$titl12 !== void 0 && _parameters$data$titl12.str || (_parameters$data$cont12 = parameters.data.contentsObj) !== null && _parameters$data$cont12 !== void 0 && _parameters$data$cont12.str || (_parameters$data$rich12 = parameters.data.richText) !== null && _parameters$data$rich12 !== void 0 && _parameters$data$rich12.str);
                  super(parameters, {
                    isRenderable,
                    ignoreBorder: true,
                    createQuadrilaterals: true
                  });
                }
                render() {
                  if (!this.data.hasPopup) {
                    this._createPopup(null, this.data);
                  }
                  if (this.quadrilaterals) {
                    return this._renderQuadrilaterals("squigglyAnnotation");
                  }
                  this.container.className = "squigglyAnnotation";
                  return this.container;
                }
              }
              class StrikeOutAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  var _parameters$data$titl13, _parameters$data$cont13, _parameters$data$rich13;
                  const isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl13 = parameters.data.titleObj) !== null && _parameters$data$titl13 !== void 0 && _parameters$data$titl13.str || (_parameters$data$cont13 = parameters.data.contentsObj) !== null && _parameters$data$cont13 !== void 0 && _parameters$data$cont13.str || (_parameters$data$rich13 = parameters.data.richText) !== null && _parameters$data$rich13 !== void 0 && _parameters$data$rich13.str);
                  super(parameters, {
                    isRenderable,
                    ignoreBorder: true,
                    createQuadrilaterals: true
                  });
                }
                render() {
                  if (!this.data.hasPopup) {
                    this._createPopup(null, this.data);
                  }
                  if (this.quadrilaterals) {
                    return this._renderQuadrilaterals("strikeoutAnnotation");
                  }
                  this.container.className = "strikeoutAnnotation";
                  return this.container;
                }
              }
              class StampAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  var _parameters$data$titl14, _parameters$data$cont14, _parameters$data$rich14;
                  const isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl14 = parameters.data.titleObj) !== null && _parameters$data$titl14 !== void 0 && _parameters$data$titl14.str || (_parameters$data$cont14 = parameters.data.contentsObj) !== null && _parameters$data$cont14 !== void 0 && _parameters$data$cont14.str || (_parameters$data$rich14 = parameters.data.richText) !== null && _parameters$data$rich14 !== void 0 && _parameters$data$rich14.str);
                  super(parameters, {
                    isRenderable,
                    ignoreBorder: true
                  });
                }
                render() {
                  this.container.className = "stampAnnotation";
                  if (!this.data.hasPopup) {
                    this._createPopup(null, this.data);
                  }
                  return this.container;
                }
              }
              class FileAttachmentAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  var _this$linkService$eve10;
                  super(parameters, {
                    isRenderable: true
                  });
                  const {
                    filename,
                    content
                  } = this.data.file;
                  this.filename = (0, _display_utils2.getFilenameFromUrl)(filename);
                  this.content = content;
                  (_this$linkService$eve10 = this.linkService.eventBus) === null || _this$linkService$eve10 === void 0 ? void 0 : _this$linkService$eve10.dispatch("fileattachmentannotation", {
                    source: this,
                    filename,
                    content
                  });
                }
                render() {
                  var _this$data$titleObj, _this$data$contentsOb;
                  this.container.className = "fileAttachmentAnnotation";
                  const trigger = document.createElement("div");
                  trigger.className = "popupTriggerArea";
                  trigger.addEventListener("dblclick", this._download.bind(this));
                  if (!this.data.hasPopup && ((_this$data$titleObj = this.data.titleObj) !== null && _this$data$titleObj !== void 0 && _this$data$titleObj.str || (_this$data$contentsOb = this.data.contentsObj) !== null && _this$data$contentsOb !== void 0 && _this$data$contentsOb.str || this.data.richText)) {
                    this._createPopup(trigger, this.data);
                  }
                  this.container.append(trigger);
                  return this.container;
                }
                _download() {
                  var _this$downloadManager;
                  (_this$downloadManager = this.downloadManager) === null || _this$downloadManager === void 0 ? void 0 : _this$downloadManager.openOrDownloadData(this.container, this.content, this.filename);
                }
              }
              class AnnotationLayer {
                static render(parameters) {
                  const {
                    annotations,
                    div,
                    viewport,
                    accessibilityManager
                  } = parameters;
                  _classStaticPrivateMethodGet(this, AnnotationLayer, _setDimensions).call(this, div, viewport);
                  let zIndex = 0;
                  for (const data of annotations) {
                    if (data.annotationType !== _util2.AnnotationType.POPUP) {
                      const {
                        width,
                        height
                      } = getRectDims(data.rect);
                      if (width <= 0 || height <= 0) {
                        continue;
                      }
                    }
                    const element = AnnotationElementFactory.create({
                      data,
                      layer: div,
                      page: parameters.page,
                      viewport,
                      linkService: parameters.linkService,
                      downloadManager: parameters.downloadManager,
                      imageResourcesPath: parameters.imageResourcesPath || "",
                      renderForms: parameters.renderForms !== false,
                      svgFactory: new _display_utils2.DOMSVGFactory(),
                      annotationStorage: parameters.annotationStorage || new _annotation_storage2.AnnotationStorage(),
                      enableScripting: parameters.enableScripting,
                      hasJSActions: parameters.hasJSActions,
                      fieldObjects: parameters.fieldObjects,
                      mouseState: parameters.mouseState || {
                        isDown: false
                      }
                    });
                    if (element.isRenderable) {
                      const rendered = element.render();
                      if (data.hidden) {
                        rendered.style.visibility = "hidden";
                      }
                      if (Array.isArray(rendered)) {
                        for (const renderedElement of rendered) {
                          renderedElement.style.zIndex = zIndex++;
                          _classStaticPrivateMethodGet(AnnotationLayer, AnnotationLayer, _appendElement).call(AnnotationLayer, renderedElement, data.id, div, accessibilityManager);
                        }
                      } else {
                        rendered.style.zIndex = zIndex++;
                        if (element instanceof PopupAnnotationElement) {
                          div.prepend(rendered);
                        } else {
                          _classStaticPrivateMethodGet(AnnotationLayer, AnnotationLayer, _appendElement).call(AnnotationLayer, rendered, data.id, div, accessibilityManager);
                        }
                      }
                    }
                  }
                  _classStaticPrivateMethodGet(this, AnnotationLayer, _setAnnotationCanvasMap).call(this, div, parameters.annotationCanvasMap);
                }
                static update(parameters) {
                  const {
                    annotationCanvasMap,
                    div,
                    viewport
                  } = parameters;
                  _classStaticPrivateMethodGet(this, AnnotationLayer, _setDimensions).call(this, div, viewport);
                  _classStaticPrivateMethodGet(this, AnnotationLayer, _setAnnotationCanvasMap).call(this, div, annotationCanvasMap);
                  div.hidden = false;
                }
              }
              exports2.AnnotationLayer = AnnotationLayer;
              function _appendElement(element, id, div, accessibilityManager) {
                const contentElement = element.firstChild || element;
                contentElement.id = `${_display_utils2.AnnotationPrefix}${id}`;
                div.append(element);
                accessibilityManager === null || accessibilityManager === void 0 ? void 0 : accessibilityManager.moveElementInDOM(div, element, contentElement, false);
              }
              function _setDimensions(div, _ref2) {
                let {
                  width,
                  height,
                  rotation
                } = _ref2;
                const {
                  style
                } = div;
                const flipOrientation = rotation % 180 !== 0, widthStr = Math.floor(width) + "px", heightStr = Math.floor(height) + "px";
                style.width = flipOrientation ? heightStr : widthStr;
                style.height = flipOrientation ? widthStr : heightStr;
                div.setAttribute("data-main-rotation", rotation);
              }
              function _setAnnotationCanvasMap(div, annotationCanvasMap) {
                if (!annotationCanvasMap) {
                  return;
                }
                for (const [id, canvas] of annotationCanvasMap) {
                  const element = div.querySelector(`[data-annotation-id="${id}"]`);
                  if (!element) {
                    continue;
                  }
                  const {
                    firstChild
                  } = element;
                  if (!firstChild) {
                    element.append(canvas);
                  } else if (firstChild.nodeName === "CANVAS") {
                    firstChild.replaceWith(canvas);
                  } else {
                    firstChild.before(canvas);
                  }
                }
                annotationCanvasMap.clear();
              }
            },
            /* 153 */
            /***/
            (__unused_webpack_module2, exports2) => {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.ColorConverters = void 0;
              function makeColorComp(n) {
                return Math.floor(Math.max(0, Math.min(1, n)) * 255).toString(16).padStart(2, "0");
              }
              class ColorConverters {
                static CMYK_G(_ref) {
                  let [c, y, m, k] = _ref;
                  return ["G", 1 - Math.min(1, 0.3 * c + 0.59 * m + 0.11 * y + k)];
                }
                static G_CMYK(_ref2) {
                  let [g] = _ref2;
                  return ["CMYK", 0, 0, 0, 1 - g];
                }
                static G_RGB(_ref3) {
                  let [g] = _ref3;
                  return ["RGB", g, g, g];
                }
                static G_HTML(_ref4) {
                  let [g] = _ref4;
                  const G = makeColorComp(g);
                  return `#${G}${G}${G}`;
                }
                static RGB_G(_ref5) {
                  let [r2, g, b] = _ref5;
                  return ["G", 0.3 * r2 + 0.59 * g + 0.11 * b];
                }
                static RGB_HTML(_ref6) {
                  let [r2, g, b] = _ref6;
                  const R = makeColorComp(r2);
                  const G = makeColorComp(g);
                  const B = makeColorComp(b);
                  return `#${R}${G}${B}`;
                }
                static T_HTML() {
                  return "#00000000";
                }
                static CMYK_RGB(_ref7) {
                  let [c, y, m, k] = _ref7;
                  return ["RGB", 1 - Math.min(1, c + k), 1 - Math.min(1, m + k), 1 - Math.min(1, y + k)];
                }
                static CMYK_HTML(components) {
                  const rgb = this.CMYK_RGB(components).slice(1);
                  return this.RGB_HTML(rgb);
                }
                static RGB_CMYK(_ref8) {
                  let [r2, g, b] = _ref8;
                  const c = 1 - r2;
                  const m = 1 - g;
                  const y = 1 - b;
                  const k = Math.min(c, m, y);
                  return ["CMYK", c, m, y, k];
                }
              }
              exports2.ColorConverters = ColorConverters;
            },
            /* 154 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.XfaLayer = void 0;
              var _xfa_text2 = __w_pdfjs_require__2(145);
              class XfaLayer {
                static setupStorage(html, id, element, storage, intent) {
                  const storedData = storage.getValue(id, {
                    value: null
                  });
                  switch (element.name) {
                    case "textarea":
                      if (storedData.value !== null) {
                        html.textContent = storedData.value;
                      }
                      if (intent === "print") {
                        break;
                      }
                      html.addEventListener("input", (event) => {
                        storage.setValue(id, {
                          value: event.target.value
                        });
                      });
                      break;
                    case "input":
                      if (element.attributes.type === "radio" || element.attributes.type === "checkbox") {
                        if (storedData.value === element.attributes.xfaOn) {
                          html.setAttribute("checked", true);
                        } else if (storedData.value === element.attributes.xfaOff) {
                          html.removeAttribute("checked");
                        }
                        if (intent === "print") {
                          break;
                        }
                        html.addEventListener("change", (event) => {
                          storage.setValue(id, {
                            value: event.target.checked ? event.target.getAttribute("xfaOn") : event.target.getAttribute("xfaOff")
                          });
                        });
                      } else {
                        if (storedData.value !== null) {
                          html.setAttribute("value", storedData.value);
                        }
                        if (intent === "print") {
                          break;
                        }
                        html.addEventListener("input", (event) => {
                          storage.setValue(id, {
                            value: event.target.value
                          });
                        });
                      }
                      break;
                    case "select":
                      if (storedData.value !== null) {
                        for (const option of element.children) {
                          if (option.attributes.value === storedData.value) {
                            option.attributes.selected = true;
                          }
                        }
                      }
                      html.addEventListener("input", (event) => {
                        const options = event.target.options;
                        const value = options.selectedIndex === -1 ? "" : options[options.selectedIndex].value;
                        storage.setValue(id, {
                          value
                        });
                      });
                      break;
                  }
                }
                static setAttributes(_ref) {
                  let {
                    html,
                    element,
                    storage = null,
                    intent,
                    linkService
                  } = _ref;
                  const {
                    attributes
                  } = element;
                  const isHTMLAnchorElement = html instanceof HTMLAnchorElement;
                  if (attributes.type === "radio") {
                    attributes.name = `${attributes.name}-${intent}`;
                  }
                  for (const [key, value] of Object.entries(attributes)) {
                    if (value === null || value === void 0) {
                      continue;
                    }
                    switch (key) {
                      case "class":
                        if (value.length) {
                          html.setAttribute(key, value.join(" "));
                        }
                        break;
                      case "dataId":
                        break;
                      case "id":
                        html.setAttribute("data-element-id", value);
                        break;
                      case "style":
                        Object.assign(html.style, value);
                        break;
                      case "textContent":
                        html.textContent = value;
                        break;
                      default:
                        if (!isHTMLAnchorElement || key !== "href" && key !== "newWindow") {
                          html.setAttribute(key, value);
                        }
                    }
                  }
                  if (isHTMLAnchorElement) {
                    linkService.addLinkAttributes(html, attributes.href, attributes.newWindow);
                  }
                  if (storage && attributes.dataId) {
                    this.setupStorage(html, attributes.dataId, element, storage);
                  }
                }
                static render(parameters) {
                  const storage = parameters.annotationStorage;
                  const linkService = parameters.linkService;
                  const root = parameters.xfaHtml;
                  const intent = parameters.intent || "display";
                  const rootHtml = document.createElement(root.name);
                  if (root.attributes) {
                    this.setAttributes({
                      html: rootHtml,
                      element: root,
                      intent,
                      linkService
                    });
                  }
                  const stack = [[root, -1, rootHtml]];
                  const rootDiv = parameters.div;
                  rootDiv.append(rootHtml);
                  if (parameters.viewport) {
                    const transform = `matrix(${parameters.viewport.transform.join(",")})`;
                    rootDiv.style.transform = transform;
                  }
                  if (intent !== "richText") {
                    rootDiv.setAttribute("class", "xfaLayer xfaFont");
                  }
                  const textDivs = [];
                  while (stack.length > 0) {
                    var _child$attributes;
                    const [parent, i, html] = stack.at(-1);
                    if (i + 1 === parent.children.length) {
                      stack.pop();
                      continue;
                    }
                    const child = parent.children[++stack.at(-1)[1]];
                    if (child === null) {
                      continue;
                    }
                    const {
                      name
                    } = child;
                    if (name === "#text") {
                      const node = document.createTextNode(child.value);
                      textDivs.push(node);
                      html.append(node);
                      continue;
                    }
                    let childHtml;
                    if (child !== null && child !== void 0 && (_child$attributes = child.attributes) !== null && _child$attributes !== void 0 && _child$attributes.xmlns) {
                      childHtml = document.createElementNS(child.attributes.xmlns, name);
                    } else {
                      childHtml = document.createElement(name);
                    }
                    html.append(childHtml);
                    if (child.attributes) {
                      this.setAttributes({
                        html: childHtml,
                        element: child,
                        storage,
                        intent,
                        linkService
                      });
                    }
                    if (child.children && child.children.length > 0) {
                      stack.push([child, -1, childHtml]);
                    } else if (child.value) {
                      const node = document.createTextNode(child.value);
                      if (_xfa_text2.XfaText.shouldBuildText(name)) {
                        textDivs.push(node);
                      }
                      childHtml.append(node);
                    }
                  }
                  for (const el of rootDiv.querySelectorAll(".xfaNonInteractive input, .xfaNonInteractive textarea")) {
                    el.setAttribute("readOnly", true);
                  }
                  return {
                    textDivs
                  };
                }
                static update(parameters) {
                  const transform = `matrix(${parameters.viewport.transform.join(",")})`;
                  parameters.div.style.transform = transform;
                  parameters.div.hidden = false;
                }
              }
              exports2.XfaLayer = XfaLayer;
            },
            /* 155 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.TextLayerRenderTask = void 0;
              exports2.renderTextLayer = renderTextLayer;
              var _util2 = __w_pdfjs_require__2(1);
              var _display_utils2 = __w_pdfjs_require__2(133);
              const MAX_TEXT_DIVS_TO_RENDER = 1e5;
              const DEFAULT_FONT_SIZE = 30;
              const DEFAULT_FONT_ASCENT = 0.8;
              const ascentCache = /* @__PURE__ */ new Map();
              const AllWhitespaceRegexp = /^\s+$/g;
              function getAscent(fontFamily, ctx) {
                const cachedAscent = ascentCache.get(fontFamily);
                if (cachedAscent) {
                  return cachedAscent;
                }
                ctx.save();
                ctx.font = `${DEFAULT_FONT_SIZE}px ${fontFamily}`;
                const metrics = ctx.measureText("");
                let ascent = metrics.fontBoundingBoxAscent;
                let descent = Math.abs(metrics.fontBoundingBoxDescent);
                if (ascent) {
                  ctx.restore();
                  const ratio = ascent / (ascent + descent);
                  ascentCache.set(fontFamily, ratio);
                  return ratio;
                }
                ctx.strokeStyle = "red";
                ctx.clearRect(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE);
                ctx.strokeText("g", 0, 0);
                let pixels = ctx.getImageData(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE).data;
                descent = 0;
                for (let i = pixels.length - 1 - 3; i >= 0; i -= 4) {
                  if (pixels[i] > 0) {
                    descent = Math.ceil(i / 4 / DEFAULT_FONT_SIZE);
                    break;
                  }
                }
                ctx.clearRect(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE);
                ctx.strokeText("A", 0, DEFAULT_FONT_SIZE);
                pixels = ctx.getImageData(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE).data;
                ascent = 0;
                for (let i = 0, ii = pixels.length; i < ii; i += 4) {
                  if (pixels[i] > 0) {
                    ascent = DEFAULT_FONT_SIZE - Math.floor(i / 4 / DEFAULT_FONT_SIZE);
                    break;
                  }
                }
                ctx.restore();
                if (ascent) {
                  const ratio = ascent / (ascent + descent);
                  ascentCache.set(fontFamily, ratio);
                  return ratio;
                }
                ascentCache.set(fontFamily, DEFAULT_FONT_ASCENT);
                return DEFAULT_FONT_ASCENT;
              }
              function appendText(task, geom, styles2, ctx) {
                const textDiv = document.createElement("span");
                const textDivProperties = task._enhanceTextSelection ? {
                  angle: 0,
                  canvasWidth: 0,
                  hasText: geom.str !== "",
                  hasEOL: geom.hasEOL,
                  originalTransform: null,
                  paddingBottom: 0,
                  paddingLeft: 0,
                  paddingRight: 0,
                  paddingTop: 0,
                  scale: 1,
                  fontSize: 0
                } : {
                  angle: 0,
                  canvasWidth: 0,
                  hasText: geom.str !== "",
                  hasEOL: geom.hasEOL,
                  fontSize: 0
                };
                task._textDivs.push(textDiv);
                const tx = _util2.Util.transform(task._viewport.transform, geom.transform);
                let angle = Math.atan2(tx[1], tx[0]);
                const style = styles2[geom.fontName];
                if (style.vertical) {
                  angle += Math.PI / 2;
                }
                const fontHeight = Math.hypot(tx[2], tx[3]);
                const fontAscent = fontHeight * getAscent(style.fontFamily, ctx);
                let left, top;
                if (angle === 0) {
                  left = tx[4];
                  top = tx[5] - fontAscent;
                } else {
                  left = tx[4] + fontAscent * Math.sin(angle);
                  top = tx[5] - fontAscent * Math.cos(angle);
                }
                textDiv.style.left = `${left}px`;
                textDiv.style.top = `${top}px`;
                textDiv.style.fontSize = `${fontHeight}px`;
                textDiv.style.fontFamily = style.fontFamily;
                textDivProperties.fontSize = fontHeight;
                textDiv.setAttribute("role", "presentation");
                textDiv.textContent = geom.str;
                textDiv.dir = geom.dir;
                if (task._fontInspectorEnabled) {
                  textDiv.dataset.fontName = geom.fontName;
                }
                if (angle !== 0) {
                  textDivProperties.angle = angle * (180 / Math.PI);
                }
                let shouldScaleText = false;
                if (geom.str.length > 1 || task._enhanceTextSelection && AllWhitespaceRegexp.test(geom.str)) {
                  shouldScaleText = true;
                } else if (geom.str !== " " && geom.transform[0] !== geom.transform[3]) {
                  const absScaleX = Math.abs(geom.transform[0]), absScaleY = Math.abs(geom.transform[3]);
                  if (absScaleX !== absScaleY && Math.max(absScaleX, absScaleY) / Math.min(absScaleX, absScaleY) > 1.5) {
                    shouldScaleText = true;
                  }
                }
                if (shouldScaleText) {
                  if (style.vertical) {
                    textDivProperties.canvasWidth = geom.height * task._viewport.scale;
                  } else {
                    textDivProperties.canvasWidth = geom.width * task._viewport.scale;
                  }
                }
                task._textDivProperties.set(textDiv, textDivProperties);
                if (task._textContentStream) {
                  task._layoutText(textDiv);
                }
                if (task._enhanceTextSelection && textDivProperties.hasText) {
                  let angleCos = 1, angleSin = 0;
                  if (angle !== 0) {
                    angleCos = Math.cos(angle);
                    angleSin = Math.sin(angle);
                  }
                  const divWidth = (style.vertical ? geom.height : geom.width) * task._viewport.scale;
                  const divHeight = fontHeight;
                  let m, b;
                  if (angle !== 0) {
                    m = [angleCos, angleSin, -angleSin, angleCos, left, top];
                    b = _util2.Util.getAxialAlignedBoundingBox([0, 0, divWidth, divHeight], m);
                  } else {
                    b = [left, top, left + divWidth, top + divHeight];
                  }
                  task._bounds.push({
                    left: b[0],
                    top: b[1],
                    right: b[2],
                    bottom: b[3],
                    div: textDiv,
                    size: [divWidth, divHeight],
                    m
                  });
                }
              }
              function render(task) {
                if (task._canceled) {
                  return;
                }
                const textDivs = task._textDivs;
                const capability = task._capability;
                const textDivsLength = textDivs.length;
                if (textDivsLength > MAX_TEXT_DIVS_TO_RENDER) {
                  task._renderingDone = true;
                  capability.resolve();
                  return;
                }
                if (!task._textContentStream) {
                  for (let i = 0; i < textDivsLength; i++) {
                    task._layoutText(textDivs[i]);
                  }
                }
                task._renderingDone = true;
                capability.resolve();
              }
              function findPositiveMin(ts, offset, count) {
                let result = 0;
                for (let i = 0; i < count; i++) {
                  const t = ts[offset++];
                  if (t > 0) {
                    result = result ? Math.min(t, result) : t;
                  }
                }
                return result;
              }
              function expand(task) {
                const bounds = task._bounds;
                const viewport = task._viewport;
                const expanded = expandBounds(viewport.width, viewport.height, bounds);
                for (let i = 0; i < expanded.length; i++) {
                  const div = bounds[i].div;
                  const divProperties = task._textDivProperties.get(div);
                  if (divProperties.angle === 0) {
                    divProperties.paddingLeft = bounds[i].left - expanded[i].left;
                    divProperties.paddingTop = bounds[i].top - expanded[i].top;
                    divProperties.paddingRight = expanded[i].right - bounds[i].right;
                    divProperties.paddingBottom = expanded[i].bottom - bounds[i].bottom;
                    task._textDivProperties.set(div, divProperties);
                    continue;
                  }
                  const e = expanded[i], b = bounds[i];
                  const m = b.m, c = m[0], s = m[1];
                  const points = [[0, 0], [0, b.size[1]], [b.size[0], 0], b.size];
                  const ts = new Float64Array(64);
                  for (let j = 0, jj = points.length; j < jj; j++) {
                    const t = _util2.Util.applyTransform(points[j], m);
                    ts[j + 0] = c && (e.left - t[0]) / c;
                    ts[j + 4] = s && (e.top - t[1]) / s;
                    ts[j + 8] = c && (e.right - t[0]) / c;
                    ts[j + 12] = s && (e.bottom - t[1]) / s;
                    ts[j + 16] = s && (e.left - t[0]) / -s;
                    ts[j + 20] = c && (e.top - t[1]) / c;
                    ts[j + 24] = s && (e.right - t[0]) / -s;
                    ts[j + 28] = c && (e.bottom - t[1]) / c;
                    ts[j + 32] = c && (e.left - t[0]) / -c;
                    ts[j + 36] = s && (e.top - t[1]) / -s;
                    ts[j + 40] = c && (e.right - t[0]) / -c;
                    ts[j + 44] = s && (e.bottom - t[1]) / -s;
                    ts[j + 48] = s && (e.left - t[0]) / s;
                    ts[j + 52] = c && (e.top - t[1]) / -c;
                    ts[j + 56] = s && (e.right - t[0]) / s;
                    ts[j + 60] = c && (e.bottom - t[1]) / -c;
                  }
                  const boxScale = 1 + Math.min(Math.abs(c), Math.abs(s));
                  divProperties.paddingLeft = findPositiveMin(ts, 32, 16) / boxScale;
                  divProperties.paddingTop = findPositiveMin(ts, 48, 16) / boxScale;
                  divProperties.paddingRight = findPositiveMin(ts, 0, 16) / boxScale;
                  divProperties.paddingBottom = findPositiveMin(ts, 16, 16) / boxScale;
                  task._textDivProperties.set(div, divProperties);
                }
              }
              function expandBounds(width, height, boxes) {
                const bounds = boxes.map(function(box, i) {
                  return {
                    x1: box.left,
                    y1: box.top,
                    x2: box.right,
                    y2: box.bottom,
                    index: i,
                    x1New: void 0,
                    x2New: void 0
                  };
                });
                expandBoundsLTR(width, bounds);
                const expanded = new Array(boxes.length);
                for (const b of bounds) {
                  const i = b.index;
                  expanded[i] = {
                    left: b.x1New,
                    top: 0,
                    right: b.x2New,
                    bottom: 0
                  };
                }
                boxes.map(function(box, i) {
                  const e = expanded[i], b = bounds[i];
                  b.x1 = box.top;
                  b.y1 = width - e.right;
                  b.x2 = box.bottom;
                  b.y2 = width - e.left;
                  b.index = i;
                  b.x1New = void 0;
                  b.x2New = void 0;
                });
                expandBoundsLTR(height, bounds);
                for (const b of bounds) {
                  const i = b.index;
                  expanded[i].top = b.x1New;
                  expanded[i].bottom = b.x2New;
                }
                return expanded;
              }
              function expandBoundsLTR(width, bounds) {
                bounds.sort(function(a, b) {
                  return a.x1 - b.x1 || a.index - b.index;
                });
                const fakeBoundary = {
                  x1: -Infinity,
                  y1: -Infinity,
                  x2: 0,
                  y2: Infinity,
                  index: -1,
                  x1New: 0,
                  x2New: 0
                };
                const horizon = [{
                  start: -Infinity,
                  end: Infinity,
                  boundary: fakeBoundary
                }];
                for (const boundary of bounds) {
                  let i = 0;
                  while (i < horizon.length && horizon[i].end <= boundary.y1) {
                    i++;
                  }
                  let j = horizon.length - 1;
                  while (j >= 0 && horizon[j].start >= boundary.y2) {
                    j--;
                  }
                  let horizonPart, affectedBoundary;
                  let q, k, maxXNew = -Infinity;
                  for (q = i; q <= j; q++) {
                    horizonPart = horizon[q];
                    affectedBoundary = horizonPart.boundary;
                    let xNew;
                    if (affectedBoundary.x2 > boundary.x1) {
                      xNew = affectedBoundary.index > boundary.index ? affectedBoundary.x1New : boundary.x1;
                    } else if (affectedBoundary.x2New === void 0) {
                      xNew = (affectedBoundary.x2 + boundary.x1) / 2;
                    } else {
                      xNew = affectedBoundary.x2New;
                    }
                    if (xNew > maxXNew) {
                      maxXNew = xNew;
                    }
                  }
                  boundary.x1New = maxXNew;
                  for (q = i; q <= j; q++) {
                    horizonPart = horizon[q];
                    affectedBoundary = horizonPart.boundary;
                    if (affectedBoundary.x2New === void 0) {
                      if (affectedBoundary.x2 > boundary.x1) {
                        if (affectedBoundary.index > boundary.index) {
                          affectedBoundary.x2New = affectedBoundary.x2;
                        }
                      } else {
                        affectedBoundary.x2New = maxXNew;
                      }
                    } else if (affectedBoundary.x2New > maxXNew) {
                      affectedBoundary.x2New = Math.max(maxXNew, affectedBoundary.x2);
                    }
                  }
                  const changedHorizon = [];
                  let lastBoundary = null;
                  for (q = i; q <= j; q++) {
                    horizonPart = horizon[q];
                    affectedBoundary = horizonPart.boundary;
                    const useBoundary = affectedBoundary.x2 > boundary.x2 ? affectedBoundary : boundary;
                    if (lastBoundary === useBoundary) {
                      changedHorizon.at(-1).end = horizonPart.end;
                    } else {
                      changedHorizon.push({
                        start: horizonPart.start,
                        end: horizonPart.end,
                        boundary: useBoundary
                      });
                      lastBoundary = useBoundary;
                    }
                  }
                  if (horizon[i].start < boundary.y1) {
                    changedHorizon[0].start = boundary.y1;
                    changedHorizon.unshift({
                      start: horizon[i].start,
                      end: boundary.y1,
                      boundary: horizon[i].boundary
                    });
                  }
                  if (boundary.y2 < horizon[j].end) {
                    changedHorizon.at(-1).end = boundary.y2;
                    changedHorizon.push({
                      start: boundary.y2,
                      end: horizon[j].end,
                      boundary: horizon[j].boundary
                    });
                  }
                  for (q = i; q <= j; q++) {
                    horizonPart = horizon[q];
                    affectedBoundary = horizonPart.boundary;
                    if (affectedBoundary.x2New !== void 0) {
                      continue;
                    }
                    let used = false;
                    for (k = i - 1; !used && k >= 0 && horizon[k].start >= affectedBoundary.y1; k--) {
                      used = horizon[k].boundary === affectedBoundary;
                    }
                    for (k = j + 1; !used && k < horizon.length && horizon[k].end <= affectedBoundary.y2; k++) {
                      used = horizon[k].boundary === affectedBoundary;
                    }
                    for (k = 0; !used && k < changedHorizon.length; k++) {
                      used = changedHorizon[k].boundary === affectedBoundary;
                    }
                    if (!used) {
                      affectedBoundary.x2New = maxXNew;
                    }
                  }
                  Array.prototype.splice.apply(horizon, [i, j - i + 1, ...changedHorizon]);
                }
                for (const horizonPart of horizon) {
                  const affectedBoundary = horizonPart.boundary;
                  if (affectedBoundary.x2New === void 0) {
                    affectedBoundary.x2New = Math.max(width, affectedBoundary.x2);
                  }
                }
              }
              class TextLayerRenderTask {
                constructor(_ref) {
                  var _globalThis$FontInspe;
                  let {
                    textContent,
                    textContentStream,
                    container,
                    viewport,
                    textDivs,
                    textContentItemsStr,
                    enhanceTextSelection
                  } = _ref;
                  if (enhanceTextSelection) {
                    (0, _display_utils2.deprecated)("The `enhanceTextSelection` functionality will be removed in the future.");
                  }
                  this._textContent = textContent;
                  this._textContentStream = textContentStream;
                  this._container = container;
                  this._document = container.ownerDocument;
                  this._viewport = viewport;
                  this._textDivs = textDivs || [];
                  this._textContentItemsStr = textContentItemsStr || [];
                  this._enhanceTextSelection = !!enhanceTextSelection;
                  this._fontInspectorEnabled = !!((_globalThis$FontInspe = globalThis.FontInspector) !== null && _globalThis$FontInspe !== void 0 && _globalThis$FontInspe.enabled);
                  this._reader = null;
                  this._layoutTextLastFontSize = null;
                  this._layoutTextLastFontFamily = null;
                  this._layoutTextCtx = null;
                  this._textDivProperties = /* @__PURE__ */ new WeakMap();
                  this._renderingDone = false;
                  this._canceled = false;
                  this._capability = (0, _util2.createPromiseCapability)();
                  this._renderTimer = null;
                  this._bounds = [];
                  this._devicePixelRatio = globalThis.devicePixelRatio || 1;
                  this._capability.promise.finally(() => {
                    if (!this._enhanceTextSelection) {
                      this._textDivProperties = null;
                    }
                    if (this._layoutTextCtx) {
                      this._layoutTextCtx.canvas.width = 0;
                      this._layoutTextCtx.canvas.height = 0;
                      this._layoutTextCtx = null;
                    }
                  }).catch(() => {
                  });
                }
                get promise() {
                  return this._capability.promise;
                }
                cancel() {
                  this._canceled = true;
                  if (this._reader) {
                    this._reader.cancel(new _util2.AbortException("TextLayer task cancelled.")).catch(() => {
                    });
                    this._reader = null;
                  }
                  if (this._renderTimer !== null) {
                    clearTimeout(this._renderTimer);
                    this._renderTimer = null;
                  }
                  this._capability.reject(new Error("TextLayer task cancelled."));
                }
                _processItems(items, styleCache) {
                  for (let i = 0, len = items.length; i < len; i++) {
                    if (items[i].str === void 0) {
                      if (items[i].type === "beginMarkedContentProps" || items[i].type === "beginMarkedContent") {
                        const parent = this._container;
                        this._container = document.createElement("span");
                        this._container.classList.add("markedContent");
                        if (items[i].id !== null) {
                          this._container.setAttribute("id", `${items[i].id}`);
                        }
                        parent.append(this._container);
                      } else if (items[i].type === "endMarkedContent") {
                        this._container = this._container.parentNode;
                      }
                      continue;
                    }
                    this._textContentItemsStr.push(items[i].str);
                    appendText(this, items[i], styleCache, this._layoutTextCtx);
                  }
                }
                _layoutText(textDiv) {
                  const textDivProperties = this._textDivProperties.get(textDiv);
                  let transform = "";
                  if (textDivProperties.canvasWidth !== 0 && textDivProperties.hasText) {
                    const {
                      fontFamily
                    } = textDiv.style;
                    const {
                      fontSize
                    } = textDivProperties;
                    if (fontSize !== this._layoutTextLastFontSize || fontFamily !== this._layoutTextLastFontFamily) {
                      this._layoutTextCtx.font = `${fontSize * this._devicePixelRatio}px ${fontFamily}`;
                      this._layoutTextLastFontSize = fontSize;
                      this._layoutTextLastFontFamily = fontFamily;
                    }
                    const {
                      width
                    } = this._layoutTextCtx.measureText(textDiv.textContent);
                    if (width > 0) {
                      const scale = this._devicePixelRatio * textDivProperties.canvasWidth / width;
                      if (this._enhanceTextSelection) {
                        textDivProperties.scale = scale;
                      }
                      transform = `scaleX(${scale})`;
                    }
                  }
                  if (textDivProperties.angle !== 0) {
                    transform = `rotate(${textDivProperties.angle}deg) ${transform}`;
                  }
                  if (transform.length > 0) {
                    if (this._enhanceTextSelection) {
                      textDivProperties.originalTransform = transform;
                    }
                    textDiv.style.transform = transform;
                  }
                  if (textDivProperties.hasText) {
                    this._container.append(textDiv);
                  }
                  if (textDivProperties.hasEOL) {
                    const br = document.createElement("br");
                    br.setAttribute("role", "presentation");
                    this._container.append(br);
                  }
                }
                _render() {
                  let timeout = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
                  const capability = (0, _util2.createPromiseCapability)();
                  let styleCache = /* @__PURE__ */ Object.create(null);
                  const canvas = this._document.createElement("canvas");
                  canvas.height = canvas.width = DEFAULT_FONT_SIZE;
                  this._layoutTextCtx = canvas.getContext("2d", {
                    alpha: false
                  });
                  if (this._textContent) {
                    const textItems = this._textContent.items;
                    const textStyles = this._textContent.styles;
                    this._processItems(textItems, textStyles);
                    capability.resolve();
                  } else if (this._textContentStream) {
                    const pump = () => {
                      this._reader.read().then((_ref2) => {
                        let {
                          value,
                          done
                        } = _ref2;
                        if (done) {
                          capability.resolve();
                          return;
                        }
                        Object.assign(styleCache, value.styles);
                        this._processItems(value.items, styleCache);
                        pump();
                      }, capability.reject);
                    };
                    this._reader = this._textContentStream.getReader();
                    pump();
                  } else {
                    throw new Error('Neither "textContent" nor "textContentStream" parameters specified.');
                  }
                  capability.promise.then(() => {
                    styleCache = null;
                    if (!timeout) {
                      render(this);
                    } else {
                      this._renderTimer = setTimeout(() => {
                        render(this);
                        this._renderTimer = null;
                      }, timeout);
                    }
                  }, this._capability.reject);
                }
                expandTextDivs() {
                  let expandDivs = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
                  if (!this._enhanceTextSelection || !this._renderingDone) {
                    return;
                  }
                  if (this._bounds !== null) {
                    expand(this);
                    this._bounds = null;
                  }
                  const transformBuf = [], paddingBuf = [];
                  for (let i = 0, ii = this._textDivs.length; i < ii; i++) {
                    const div = this._textDivs[i];
                    const divProps = this._textDivProperties.get(div);
                    if (!divProps.hasText) {
                      continue;
                    }
                    if (expandDivs) {
                      transformBuf.length = 0;
                      paddingBuf.length = 0;
                      if (divProps.originalTransform) {
                        transformBuf.push(divProps.originalTransform);
                      }
                      if (divProps.paddingTop > 0) {
                        paddingBuf.push(`${divProps.paddingTop}px`);
                        transformBuf.push(`translateY(${-divProps.paddingTop}px)`);
                      } else {
                        paddingBuf.push(0);
                      }
                      if (divProps.paddingRight > 0) {
                        paddingBuf.push(`${divProps.paddingRight / divProps.scale}px`);
                      } else {
                        paddingBuf.push(0);
                      }
                      if (divProps.paddingBottom > 0) {
                        paddingBuf.push(`${divProps.paddingBottom}px`);
                      } else {
                        paddingBuf.push(0);
                      }
                      if (divProps.paddingLeft > 0) {
                        paddingBuf.push(`${divProps.paddingLeft / divProps.scale}px`);
                        transformBuf.push(`translateX(${-divProps.paddingLeft / divProps.scale}px)`);
                      } else {
                        paddingBuf.push(0);
                      }
                      div.style.padding = paddingBuf.join(" ");
                      if (transformBuf.length) {
                        div.style.transform = transformBuf.join(" ");
                      }
                    } else {
                      div.style.padding = null;
                      div.style.transform = divProps.originalTransform;
                    }
                  }
                }
              }
              exports2.TextLayerRenderTask = TextLayerRenderTask;
              function renderTextLayer(renderParameters) {
                const task = new TextLayerRenderTask({
                  textContent: renderParameters.textContent,
                  textContentStream: renderParameters.textContentStream,
                  container: renderParameters.container,
                  viewport: renderParameters.viewport,
                  textDivs: renderParameters.textDivs,
                  textContentItemsStr: renderParameters.textContentItemsStr,
                  enhanceTextSelection: renderParameters.enhanceTextSelection
                });
                task._render(renderParameters.timeout);
                return task;
              }
            },
            /* 156 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.SVGGraphics = void 0;
              var _display_utils2 = __w_pdfjs_require__2(133);
              var _util2 = __w_pdfjs_require__2(1);
              var _is_node2 = __w_pdfjs_require__2(3);
              let SVGGraphics = class {
                constructor() {
                  (0, _util2.unreachable)("Not implemented: SVGGraphics");
                }
              };
              exports2.SVGGraphics = SVGGraphics;
              {
                let opListToTree = function(opList) {
                  let opTree = [];
                  const tmp = [];
                  for (const opListElement of opList) {
                    if (opListElement.fn === "save") {
                      opTree.push({
                        fnId: 92,
                        fn: "group",
                        items: []
                      });
                      tmp.push(opTree);
                      opTree = opTree.at(-1).items;
                      continue;
                    }
                    if (opListElement.fn === "restore") {
                      opTree = tmp.pop();
                    } else {
                      opTree.push(opListElement);
                    }
                  }
                  return opTree;
                }, pf = function(value) {
                  if (Number.isInteger(value)) {
                    return value.toString();
                  }
                  const s = value.toFixed(10);
                  let i = s.length - 1;
                  if (s[i] !== "0") {
                    return s;
                  }
                  do {
                    i--;
                  } while (s[i] === "0");
                  return s.substring(0, s[i] === "." ? i : i + 1);
                }, pm = function(m) {
                  if (m[4] === 0 && m[5] === 0) {
                    if (m[1] === 0 && m[2] === 0) {
                      if (m[0] === 1 && m[3] === 1) {
                        return "";
                      }
                      return `scale(${pf(m[0])} ${pf(m[3])})`;
                    }
                    if (m[0] === m[3] && m[1] === -m[2]) {
                      const a = Math.acos(m[0]) * 180 / Math.PI;
                      return `rotate(${pf(a)})`;
                    }
                  } else {
                    if (m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 1) {
                      return `translate(${pf(m[4])} ${pf(m[5])})`;
                    }
                  }
                  return `matrix(${pf(m[0])} ${pf(m[1])} ${pf(m[2])} ${pf(m[3])} ${pf(m[4])} ${pf(m[5])})`;
                };
                const SVG_DEFAULTS = {
                  fontStyle: "normal",
                  fontWeight: "normal",
                  fillColor: "#000000"
                };
                const XML_NS = "http://www.w3.org/XML/1998/namespace";
                const XLINK_NS = "http://www.w3.org/1999/xlink";
                const LINE_CAP_STYLES = ["butt", "round", "square"];
                const LINE_JOIN_STYLES = ["miter", "round", "bevel"];
                const createObjectURL = function(data) {
                  let contentType = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
                  let forceDataSchema = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                  if (URL.createObjectURL && typeof Blob !== "undefined" && !forceDataSchema) {
                    return URL.createObjectURL(new Blob([data], {
                      type: contentType
                    }));
                  }
                  const digits = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
                  let buffer = `data:${contentType};base64,`;
                  for (let i = 0, ii = data.length; i < ii; i += 3) {
                    const b1 = data[i] & 255;
                    const b2 = data[i + 1] & 255;
                    const b3 = data[i + 2] & 255;
                    const d1 = b1 >> 2, d2 = (b1 & 3) << 4 | b2 >> 4;
                    const d3 = i + 1 < ii ? (b2 & 15) << 2 | b3 >> 6 : 64;
                    const d4 = i + 2 < ii ? b3 & 63 : 64;
                    buffer += digits[d1] + digits[d2] + digits[d3] + digits[d4];
                  }
                  return buffer;
                };
                const convertImgDataToPng = function() {
                  const PNG_HEADER = new Uint8Array([137, 80, 78, 71, 13, 10, 26, 10]);
                  const CHUNK_WRAPPER_SIZE = 12;
                  const crcTable = new Int32Array(256);
                  for (let i = 0; i < 256; i++) {
                    let c = i;
                    for (let h = 0; h < 8; h++) {
                      if (c & 1) {
                        c = 3988292384 ^ c >> 1 & 2147483647;
                      } else {
                        c = c >> 1 & 2147483647;
                      }
                    }
                    crcTable[i] = c;
                  }
                  function crc32(data, start, end) {
                    let crc = -1;
                    for (let i = start; i < end; i++) {
                      const a = (crc ^ data[i]) & 255;
                      const b = crcTable[a];
                      crc = crc >>> 8 ^ b;
                    }
                    return crc ^ -1;
                  }
                  function writePngChunk(type, body, data, offset) {
                    let p = offset;
                    const len = body.length;
                    data[p] = len >> 24 & 255;
                    data[p + 1] = len >> 16 & 255;
                    data[p + 2] = len >> 8 & 255;
                    data[p + 3] = len & 255;
                    p += 4;
                    data[p] = type.charCodeAt(0) & 255;
                    data[p + 1] = type.charCodeAt(1) & 255;
                    data[p + 2] = type.charCodeAt(2) & 255;
                    data[p + 3] = type.charCodeAt(3) & 255;
                    p += 4;
                    data.set(body, p);
                    p += body.length;
                    const crc = crc32(data, offset + 4, p);
                    data[p] = crc >> 24 & 255;
                    data[p + 1] = crc >> 16 & 255;
                    data[p + 2] = crc >> 8 & 255;
                    data[p + 3] = crc & 255;
                  }
                  function adler32(data, start, end) {
                    let a = 1;
                    let b = 0;
                    for (let i = start; i < end; ++i) {
                      a = (a + (data[i] & 255)) % 65521;
                      b = (b + a) % 65521;
                    }
                    return b << 16 | a;
                  }
                  function deflateSync(literals) {
                    if (!_is_node2.isNodeJS) {
                      return deflateSyncUncompressed(literals);
                    }
                    try {
                      let input;
                      if (parseInt(process.versions.node) >= 8) {
                        input = literals;
                      } else {
                        input = Buffer.from(literals);
                      }
                      const output = require_zlib().deflateSync(input, {
                        level: 9
                      });
                      return output instanceof Uint8Array ? output : new Uint8Array(output);
                    } catch (e) {
                      (0, _util2.warn)("Not compressing PNG because zlib.deflateSync is unavailable: " + e);
                    }
                    return deflateSyncUncompressed(literals);
                  }
                  function deflateSyncUncompressed(literals) {
                    let len = literals.length;
                    const maxBlockLength = 65535;
                    const deflateBlocks = Math.ceil(len / maxBlockLength);
                    const idat = new Uint8Array(2 + len + deflateBlocks * 5 + 4);
                    let pi = 0;
                    idat[pi++] = 120;
                    idat[pi++] = 156;
                    let pos = 0;
                    while (len > maxBlockLength) {
                      idat[pi++] = 0;
                      idat[pi++] = 255;
                      idat[pi++] = 255;
                      idat[pi++] = 0;
                      idat[pi++] = 0;
                      idat.set(literals.subarray(pos, pos + maxBlockLength), pi);
                      pi += maxBlockLength;
                      pos += maxBlockLength;
                      len -= maxBlockLength;
                    }
                    idat[pi++] = 1;
                    idat[pi++] = len & 255;
                    idat[pi++] = len >> 8 & 255;
                    idat[pi++] = ~len & 65535 & 255;
                    idat[pi++] = (~len & 65535) >> 8 & 255;
                    idat.set(literals.subarray(pos), pi);
                    pi += literals.length - pos;
                    const adler = adler32(literals, 0, literals.length);
                    idat[pi++] = adler >> 24 & 255;
                    idat[pi++] = adler >> 16 & 255;
                    idat[pi++] = adler >> 8 & 255;
                    idat[pi++] = adler & 255;
                    return idat;
                  }
                  function encode(imgData, kind, forceDataSchema, isMask) {
                    const width = imgData.width;
                    const height = imgData.height;
                    let bitDepth, colorType, lineSize;
                    const bytes = imgData.data;
                    switch (kind) {
                      case _util2.ImageKind.GRAYSCALE_1BPP:
                        colorType = 0;
                        bitDepth = 1;
                        lineSize = width + 7 >> 3;
                        break;
                      case _util2.ImageKind.RGB_24BPP:
                        colorType = 2;
                        bitDepth = 8;
                        lineSize = width * 3;
                        break;
                      case _util2.ImageKind.RGBA_32BPP:
                        colorType = 6;
                        bitDepth = 8;
                        lineSize = width * 4;
                        break;
                      default:
                        throw new Error("invalid format");
                    }
                    const literals = new Uint8Array((1 + lineSize) * height);
                    let offsetLiterals = 0, offsetBytes = 0;
                    for (let y = 0; y < height; ++y) {
                      literals[offsetLiterals++] = 0;
                      literals.set(bytes.subarray(offsetBytes, offsetBytes + lineSize), offsetLiterals);
                      offsetBytes += lineSize;
                      offsetLiterals += lineSize;
                    }
                    if (kind === _util2.ImageKind.GRAYSCALE_1BPP && isMask) {
                      offsetLiterals = 0;
                      for (let y = 0; y < height; y++) {
                        offsetLiterals++;
                        for (let i = 0; i < lineSize; i++) {
                          literals[offsetLiterals++] ^= 255;
                        }
                      }
                    }
                    const ihdr = new Uint8Array([width >> 24 & 255, width >> 16 & 255, width >> 8 & 255, width & 255, height >> 24 & 255, height >> 16 & 255, height >> 8 & 255, height & 255, bitDepth, colorType, 0, 0, 0]);
                    const idat = deflateSync(literals);
                    const pngLength = PNG_HEADER.length + CHUNK_WRAPPER_SIZE * 3 + ihdr.length + idat.length;
                    const data = new Uint8Array(pngLength);
                    let offset = 0;
                    data.set(PNG_HEADER, offset);
                    offset += PNG_HEADER.length;
                    writePngChunk("IHDR", ihdr, data, offset);
                    offset += CHUNK_WRAPPER_SIZE + ihdr.length;
                    writePngChunk("IDATA", idat, data, offset);
                    offset += CHUNK_WRAPPER_SIZE + idat.length;
                    writePngChunk("IEND", new Uint8Array(0), data, offset);
                    return createObjectURL(data, "image/png", forceDataSchema);
                  }
                  return function convertImgDataToPng2(imgData, forceDataSchema, isMask) {
                    const kind = imgData.kind === void 0 ? _util2.ImageKind.GRAYSCALE_1BPP : imgData.kind;
                    return encode(imgData, kind, forceDataSchema, isMask);
                  };
                }();
                class SVGExtraState {
                  constructor() {
                    this.fontSizeScale = 1;
                    this.fontWeight = SVG_DEFAULTS.fontWeight;
                    this.fontSize = 0;
                    this.textMatrix = _util2.IDENTITY_MATRIX;
                    this.fontMatrix = _util2.FONT_IDENTITY_MATRIX;
                    this.leading = 0;
                    this.textRenderingMode = _util2.TextRenderingMode.FILL;
                    this.textMatrixScale = 1;
                    this.x = 0;
                    this.y = 0;
                    this.lineX = 0;
                    this.lineY = 0;
                    this.charSpacing = 0;
                    this.wordSpacing = 0;
                    this.textHScale = 1;
                    this.textRise = 0;
                    this.fillColor = SVG_DEFAULTS.fillColor;
                    this.strokeColor = "#000000";
                    this.fillAlpha = 1;
                    this.strokeAlpha = 1;
                    this.lineWidth = 1;
                    this.lineJoin = "";
                    this.lineCap = "";
                    this.miterLimit = 0;
                    this.dashArray = [];
                    this.dashPhase = 0;
                    this.dependencies = [];
                    this.activeClipUrl = null;
                    this.clipGroup = null;
                    this.maskId = "";
                  }
                  clone() {
                    return Object.create(this);
                  }
                  setCurrentPoint(x, y) {
                    this.x = x;
                    this.y = y;
                  }
                }
                let clipCount = 0;
                let maskCount = 0;
                let shadingCount = 0;
                exports2.SVGGraphics = SVGGraphics = class {
                  constructor(commonObjs, objs) {
                    let forceDataSchema = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                    (0, _display_utils2.deprecated)("The SVG back-end is no longer maintained and *may* be removed in the future.");
                    this.svgFactory = new _display_utils2.DOMSVGFactory();
                    this.current = new SVGExtraState();
                    this.transformMatrix = _util2.IDENTITY_MATRIX;
                    this.transformStack = [];
                    this.extraStack = [];
                    this.commonObjs = commonObjs;
                    this.objs = objs;
                    this.pendingClip = null;
                    this.pendingEOFill = false;
                    this.embedFonts = false;
                    this.embeddedFonts = /* @__PURE__ */ Object.create(null);
                    this.cssStyle = null;
                    this.forceDataSchema = !!forceDataSchema;
                    this._operatorIdMapping = [];
                    for (const op in _util2.OPS) {
                      this._operatorIdMapping[_util2.OPS[op]] = op;
                    }
                  }
                  save() {
                    this.transformStack.push(this.transformMatrix);
                    const old = this.current;
                    this.extraStack.push(old);
                    this.current = old.clone();
                  }
                  restore() {
                    this.transformMatrix = this.transformStack.pop();
                    this.current = this.extraStack.pop();
                    this.pendingClip = null;
                    this.tgrp = null;
                  }
                  group(items) {
                    this.save();
                    this.executeOpTree(items);
                    this.restore();
                  }
                  loadDependencies(operatorList) {
                    const fnArray = operatorList.fnArray;
                    const argsArray = operatorList.argsArray;
                    for (let i = 0, ii = fnArray.length; i < ii; i++) {
                      if (fnArray[i] !== _util2.OPS.dependency) {
                        continue;
                      }
                      for (const obj of argsArray[i]) {
                        const objsPool = obj.startsWith("g_") ? this.commonObjs : this.objs;
                        const promise = new Promise((resolve) => {
                          objsPool.get(obj, resolve);
                        });
                        this.current.dependencies.push(promise);
                      }
                    }
                    return Promise.all(this.current.dependencies);
                  }
                  transform(a, b, c, d, e, f) {
                    const transformMatrix = [a, b, c, d, e, f];
                    this.transformMatrix = _util2.Util.transform(this.transformMatrix, transformMatrix);
                    this.tgrp = null;
                  }
                  getSVG(operatorList, viewport) {
                    this.viewport = viewport;
                    const svgElement = this._initialize(viewport);
                    return this.loadDependencies(operatorList).then(() => {
                      this.transformMatrix = _util2.IDENTITY_MATRIX;
                      this.executeOpTree(this.convertOpList(operatorList));
                      return svgElement;
                    });
                  }
                  convertOpList(operatorList) {
                    const operatorIdMapping = this._operatorIdMapping;
                    const argsArray = operatorList.argsArray;
                    const fnArray = operatorList.fnArray;
                    const opList = [];
                    for (let i = 0, ii = fnArray.length; i < ii; i++) {
                      const fnId = fnArray[i];
                      opList.push({
                        fnId,
                        fn: operatorIdMapping[fnId],
                        args: argsArray[i]
                      });
                    }
                    return opListToTree(opList);
                  }
                  executeOpTree(opTree) {
                    for (const opTreeElement of opTree) {
                      const fn = opTreeElement.fn;
                      const fnId = opTreeElement.fnId;
                      const args = opTreeElement.args;
                      switch (fnId | 0) {
                        case _util2.OPS.beginText:
                          this.beginText();
                          break;
                        case _util2.OPS.dependency:
                          break;
                        case _util2.OPS.setLeading:
                          this.setLeading(args);
                          break;
                        case _util2.OPS.setLeadingMoveText:
                          this.setLeadingMoveText(args[0], args[1]);
                          break;
                        case _util2.OPS.setFont:
                          this.setFont(args);
                          break;
                        case _util2.OPS.showText:
                          this.showText(args[0]);
                          break;
                        case _util2.OPS.showSpacedText:
                          this.showText(args[0]);
                          break;
                        case _util2.OPS.endText:
                          this.endText();
                          break;
                        case _util2.OPS.moveText:
                          this.moveText(args[0], args[1]);
                          break;
                        case _util2.OPS.setCharSpacing:
                          this.setCharSpacing(args[0]);
                          break;
                        case _util2.OPS.setWordSpacing:
                          this.setWordSpacing(args[0]);
                          break;
                        case _util2.OPS.setHScale:
                          this.setHScale(args[0]);
                          break;
                        case _util2.OPS.setTextMatrix:
                          this.setTextMatrix(args[0], args[1], args[2], args[3], args[4], args[5]);
                          break;
                        case _util2.OPS.setTextRise:
                          this.setTextRise(args[0]);
                          break;
                        case _util2.OPS.setTextRenderingMode:
                          this.setTextRenderingMode(args[0]);
                          break;
                        case _util2.OPS.setLineWidth:
                          this.setLineWidth(args[0]);
                          break;
                        case _util2.OPS.setLineJoin:
                          this.setLineJoin(args[0]);
                          break;
                        case _util2.OPS.setLineCap:
                          this.setLineCap(args[0]);
                          break;
                        case _util2.OPS.setMiterLimit:
                          this.setMiterLimit(args[0]);
                          break;
                        case _util2.OPS.setFillRGBColor:
                          this.setFillRGBColor(args[0], args[1], args[2]);
                          break;
                        case _util2.OPS.setStrokeRGBColor:
                          this.setStrokeRGBColor(args[0], args[1], args[2]);
                          break;
                        case _util2.OPS.setStrokeColorN:
                          this.setStrokeColorN(args);
                          break;
                        case _util2.OPS.setFillColorN:
                          this.setFillColorN(args);
                          break;
                        case _util2.OPS.shadingFill:
                          this.shadingFill(args[0]);
                          break;
                        case _util2.OPS.setDash:
                          this.setDash(args[0], args[1]);
                          break;
                        case _util2.OPS.setRenderingIntent:
                          this.setRenderingIntent(args[0]);
                          break;
                        case _util2.OPS.setFlatness:
                          this.setFlatness(args[0]);
                          break;
                        case _util2.OPS.setGState:
                          this.setGState(args[0]);
                          break;
                        case _util2.OPS.fill:
                          this.fill();
                          break;
                        case _util2.OPS.eoFill:
                          this.eoFill();
                          break;
                        case _util2.OPS.stroke:
                          this.stroke();
                          break;
                        case _util2.OPS.fillStroke:
                          this.fillStroke();
                          break;
                        case _util2.OPS.eoFillStroke:
                          this.eoFillStroke();
                          break;
                        case _util2.OPS.clip:
                          this.clip("nonzero");
                          break;
                        case _util2.OPS.eoClip:
                          this.clip("evenodd");
                          break;
                        case _util2.OPS.paintSolidColorImageMask:
                          this.paintSolidColorImageMask();
                          break;
                        case _util2.OPS.paintImageXObject:
                          this.paintImageXObject(args[0]);
                          break;
                        case _util2.OPS.paintInlineImageXObject:
                          this.paintInlineImageXObject(args[0]);
                          break;
                        case _util2.OPS.paintImageMaskXObject:
                          this.paintImageMaskXObject(args[0]);
                          break;
                        case _util2.OPS.paintFormXObjectBegin:
                          this.paintFormXObjectBegin(args[0], args[1]);
                          break;
                        case _util2.OPS.paintFormXObjectEnd:
                          this.paintFormXObjectEnd();
                          break;
                        case _util2.OPS.closePath:
                          this.closePath();
                          break;
                        case _util2.OPS.closeStroke:
                          this.closeStroke();
                          break;
                        case _util2.OPS.closeFillStroke:
                          this.closeFillStroke();
                          break;
                        case _util2.OPS.closeEOFillStroke:
                          this.closeEOFillStroke();
                          break;
                        case _util2.OPS.nextLine:
                          this.nextLine();
                          break;
                        case _util2.OPS.transform:
                          this.transform(args[0], args[1], args[2], args[3], args[4], args[5]);
                          break;
                        case _util2.OPS.constructPath:
                          this.constructPath(args[0], args[1]);
                          break;
                        case _util2.OPS.endPath:
                          this.endPath();
                          break;
                        case 92:
                          this.group(opTreeElement.items);
                          break;
                        default:
                          (0, _util2.warn)(`Unimplemented operator ${fn}`);
                          break;
                      }
                    }
                  }
                  setWordSpacing(wordSpacing) {
                    this.current.wordSpacing = wordSpacing;
                  }
                  setCharSpacing(charSpacing) {
                    this.current.charSpacing = charSpacing;
                  }
                  nextLine() {
                    this.moveText(0, this.current.leading);
                  }
                  setTextMatrix(a, b, c, d, e, f) {
                    const current = this.current;
                    current.textMatrix = current.lineMatrix = [a, b, c, d, e, f];
                    current.textMatrixScale = Math.hypot(a, b);
                    current.x = current.lineX = 0;
                    current.y = current.lineY = 0;
                    current.xcoords = [];
                    current.ycoords = [];
                    current.tspan = this.svgFactory.createElement("svg:tspan");
                    current.tspan.setAttributeNS(null, "font-family", current.fontFamily);
                    current.tspan.setAttributeNS(null, "font-size", `${pf(current.fontSize)}px`);
                    current.tspan.setAttributeNS(null, "y", pf(-current.y));
                    current.txtElement = this.svgFactory.createElement("svg:text");
                    current.txtElement.append(current.tspan);
                  }
                  beginText() {
                    const current = this.current;
                    current.x = current.lineX = 0;
                    current.y = current.lineY = 0;
                    current.textMatrix = _util2.IDENTITY_MATRIX;
                    current.lineMatrix = _util2.IDENTITY_MATRIX;
                    current.textMatrixScale = 1;
                    current.tspan = this.svgFactory.createElement("svg:tspan");
                    current.txtElement = this.svgFactory.createElement("svg:text");
                    current.txtgrp = this.svgFactory.createElement("svg:g");
                    current.xcoords = [];
                    current.ycoords = [];
                  }
                  moveText(x, y) {
                    const current = this.current;
                    current.x = current.lineX += x;
                    current.y = current.lineY += y;
                    current.xcoords = [];
                    current.ycoords = [];
                    current.tspan = this.svgFactory.createElement("svg:tspan");
                    current.tspan.setAttributeNS(null, "font-family", current.fontFamily);
                    current.tspan.setAttributeNS(null, "font-size", `${pf(current.fontSize)}px`);
                    current.tspan.setAttributeNS(null, "y", pf(-current.y));
                  }
                  showText(glyphs) {
                    const current = this.current;
                    const font = current.font;
                    const fontSize = current.fontSize;
                    if (fontSize === 0) {
                      return;
                    }
                    const fontSizeScale = current.fontSizeScale;
                    const charSpacing = current.charSpacing;
                    const wordSpacing = current.wordSpacing;
                    const fontDirection = current.fontDirection;
                    const textHScale = current.textHScale * fontDirection;
                    const vertical = font.vertical;
                    const spacingDir = vertical ? 1 : -1;
                    const defaultVMetrics = font.defaultVMetrics;
                    const widthAdvanceScale = fontSize * current.fontMatrix[0];
                    let x = 0;
                    for (const glyph of glyphs) {
                      if (glyph === null) {
                        x += fontDirection * wordSpacing;
                        continue;
                      } else if (typeof glyph === "number") {
                        x += spacingDir * glyph * fontSize / 1e3;
                        continue;
                      }
                      const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
                      const character = glyph.fontChar;
                      let scaledX, scaledY;
                      let width = glyph.width;
                      if (vertical) {
                        let vx;
                        const vmetric = glyph.vmetric || defaultVMetrics;
                        vx = glyph.vmetric ? vmetric[1] : width * 0.5;
                        vx = -vx * widthAdvanceScale;
                        const vy = vmetric[2] * widthAdvanceScale;
                        width = vmetric ? -vmetric[0] : width;
                        scaledX = vx / fontSizeScale;
                        scaledY = (x + vy) / fontSizeScale;
                      } else {
                        scaledX = x / fontSizeScale;
                        scaledY = 0;
                      }
                      if (glyph.isInFont || font.missingFile) {
                        current.xcoords.push(current.x + scaledX);
                        if (vertical) {
                          current.ycoords.push(-current.y + scaledY);
                        }
                        current.tspan.textContent += character;
                      } else {
                      }
                      let charWidth;
                      if (vertical) {
                        charWidth = width * widthAdvanceScale - spacing * fontDirection;
                      } else {
                        charWidth = width * widthAdvanceScale + spacing * fontDirection;
                      }
                      x += charWidth;
                    }
                    current.tspan.setAttributeNS(null, "x", current.xcoords.map(pf).join(" "));
                    if (vertical) {
                      current.tspan.setAttributeNS(null, "y", current.ycoords.map(pf).join(" "));
                    } else {
                      current.tspan.setAttributeNS(null, "y", pf(-current.y));
                    }
                    if (vertical) {
                      current.y -= x;
                    } else {
                      current.x += x * textHScale;
                    }
                    current.tspan.setAttributeNS(null, "font-family", current.fontFamily);
                    current.tspan.setAttributeNS(null, "font-size", `${pf(current.fontSize)}px`);
                    if (current.fontStyle !== SVG_DEFAULTS.fontStyle) {
                      current.tspan.setAttributeNS(null, "font-style", current.fontStyle);
                    }
                    if (current.fontWeight !== SVG_DEFAULTS.fontWeight) {
                      current.tspan.setAttributeNS(null, "font-weight", current.fontWeight);
                    }
                    const fillStrokeMode = current.textRenderingMode & _util2.TextRenderingMode.FILL_STROKE_MASK;
                    if (fillStrokeMode === _util2.TextRenderingMode.FILL || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                      if (current.fillColor !== SVG_DEFAULTS.fillColor) {
                        current.tspan.setAttributeNS(null, "fill", current.fillColor);
                      }
                      if (current.fillAlpha < 1) {
                        current.tspan.setAttributeNS(null, "fill-opacity", current.fillAlpha);
                      }
                    } else if (current.textRenderingMode === _util2.TextRenderingMode.ADD_TO_PATH) {
                      current.tspan.setAttributeNS(null, "fill", "transparent");
                    } else {
                      current.tspan.setAttributeNS(null, "fill", "none");
                    }
                    if (fillStrokeMode === _util2.TextRenderingMode.STROKE || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                      const lineWidthScale = 1 / (current.textMatrixScale || 1);
                      this._setStrokeAttributes(current.tspan, lineWidthScale);
                    }
                    let textMatrix = current.textMatrix;
                    if (current.textRise !== 0) {
                      textMatrix = textMatrix.slice();
                      textMatrix[5] += current.textRise;
                    }
                    current.txtElement.setAttributeNS(null, "transform", `${pm(textMatrix)} scale(${pf(textHScale)}, -1)`);
                    current.txtElement.setAttributeNS(XML_NS, "xml:space", "preserve");
                    current.txtElement.append(current.tspan);
                    current.txtgrp.append(current.txtElement);
                    this._ensureTransformGroup().append(current.txtElement);
                  }
                  setLeadingMoveText(x, y) {
                    this.setLeading(-y);
                    this.moveText(x, y);
                  }
                  addFontStyle(fontObj) {
                    if (!fontObj.data) {
                      throw new Error('addFontStyle: No font data available, ensure that the "fontExtraProperties" API parameter is set.');
                    }
                    if (!this.cssStyle) {
                      this.cssStyle = this.svgFactory.createElement("svg:style");
                      this.cssStyle.setAttributeNS(null, "type", "text/css");
                      this.defs.append(this.cssStyle);
                    }
                    const url = createObjectURL(fontObj.data, fontObj.mimetype, this.forceDataSchema);
                    this.cssStyle.textContent += `@font-face { font-family: "${fontObj.loadedName}"; src: url(${url}); }
`;
                  }
                  setFont(details) {
                    const current = this.current;
                    const fontObj = this.commonObjs.get(details[0]);
                    let size = details[1];
                    current.font = fontObj;
                    if (this.embedFonts && !fontObj.missingFile && !this.embeddedFonts[fontObj.loadedName]) {
                      this.addFontStyle(fontObj);
                      this.embeddedFonts[fontObj.loadedName] = fontObj;
                    }
                    current.fontMatrix = fontObj.fontMatrix || _util2.FONT_IDENTITY_MATRIX;
                    let bold = "normal";
                    if (fontObj.black) {
                      bold = "900";
                    } else if (fontObj.bold) {
                      bold = "bold";
                    }
                    const italic = fontObj.italic ? "italic" : "normal";
                    if (size < 0) {
                      size = -size;
                      current.fontDirection = -1;
                    } else {
                      current.fontDirection = 1;
                    }
                    current.fontSize = size;
                    current.fontFamily = fontObj.loadedName;
                    current.fontWeight = bold;
                    current.fontStyle = italic;
                    current.tspan = this.svgFactory.createElement("svg:tspan");
                    current.tspan.setAttributeNS(null, "y", pf(-current.y));
                    current.xcoords = [];
                    current.ycoords = [];
                  }
                  endText() {
                    var _current$txtElement;
                    const current = this.current;
                    if (current.textRenderingMode & _util2.TextRenderingMode.ADD_TO_PATH_FLAG && (_current$txtElement = current.txtElement) !== null && _current$txtElement !== void 0 && _current$txtElement.hasChildNodes()) {
                      current.element = current.txtElement;
                      this.clip("nonzero");
                      this.endPath();
                    }
                  }
                  setLineWidth(width) {
                    if (width > 0) {
                      this.current.lineWidth = width;
                    }
                  }
                  setLineCap(style) {
                    this.current.lineCap = LINE_CAP_STYLES[style];
                  }
                  setLineJoin(style) {
                    this.current.lineJoin = LINE_JOIN_STYLES[style];
                  }
                  setMiterLimit(limit) {
                    this.current.miterLimit = limit;
                  }
                  setStrokeAlpha(strokeAlpha) {
                    this.current.strokeAlpha = strokeAlpha;
                  }
                  setStrokeRGBColor(r2, g, b) {
                    this.current.strokeColor = _util2.Util.makeHexColor(r2, g, b);
                  }
                  setFillAlpha(fillAlpha) {
                    this.current.fillAlpha = fillAlpha;
                  }
                  setFillRGBColor(r2, g, b) {
                    this.current.fillColor = _util2.Util.makeHexColor(r2, g, b);
                    this.current.tspan = this.svgFactory.createElement("svg:tspan");
                    this.current.xcoords = [];
                    this.current.ycoords = [];
                  }
                  setStrokeColorN(args) {
                    this.current.strokeColor = this._makeColorN_Pattern(args);
                  }
                  setFillColorN(args) {
                    this.current.fillColor = this._makeColorN_Pattern(args);
                  }
                  shadingFill(args) {
                    const width = this.viewport.width;
                    const height = this.viewport.height;
                    const inv = _util2.Util.inverseTransform(this.transformMatrix);
                    const bl = _util2.Util.applyTransform([0, 0], inv);
                    const br = _util2.Util.applyTransform([0, height], inv);
                    const ul = _util2.Util.applyTransform([width, 0], inv);
                    const ur = _util2.Util.applyTransform([width, height], inv);
                    const x0 = Math.min(bl[0], br[0], ul[0], ur[0]);
                    const y0 = Math.min(bl[1], br[1], ul[1], ur[1]);
                    const x1 = Math.max(bl[0], br[0], ul[0], ur[0]);
                    const y1 = Math.max(bl[1], br[1], ul[1], ur[1]);
                    const rect = this.svgFactory.createElement("svg:rect");
                    rect.setAttributeNS(null, "x", x0);
                    rect.setAttributeNS(null, "y", y0);
                    rect.setAttributeNS(null, "width", x1 - x0);
                    rect.setAttributeNS(null, "height", y1 - y0);
                    rect.setAttributeNS(null, "fill", this._makeShadingPattern(args));
                    if (this.current.fillAlpha < 1) {
                      rect.setAttributeNS(null, "fill-opacity", this.current.fillAlpha);
                    }
                    this._ensureTransformGroup().append(rect);
                  }
                  _makeColorN_Pattern(args) {
                    if (args[0] === "TilingPattern") {
                      return this._makeTilingPattern(args);
                    }
                    return this._makeShadingPattern(args);
                  }
                  _makeTilingPattern(args) {
                    const color = args[1];
                    const operatorList = args[2];
                    const matrix = args[3] || _util2.IDENTITY_MATRIX;
                    const [x0, y0, x1, y1] = args[4];
                    const xstep = args[5];
                    const ystep = args[6];
                    const paintType = args[7];
                    const tilingId = `shading${shadingCount++}`;
                    const [tx0, ty0, tx1, ty1] = _util2.Util.normalizeRect([..._util2.Util.applyTransform([x0, y0], matrix), ..._util2.Util.applyTransform([x1, y1], matrix)]);
                    const [xscale, yscale] = _util2.Util.singularValueDecompose2dScale(matrix);
                    const txstep = xstep * xscale;
                    const tystep = ystep * yscale;
                    const tiling = this.svgFactory.createElement("svg:pattern");
                    tiling.setAttributeNS(null, "id", tilingId);
                    tiling.setAttributeNS(null, "patternUnits", "userSpaceOnUse");
                    tiling.setAttributeNS(null, "width", txstep);
                    tiling.setAttributeNS(null, "height", tystep);
                    tiling.setAttributeNS(null, "x", `${tx0}`);
                    tiling.setAttributeNS(null, "y", `${ty0}`);
                    const svg = this.svg;
                    const transformMatrix = this.transformMatrix;
                    const fillColor = this.current.fillColor;
                    const strokeColor = this.current.strokeColor;
                    const bbox = this.svgFactory.create(tx1 - tx0, ty1 - ty0);
                    this.svg = bbox;
                    this.transformMatrix = matrix;
                    if (paintType === 2) {
                      const cssColor = _util2.Util.makeHexColor(...color);
                      this.current.fillColor = cssColor;
                      this.current.strokeColor = cssColor;
                    }
                    this.executeOpTree(this.convertOpList(operatorList));
                    this.svg = svg;
                    this.transformMatrix = transformMatrix;
                    this.current.fillColor = fillColor;
                    this.current.strokeColor = strokeColor;
                    tiling.append(bbox.childNodes[0]);
                    this.defs.append(tiling);
                    return `url(#${tilingId})`;
                  }
                  _makeShadingPattern(args) {
                    if (typeof args === "string") {
                      args = this.objs.get(args);
                    }
                    switch (args[0]) {
                      case "RadialAxial":
                        const shadingId = `shading${shadingCount++}`;
                        const colorStops = args[3];
                        let gradient;
                        switch (args[1]) {
                          case "axial":
                            const point0 = args[4];
                            const point1 = args[5];
                            gradient = this.svgFactory.createElement("svg:linearGradient");
                            gradient.setAttributeNS(null, "id", shadingId);
                            gradient.setAttributeNS(null, "gradientUnits", "userSpaceOnUse");
                            gradient.setAttributeNS(null, "x1", point0[0]);
                            gradient.setAttributeNS(null, "y1", point0[1]);
                            gradient.setAttributeNS(null, "x2", point1[0]);
                            gradient.setAttributeNS(null, "y2", point1[1]);
                            break;
                          case "radial":
                            const focalPoint = args[4];
                            const circlePoint = args[5];
                            const focalRadius = args[6];
                            const circleRadius = args[7];
                            gradient = this.svgFactory.createElement("svg:radialGradient");
                            gradient.setAttributeNS(null, "id", shadingId);
                            gradient.setAttributeNS(null, "gradientUnits", "userSpaceOnUse");
                            gradient.setAttributeNS(null, "cx", circlePoint[0]);
                            gradient.setAttributeNS(null, "cy", circlePoint[1]);
                            gradient.setAttributeNS(null, "r", circleRadius);
                            gradient.setAttributeNS(null, "fx", focalPoint[0]);
                            gradient.setAttributeNS(null, "fy", focalPoint[1]);
                            gradient.setAttributeNS(null, "fr", focalRadius);
                            break;
                          default:
                            throw new Error(`Unknown RadialAxial type: ${args[1]}`);
                        }
                        for (const colorStop of colorStops) {
                          const stop = this.svgFactory.createElement("svg:stop");
                          stop.setAttributeNS(null, "offset", colorStop[0]);
                          stop.setAttributeNS(null, "stop-color", colorStop[1]);
                          gradient.append(stop);
                        }
                        this.defs.append(gradient);
                        return `url(#${shadingId})`;
                      case "Mesh":
                        (0, _util2.warn)("Unimplemented pattern Mesh");
                        return null;
                      case "Dummy":
                        return "hotpink";
                      default:
                        throw new Error(`Unknown IR type: ${args[0]}`);
                    }
                  }
                  setDash(dashArray, dashPhase) {
                    this.current.dashArray = dashArray;
                    this.current.dashPhase = dashPhase;
                  }
                  constructPath(ops, args) {
                    const current = this.current;
                    let x = current.x, y = current.y;
                    let d = [];
                    let j = 0;
                    for (const op of ops) {
                      switch (op | 0) {
                        case _util2.OPS.rectangle:
                          x = args[j++];
                          y = args[j++];
                          const width = args[j++];
                          const height = args[j++];
                          const xw = x + width;
                          const yh = y + height;
                          d.push("M", pf(x), pf(y), "L", pf(xw), pf(y), "L", pf(xw), pf(yh), "L", pf(x), pf(yh), "Z");
                          break;
                        case _util2.OPS.moveTo:
                          x = args[j++];
                          y = args[j++];
                          d.push("M", pf(x), pf(y));
                          break;
                        case _util2.OPS.lineTo:
                          x = args[j++];
                          y = args[j++];
                          d.push("L", pf(x), pf(y));
                          break;
                        case _util2.OPS.curveTo:
                          x = args[j + 4];
                          y = args[j + 5];
                          d.push("C", pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]), pf(x), pf(y));
                          j += 6;
                          break;
                        case _util2.OPS.curveTo2:
                          d.push("C", pf(x), pf(y), pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]));
                          x = args[j + 2];
                          y = args[j + 3];
                          j += 4;
                          break;
                        case _util2.OPS.curveTo3:
                          x = args[j + 2];
                          y = args[j + 3];
                          d.push("C", pf(args[j]), pf(args[j + 1]), pf(x), pf(y), pf(x), pf(y));
                          j += 4;
                          break;
                        case _util2.OPS.closePath:
                          d.push("Z");
                          break;
                      }
                    }
                    d = d.join(" ");
                    if (current.path && ops.length > 0 && ops[0] !== _util2.OPS.rectangle && ops[0] !== _util2.OPS.moveTo) {
                      d = current.path.getAttributeNS(null, "d") + d;
                    } else {
                      current.path = this.svgFactory.createElement("svg:path");
                      this._ensureTransformGroup().append(current.path);
                    }
                    current.path.setAttributeNS(null, "d", d);
                    current.path.setAttributeNS(null, "fill", "none");
                    current.element = current.path;
                    current.setCurrentPoint(x, y);
                  }
                  endPath() {
                    const current = this.current;
                    current.path = null;
                    if (!this.pendingClip) {
                      return;
                    }
                    if (!current.element) {
                      this.pendingClip = null;
                      return;
                    }
                    const clipId = `clippath${clipCount++}`;
                    const clipPath = this.svgFactory.createElement("svg:clipPath");
                    clipPath.setAttributeNS(null, "id", clipId);
                    clipPath.setAttributeNS(null, "transform", pm(this.transformMatrix));
                    const clipElement = current.element.cloneNode(true);
                    if (this.pendingClip === "evenodd") {
                      clipElement.setAttributeNS(null, "clip-rule", "evenodd");
                    } else {
                      clipElement.setAttributeNS(null, "clip-rule", "nonzero");
                    }
                    this.pendingClip = null;
                    clipPath.append(clipElement);
                    this.defs.append(clipPath);
                    if (current.activeClipUrl) {
                      current.clipGroup = null;
                      for (const prev of this.extraStack) {
                        prev.clipGroup = null;
                      }
                      clipPath.setAttributeNS(null, "clip-path", current.activeClipUrl);
                    }
                    current.activeClipUrl = `url(#${clipId})`;
                    this.tgrp = null;
                  }
                  clip(type) {
                    this.pendingClip = type;
                  }
                  closePath() {
                    const current = this.current;
                    if (current.path) {
                      const d = `${current.path.getAttributeNS(null, "d")}Z`;
                      current.path.setAttributeNS(null, "d", d);
                    }
                  }
                  setLeading(leading) {
                    this.current.leading = -leading;
                  }
                  setTextRise(textRise) {
                    this.current.textRise = textRise;
                  }
                  setTextRenderingMode(textRenderingMode) {
                    this.current.textRenderingMode = textRenderingMode;
                  }
                  setHScale(scale) {
                    this.current.textHScale = scale / 100;
                  }
                  setRenderingIntent(intent) {
                  }
                  setFlatness(flatness) {
                  }
                  setGState(states) {
                    for (const [key, value] of states) {
                      switch (key) {
                        case "LW":
                          this.setLineWidth(value);
                          break;
                        case "LC":
                          this.setLineCap(value);
                          break;
                        case "LJ":
                          this.setLineJoin(value);
                          break;
                        case "ML":
                          this.setMiterLimit(value);
                          break;
                        case "D":
                          this.setDash(value[0], value[1]);
                          break;
                        case "RI":
                          this.setRenderingIntent(value);
                          break;
                        case "FL":
                          this.setFlatness(value);
                          break;
                        case "Font":
                          this.setFont(value);
                          break;
                        case "CA":
                          this.setStrokeAlpha(value);
                          break;
                        case "ca":
                          this.setFillAlpha(value);
                          break;
                        default:
                          (0, _util2.warn)(`Unimplemented graphic state operator ${key}`);
                          break;
                      }
                    }
                  }
                  fill() {
                    const current = this.current;
                    if (current.element) {
                      current.element.setAttributeNS(null, "fill", current.fillColor);
                      current.element.setAttributeNS(null, "fill-opacity", current.fillAlpha);
                      this.endPath();
                    }
                  }
                  stroke() {
                    const current = this.current;
                    if (current.element) {
                      this._setStrokeAttributes(current.element);
                      current.element.setAttributeNS(null, "fill", "none");
                      this.endPath();
                    }
                  }
                  _setStrokeAttributes(element) {
                    let lineWidthScale = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
                    const current = this.current;
                    let dashArray = current.dashArray;
                    if (lineWidthScale !== 1 && dashArray.length > 0) {
                      dashArray = dashArray.map(function(value) {
                        return lineWidthScale * value;
                      });
                    }
                    element.setAttributeNS(null, "stroke", current.strokeColor);
                    element.setAttributeNS(null, "stroke-opacity", current.strokeAlpha);
                    element.setAttributeNS(null, "stroke-miterlimit", pf(current.miterLimit));
                    element.setAttributeNS(null, "stroke-linecap", current.lineCap);
                    element.setAttributeNS(null, "stroke-linejoin", current.lineJoin);
                    element.setAttributeNS(null, "stroke-width", pf(lineWidthScale * current.lineWidth) + "px");
                    element.setAttributeNS(null, "stroke-dasharray", dashArray.map(pf).join(" "));
                    element.setAttributeNS(null, "stroke-dashoffset", pf(lineWidthScale * current.dashPhase) + "px");
                  }
                  eoFill() {
                    if (this.current.element) {
                      this.current.element.setAttributeNS(null, "fill-rule", "evenodd");
                    }
                    this.fill();
                  }
                  fillStroke() {
                    this.stroke();
                    this.fill();
                  }
                  eoFillStroke() {
                    if (this.current.element) {
                      this.current.element.setAttributeNS(null, "fill-rule", "evenodd");
                    }
                    this.fillStroke();
                  }
                  closeStroke() {
                    this.closePath();
                    this.stroke();
                  }
                  closeFillStroke() {
                    this.closePath();
                    this.fillStroke();
                  }
                  closeEOFillStroke() {
                    this.closePath();
                    this.eoFillStroke();
                  }
                  paintSolidColorImageMask() {
                    const rect = this.svgFactory.createElement("svg:rect");
                    rect.setAttributeNS(null, "x", "0");
                    rect.setAttributeNS(null, "y", "0");
                    rect.setAttributeNS(null, "width", "1px");
                    rect.setAttributeNS(null, "height", "1px");
                    rect.setAttributeNS(null, "fill", this.current.fillColor);
                    this._ensureTransformGroup().append(rect);
                  }
                  paintImageXObject(objId) {
                    const imgData = objId.startsWith("g_") ? this.commonObjs.get(objId) : this.objs.get(objId);
                    if (!imgData) {
                      (0, _util2.warn)(`Dependent image with object ID ${objId} is not ready yet`);
                      return;
                    }
                    this.paintInlineImageXObject(imgData);
                  }
                  paintInlineImageXObject(imgData, mask) {
                    const width = imgData.width;
                    const height = imgData.height;
                    const imgSrc = convertImgDataToPng(imgData, this.forceDataSchema, !!mask);
                    const cliprect = this.svgFactory.createElement("svg:rect");
                    cliprect.setAttributeNS(null, "x", "0");
                    cliprect.setAttributeNS(null, "y", "0");
                    cliprect.setAttributeNS(null, "width", pf(width));
                    cliprect.setAttributeNS(null, "height", pf(height));
                    this.current.element = cliprect;
                    this.clip("nonzero");
                    const imgEl = this.svgFactory.createElement("svg:image");
                    imgEl.setAttributeNS(XLINK_NS, "xlink:href", imgSrc);
                    imgEl.setAttributeNS(null, "x", "0");
                    imgEl.setAttributeNS(null, "y", pf(-height));
                    imgEl.setAttributeNS(null, "width", pf(width) + "px");
                    imgEl.setAttributeNS(null, "height", pf(height) + "px");
                    imgEl.setAttributeNS(null, "transform", `scale(${pf(1 / width)} ${pf(-1 / height)})`);
                    if (mask) {
                      mask.append(imgEl);
                    } else {
                      this._ensureTransformGroup().append(imgEl);
                    }
                  }
                  paintImageMaskXObject(imgData) {
                    const current = this.current;
                    const width = imgData.width;
                    const height = imgData.height;
                    const fillColor = current.fillColor;
                    current.maskId = `mask${maskCount++}`;
                    const mask = this.svgFactory.createElement("svg:mask");
                    mask.setAttributeNS(null, "id", current.maskId);
                    const rect = this.svgFactory.createElement("svg:rect");
                    rect.setAttributeNS(null, "x", "0");
                    rect.setAttributeNS(null, "y", "0");
                    rect.setAttributeNS(null, "width", pf(width));
                    rect.setAttributeNS(null, "height", pf(height));
                    rect.setAttributeNS(null, "fill", fillColor);
                    rect.setAttributeNS(null, "mask", `url(#${current.maskId})`);
                    this.defs.append(mask);
                    this._ensureTransformGroup().append(rect);
                    this.paintInlineImageXObject(imgData, mask);
                  }
                  paintFormXObjectBegin(matrix, bbox) {
                    if (Array.isArray(matrix) && matrix.length === 6) {
                      this.transform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);
                    }
                    if (bbox) {
                      const width = bbox[2] - bbox[0];
                      const height = bbox[3] - bbox[1];
                      const cliprect = this.svgFactory.createElement("svg:rect");
                      cliprect.setAttributeNS(null, "x", bbox[0]);
                      cliprect.setAttributeNS(null, "y", bbox[1]);
                      cliprect.setAttributeNS(null, "width", pf(width));
                      cliprect.setAttributeNS(null, "height", pf(height));
                      this.current.element = cliprect;
                      this.clip("nonzero");
                      this.endPath();
                    }
                  }
                  paintFormXObjectEnd() {
                  }
                  _initialize(viewport) {
                    const svg = this.svgFactory.create(viewport.width, viewport.height);
                    const definitions = this.svgFactory.createElement("svg:defs");
                    svg.append(definitions);
                    this.defs = definitions;
                    const rootGroup = this.svgFactory.createElement("svg:g");
                    rootGroup.setAttributeNS(null, "transform", pm(viewport.transform));
                    svg.append(rootGroup);
                    this.svg = rootGroup;
                    return svg;
                  }
                  _ensureClipGroup() {
                    if (!this.current.clipGroup) {
                      const clipGroup = this.svgFactory.createElement("svg:g");
                      clipGroup.setAttributeNS(null, "clip-path", this.current.activeClipUrl);
                      this.svg.append(clipGroup);
                      this.current.clipGroup = clipGroup;
                    }
                    return this.current.clipGroup;
                  }
                  _ensureTransformGroup() {
                    if (!this.tgrp) {
                      this.tgrp = this.svgFactory.createElement("svg:g");
                      this.tgrp.setAttributeNS(null, "transform", pm(this.transformMatrix));
                      if (this.current.activeClipUrl) {
                        this._ensureClipGroup().append(this.tgrp);
                      } else {
                        this.svg.append(this.tgrp);
                      }
                    }
                    return this.tgrp;
                  }
                };
              }
            },
            /* 157 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.PDFNodeStream = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              var _network_utils = __w_pdfjs_require__2(158);
              ;
              const fs = require_fs();
              const http = require_http();
              const https = require_https();
              const url = require_url();
              const fileUriRegex = /^file:\/\/\/[a-zA-Z]:\//;
              function parseUrl(sourceUrl) {
                const parsedUrl = url.parse(sourceUrl);
                if (parsedUrl.protocol === "file:" || parsedUrl.host) {
                  return parsedUrl;
                }
                if (/^[a-z]:[/\\]/i.test(sourceUrl)) {
                  return url.parse(`file:///${sourceUrl}`);
                }
                if (!parsedUrl.host) {
                  parsedUrl.protocol = "file:";
                }
                return parsedUrl;
              }
              class PDFNodeStream {
                constructor(source) {
                  this.source = source;
                  this.url = parseUrl(source.url);
                  this.isHttp = this.url.protocol === "http:" || this.url.protocol === "https:";
                  this.isFsUrl = this.url.protocol === "file:";
                  this.httpHeaders = this.isHttp && source.httpHeaders || {};
                  this._fullRequestReader = null;
                  this._rangeRequestReaders = [];
                }
                get _progressiveDataLength() {
                  var _this$_fullRequestRea, _this$_fullRequestRea2;
                  return (_this$_fullRequestRea = (_this$_fullRequestRea2 = this._fullRequestReader) === null || _this$_fullRequestRea2 === void 0 ? void 0 : _this$_fullRequestRea2._loaded) !== null && _this$_fullRequestRea !== void 0 ? _this$_fullRequestRea : 0;
                }
                getFullReader() {
                  (0, _util2.assert)(!this._fullRequestReader, "PDFNodeStream.getFullReader can only be called once.");
                  this._fullRequestReader = this.isFsUrl ? new PDFNodeStreamFsFullReader(this) : new PDFNodeStreamFullReader(this);
                  return this._fullRequestReader;
                }
                getRangeReader(start, end) {
                  if (end <= this._progressiveDataLength) {
                    return null;
                  }
                  const rangeReader = this.isFsUrl ? new PDFNodeStreamFsRangeReader(this, start, end) : new PDFNodeStreamRangeReader(this, start, end);
                  this._rangeRequestReaders.push(rangeReader);
                  return rangeReader;
                }
                cancelAllRequests(reason) {
                  if (this._fullRequestReader) {
                    this._fullRequestReader.cancel(reason);
                  }
                  for (const reader of this._rangeRequestReaders.slice(0)) {
                    reader.cancel(reason);
                  }
                }
              }
              exports2.PDFNodeStream = PDFNodeStream;
              class BaseFullReader {
                constructor(stream) {
                  this._url = stream.url;
                  this._done = false;
                  this._storedError = null;
                  this.onProgress = null;
                  const source = stream.source;
                  this._contentLength = source.length;
                  this._loaded = 0;
                  this._filename = null;
                  this._disableRange = source.disableRange || false;
                  this._rangeChunkSize = source.rangeChunkSize;
                  if (!this._rangeChunkSize && !this._disableRange) {
                    this._disableRange = true;
                  }
                  this._isStreamingSupported = !source.disableStream;
                  this._isRangeSupported = !source.disableRange;
                  this._readableStream = null;
                  this._readCapability = (0, _util2.createPromiseCapability)();
                  this._headersCapability = (0, _util2.createPromiseCapability)();
                }
                get headersReady() {
                  return this._headersCapability.promise;
                }
                get filename() {
                  return this._filename;
                }
                get contentLength() {
                  return this._contentLength;
                }
                get isRangeSupported() {
                  return this._isRangeSupported;
                }
                get isStreamingSupported() {
                  return this._isStreamingSupported;
                }
                async read() {
                  await this._readCapability.promise;
                  if (this._done) {
                    return {
                      value: void 0,
                      done: true
                    };
                  }
                  if (this._storedError) {
                    throw this._storedError;
                  }
                  const chunk = this._readableStream.read();
                  if (chunk === null) {
                    this._readCapability = (0, _util2.createPromiseCapability)();
                    return this.read();
                  }
                  this._loaded += chunk.length;
                  if (this.onProgress) {
                    this.onProgress({
                      loaded: this._loaded,
                      total: this._contentLength
                    });
                  }
                  const buffer = new Uint8Array(chunk).buffer;
                  return {
                    value: buffer,
                    done: false
                  };
                }
                cancel(reason) {
                  if (!this._readableStream) {
                    this._error(reason);
                    return;
                  }
                  this._readableStream.destroy(reason);
                }
                _error(reason) {
                  this._storedError = reason;
                  this._readCapability.resolve();
                }
                _setReadableStream(readableStream) {
                  this._readableStream = readableStream;
                  readableStream.on("readable", () => {
                    this._readCapability.resolve();
                  });
                  readableStream.on("end", () => {
                    readableStream.destroy();
                    this._done = true;
                    this._readCapability.resolve();
                  });
                  readableStream.on("error", (reason) => {
                    this._error(reason);
                  });
                  if (!this._isStreamingSupported && this._isRangeSupported) {
                    this._error(new _util2.AbortException("streaming is disabled"));
                  }
                  if (this._storedError) {
                    this._readableStream.destroy(this._storedError);
                  }
                }
              }
              class BaseRangeReader {
                constructor(stream) {
                  this._url = stream.url;
                  this._done = false;
                  this._storedError = null;
                  this.onProgress = null;
                  this._loaded = 0;
                  this._readableStream = null;
                  this._readCapability = (0, _util2.createPromiseCapability)();
                  const source = stream.source;
                  this._isStreamingSupported = !source.disableStream;
                }
                get isStreamingSupported() {
                  return this._isStreamingSupported;
                }
                async read() {
                  await this._readCapability.promise;
                  if (this._done) {
                    return {
                      value: void 0,
                      done: true
                    };
                  }
                  if (this._storedError) {
                    throw this._storedError;
                  }
                  const chunk = this._readableStream.read();
                  if (chunk === null) {
                    this._readCapability = (0, _util2.createPromiseCapability)();
                    return this.read();
                  }
                  this._loaded += chunk.length;
                  if (this.onProgress) {
                    this.onProgress({
                      loaded: this._loaded
                    });
                  }
                  const buffer = new Uint8Array(chunk).buffer;
                  return {
                    value: buffer,
                    done: false
                  };
                }
                cancel(reason) {
                  if (!this._readableStream) {
                    this._error(reason);
                    return;
                  }
                  this._readableStream.destroy(reason);
                }
                _error(reason) {
                  this._storedError = reason;
                  this._readCapability.resolve();
                }
                _setReadableStream(readableStream) {
                  this._readableStream = readableStream;
                  readableStream.on("readable", () => {
                    this._readCapability.resolve();
                  });
                  readableStream.on("end", () => {
                    readableStream.destroy();
                    this._done = true;
                    this._readCapability.resolve();
                  });
                  readableStream.on("error", (reason) => {
                    this._error(reason);
                  });
                  if (this._storedError) {
                    this._readableStream.destroy(this._storedError);
                  }
                }
              }
              function createRequestOptions(parsedUrl, headers) {
                return {
                  protocol: parsedUrl.protocol,
                  auth: parsedUrl.auth,
                  host: parsedUrl.hostname,
                  port: parsedUrl.port,
                  path: parsedUrl.path,
                  method: "GET",
                  headers
                };
              }
              class PDFNodeStreamFullReader extends BaseFullReader {
                constructor(stream) {
                  super(stream);
                  const handleResponse = (response) => {
                    if (response.statusCode === 404) {
                      const error = new _util2.MissingPDFException(`Missing PDF "${this._url}".`);
                      this._storedError = error;
                      this._headersCapability.reject(error);
                      return;
                    }
                    this._headersCapability.resolve();
                    this._setReadableStream(response);
                    const getResponseHeader = (name) => {
                      return this._readableStream.headers[name.toLowerCase()];
                    };
                    const {
                      allowRangeRequests,
                      suggestedLength
                    } = (0, _network_utils.validateRangeRequestCapabilities)({
                      getResponseHeader,
                      isHttp: stream.isHttp,
                      rangeChunkSize: this._rangeChunkSize,
                      disableRange: this._disableRange
                    });
                    this._isRangeSupported = allowRangeRequests;
                    this._contentLength = suggestedLength || this._contentLength;
                    this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);
                  };
                  this._request = null;
                  if (this._url.protocol === "http:") {
                    this._request = http.request(createRequestOptions(this._url, stream.httpHeaders), handleResponse);
                  } else {
                    this._request = https.request(createRequestOptions(this._url, stream.httpHeaders), handleResponse);
                  }
                  this._request.on("error", (reason) => {
                    this._storedError = reason;
                    this._headersCapability.reject(reason);
                  });
                  this._request.end();
                }
              }
              class PDFNodeStreamRangeReader extends BaseRangeReader {
                constructor(stream, start, end) {
                  super(stream);
                  this._httpHeaders = {};
                  for (const property in stream.httpHeaders) {
                    const value = stream.httpHeaders[property];
                    if (typeof value === "undefined") {
                      continue;
                    }
                    this._httpHeaders[property] = value;
                  }
                  this._httpHeaders.Range = `bytes=${start}-${end - 1}`;
                  const handleResponse = (response) => {
                    if (response.statusCode === 404) {
                      const error = new _util2.MissingPDFException(`Missing PDF "${this._url}".`);
                      this._storedError = error;
                      return;
                    }
                    this._setReadableStream(response);
                  };
                  this._request = null;
                  if (this._url.protocol === "http:") {
                    this._request = http.request(createRequestOptions(this._url, this._httpHeaders), handleResponse);
                  } else {
                    this._request = https.request(createRequestOptions(this._url, this._httpHeaders), handleResponse);
                  }
                  this._request.on("error", (reason) => {
                    this._storedError = reason;
                  });
                  this._request.end();
                }
              }
              class PDFNodeStreamFsFullReader extends BaseFullReader {
                constructor(stream) {
                  super(stream);
                  let path = decodeURIComponent(this._url.path);
                  if (fileUriRegex.test(this._url.href)) {
                    path = path.replace(/^\//, "");
                  }
                  fs.lstat(path, (error, stat) => {
                    if (error) {
                      if (error.code === "ENOENT") {
                        error = new _util2.MissingPDFException(`Missing PDF "${path}".`);
                      }
                      this._storedError = error;
                      this._headersCapability.reject(error);
                      return;
                    }
                    this._contentLength = stat.size;
                    this._setReadableStream(fs.createReadStream(path));
                    this._headersCapability.resolve();
                  });
                }
              }
              class PDFNodeStreamFsRangeReader extends BaseRangeReader {
                constructor(stream, start, end) {
                  super(stream);
                  let path = decodeURIComponent(this._url.path);
                  if (fileUriRegex.test(this._url.href)) {
                    path = path.replace(/^\//, "");
                  }
                  this._setReadableStream(fs.createReadStream(path, {
                    start,
                    end: end - 1
                  }));
                }
              }
            },
            /* 158 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.createResponseStatusError = createResponseStatusError;
              exports2.extractFilenameFromHeader = extractFilenameFromHeader;
              exports2.validateRangeRequestCapabilities = validateRangeRequestCapabilities;
              exports2.validateResponseStatus = validateResponseStatus;
              var _util2 = __w_pdfjs_require__2(1);
              var _content_disposition = __w_pdfjs_require__2(159);
              var _display_utils2 = __w_pdfjs_require__2(133);
              function validateRangeRequestCapabilities(_ref) {
                let {
                  getResponseHeader,
                  isHttp,
                  rangeChunkSize,
                  disableRange
                } = _ref;
                const returnValues = {
                  allowRangeRequests: false,
                  suggestedLength: void 0
                };
                const length = parseInt(getResponseHeader("Content-Length"), 10);
                if (!Number.isInteger(length)) {
                  return returnValues;
                }
                returnValues.suggestedLength = length;
                if (length <= 2 * rangeChunkSize) {
                  return returnValues;
                }
                if (disableRange || !isHttp) {
                  return returnValues;
                }
                if (getResponseHeader("Accept-Ranges") !== "bytes") {
                  return returnValues;
                }
                const contentEncoding = getResponseHeader("Content-Encoding") || "identity";
                if (contentEncoding !== "identity") {
                  return returnValues;
                }
                returnValues.allowRangeRequests = true;
                return returnValues;
              }
              function extractFilenameFromHeader(getResponseHeader) {
                const contentDisposition = getResponseHeader("Content-Disposition");
                if (contentDisposition) {
                  let filename = (0, _content_disposition.getFilenameFromContentDispositionHeader)(contentDisposition);
                  if (filename.includes("%")) {
                    try {
                      filename = decodeURIComponent(filename);
                    } catch (ex) {
                    }
                  }
                  if ((0, _display_utils2.isPdfFile)(filename)) {
                    return filename;
                  }
                }
                return null;
              }
              function createResponseStatusError(status, url) {
                if (status === 404 || status === 0 && url.startsWith("file:")) {
                  return new _util2.MissingPDFException('Missing PDF "' + url + '".');
                }
                return new _util2.UnexpectedResponseException(`Unexpected server response (${status}) while retrieving PDF "${url}".`, status);
              }
              function validateResponseStatus(status) {
                return status === 200 || status === 206;
              }
            },
            /* 159 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.getFilenameFromContentDispositionHeader = getFilenameFromContentDispositionHeader;
              var _util2 = __w_pdfjs_require__2(1);
              function getFilenameFromContentDispositionHeader(contentDisposition) {
                let needsEncodingFixup = true;
                let tmp = toParamRegExp("filename\\*", "i").exec(contentDisposition);
                if (tmp) {
                  tmp = tmp[1];
                  let filename = rfc2616unquote(tmp);
                  filename = unescape(filename);
                  filename = rfc5987decode(filename);
                  filename = rfc2047decode(filename);
                  return fixupEncoding(filename);
                }
                tmp = rfc2231getparam(contentDisposition);
                if (tmp) {
                  const filename = rfc2047decode(tmp);
                  return fixupEncoding(filename);
                }
                tmp = toParamRegExp("filename", "i").exec(contentDisposition);
                if (tmp) {
                  tmp = tmp[1];
                  let filename = rfc2616unquote(tmp);
                  filename = rfc2047decode(filename);
                  return fixupEncoding(filename);
                }
                function toParamRegExp(attributePattern, flags) {
                  return new RegExp("(?:^|;)\\s*" + attributePattern + '\\s*=\\s*([^";\\s][^;\\s]*|"(?:[^"\\\\]|\\\\"?)+"?)', flags);
                }
                function textdecode(encoding, value) {
                  if (encoding) {
                    if (!/^[\x00-\xFF]+$/.test(value)) {
                      return value;
                    }
                    try {
                      const decoder = new TextDecoder(encoding, {
                        fatal: true
                      });
                      const buffer = (0, _util2.stringToBytes)(value);
                      value = decoder.decode(buffer);
                      needsEncodingFixup = false;
                    } catch (e) {
                    }
                  }
                  return value;
                }
                function fixupEncoding(value) {
                  if (needsEncodingFixup && /[\x80-\xff]/.test(value)) {
                    value = textdecode("utf-8", value);
                    if (needsEncodingFixup) {
                      value = textdecode("iso-8859-1", value);
                    }
                  }
                  return value;
                }
                function rfc2231getparam(contentDispositionStr) {
                  const matches = [];
                  let match;
                  const iter = toParamRegExp("filename\\*((?!0\\d)\\d+)(\\*?)", "ig");
                  while ((match = iter.exec(contentDispositionStr)) !== null) {
                    let [, n, quot, part] = match;
                    n = parseInt(n, 10);
                    if (n in matches) {
                      if (n === 0) {
                        break;
                      }
                      continue;
                    }
                    matches[n] = [quot, part];
                  }
                  const parts = [];
                  for (let n = 0; n < matches.length; ++n) {
                    if (!(n in matches)) {
                      break;
                    }
                    let [quot, part] = matches[n];
                    part = rfc2616unquote(part);
                    if (quot) {
                      part = unescape(part);
                      if (n === 0) {
                        part = rfc5987decode(part);
                      }
                    }
                    parts.push(part);
                  }
                  return parts.join("");
                }
                function rfc2616unquote(value) {
                  if (value.startsWith('"')) {
                    const parts = value.slice(1).split('\\"');
                    for (let i = 0; i < parts.length; ++i) {
                      const quotindex = parts[i].indexOf('"');
                      if (quotindex !== -1) {
                        parts[i] = parts[i].slice(0, quotindex);
                        parts.length = i + 1;
                      }
                      parts[i] = parts[i].replace(/\\(.)/g, "$1");
                    }
                    value = parts.join('"');
                  }
                  return value;
                }
                function rfc5987decode(extvalue) {
                  const encodingend = extvalue.indexOf("'");
                  if (encodingend === -1) {
                    return extvalue;
                  }
                  const encoding = extvalue.slice(0, encodingend);
                  const langvalue = extvalue.slice(encodingend + 1);
                  const value = langvalue.replace(/^[^']*'/, "");
                  return textdecode(encoding, value);
                }
                function rfc2047decode(value) {
                  if (!value.startsWith("=?") || /[\x00-\x19\x80-\xff]/.test(value)) {
                    return value;
                  }
                  return value.replace(/=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g, function(matches, charset, encoding, text) {
                    if (encoding === "q" || encoding === "Q") {
                      text = text.replace(/_/g, " ");
                      text = text.replace(/=([0-9a-fA-F]{2})/g, function(match, hex) {
                        return String.fromCharCode(parseInt(hex, 16));
                      });
                      return textdecode(charset, text);
                    }
                    try {
                      text = atob(text);
                    } catch (e) {
                    }
                    return textdecode(charset, text);
                  });
                }
                return "";
              }
            },
            /* 160 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.PDFNetworkStream = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              var _network_utils = __w_pdfjs_require__2(158);
              ;
              const OK_RESPONSE = 200;
              const PARTIAL_CONTENT_RESPONSE = 206;
              function getArrayBuffer(xhr) {
                const data = xhr.response;
                if (typeof data !== "string") {
                  return data;
                }
                const array = (0, _util2.stringToBytes)(data);
                return array.buffer;
              }
              class NetworkManager {
                constructor(url) {
                  let args = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                  this.url = url;
                  this.isHttp = /^https?:/i.test(url);
                  this.httpHeaders = this.isHttp && args.httpHeaders || /* @__PURE__ */ Object.create(null);
                  this.withCredentials = args.withCredentials || false;
                  this.getXhr = args.getXhr || function NetworkManager_getXhr() {
                    return new XMLHttpRequest();
                  };
                  this.currXhrId = 0;
                  this.pendingRequests = /* @__PURE__ */ Object.create(null);
                }
                requestRange(begin, end, listeners) {
                  const args = {
                    begin,
                    end
                  };
                  for (const prop in listeners) {
                    args[prop] = listeners[prop];
                  }
                  return this.request(args);
                }
                requestFull(listeners) {
                  return this.request(listeners);
                }
                request(args) {
                  const xhr = this.getXhr();
                  const xhrId = this.currXhrId++;
                  const pendingRequest = this.pendingRequests[xhrId] = {
                    xhr
                  };
                  xhr.open("GET", this.url);
                  xhr.withCredentials = this.withCredentials;
                  for (const property in this.httpHeaders) {
                    const value = this.httpHeaders[property];
                    if (typeof value === "undefined") {
                      continue;
                    }
                    xhr.setRequestHeader(property, value);
                  }
                  if (this.isHttp && "begin" in args && "end" in args) {
                    xhr.setRequestHeader("Range", `bytes=${args.begin}-${args.end - 1}`);
                    pendingRequest.expectedStatus = PARTIAL_CONTENT_RESPONSE;
                  } else {
                    pendingRequest.expectedStatus = OK_RESPONSE;
                  }
                  xhr.responseType = "arraybuffer";
                  if (args.onError) {
                    xhr.onerror = function(evt) {
                      args.onError(xhr.status);
                    };
                  }
                  xhr.onreadystatechange = this.onStateChange.bind(this, xhrId);
                  xhr.onprogress = this.onProgress.bind(this, xhrId);
                  pendingRequest.onHeadersReceived = args.onHeadersReceived;
                  pendingRequest.onDone = args.onDone;
                  pendingRequest.onError = args.onError;
                  pendingRequest.onProgress = args.onProgress;
                  xhr.send(null);
                  return xhrId;
                }
                onProgress(xhrId, evt) {
                  var _pendingRequest$onPro;
                  const pendingRequest = this.pendingRequests[xhrId];
                  if (!pendingRequest) {
                    return;
                  }
                  (_pendingRequest$onPro = pendingRequest.onProgress) === null || _pendingRequest$onPro === void 0 ? void 0 : _pendingRequest$onPro.call(pendingRequest, evt);
                }
                onStateChange(xhrId, evt) {
                  const pendingRequest = this.pendingRequests[xhrId];
                  if (!pendingRequest) {
                    return;
                  }
                  const xhr = pendingRequest.xhr;
                  if (xhr.readyState >= 2 && pendingRequest.onHeadersReceived) {
                    pendingRequest.onHeadersReceived();
                    delete pendingRequest.onHeadersReceived;
                  }
                  if (xhr.readyState !== 4) {
                    return;
                  }
                  if (!(xhrId in this.pendingRequests)) {
                    return;
                  }
                  delete this.pendingRequests[xhrId];
                  if (xhr.status === 0 && this.isHttp) {
                    var _pendingRequest$onErr;
                    (_pendingRequest$onErr = pendingRequest.onError) === null || _pendingRequest$onErr === void 0 ? void 0 : _pendingRequest$onErr.call(pendingRequest, xhr.status);
                    return;
                  }
                  const xhrStatus = xhr.status || OK_RESPONSE;
                  const ok_response_on_range_request = xhrStatus === OK_RESPONSE && pendingRequest.expectedStatus === PARTIAL_CONTENT_RESPONSE;
                  if (!ok_response_on_range_request && xhrStatus !== pendingRequest.expectedStatus) {
                    var _pendingRequest$onErr2;
                    (_pendingRequest$onErr2 = pendingRequest.onError) === null || _pendingRequest$onErr2 === void 0 ? void 0 : _pendingRequest$onErr2.call(pendingRequest, xhr.status);
                    return;
                  }
                  const chunk = getArrayBuffer(xhr);
                  if (xhrStatus === PARTIAL_CONTENT_RESPONSE) {
                    const rangeHeader = xhr.getResponseHeader("Content-Range");
                    const matches = /bytes (\d+)-(\d+)\/(\d+)/.exec(rangeHeader);
                    pendingRequest.onDone({
                      begin: parseInt(matches[1], 10),
                      chunk
                    });
                  } else if (chunk) {
                    pendingRequest.onDone({
                      begin: 0,
                      chunk
                    });
                  } else {
                    var _pendingRequest$onErr3;
                    (_pendingRequest$onErr3 = pendingRequest.onError) === null || _pendingRequest$onErr3 === void 0 ? void 0 : _pendingRequest$onErr3.call(pendingRequest, xhr.status);
                  }
                }
                getRequestXhr(xhrId) {
                  return this.pendingRequests[xhrId].xhr;
                }
                isPendingRequest(xhrId) {
                  return xhrId in this.pendingRequests;
                }
                abortRequest(xhrId) {
                  const xhr = this.pendingRequests[xhrId].xhr;
                  delete this.pendingRequests[xhrId];
                  xhr.abort();
                }
              }
              class PDFNetworkStream {
                constructor(source) {
                  this._source = source;
                  this._manager = new NetworkManager(source.url, {
                    httpHeaders: source.httpHeaders,
                    withCredentials: source.withCredentials
                  });
                  this._rangeChunkSize = source.rangeChunkSize;
                  this._fullRequestReader = null;
                  this._rangeRequestReaders = [];
                }
                _onRangeRequestReaderClosed(reader) {
                  const i = this._rangeRequestReaders.indexOf(reader);
                  if (i >= 0) {
                    this._rangeRequestReaders.splice(i, 1);
                  }
                }
                getFullReader() {
                  (0, _util2.assert)(!this._fullRequestReader, "PDFNetworkStream.getFullReader can only be called once.");
                  this._fullRequestReader = new PDFNetworkStreamFullRequestReader(this._manager, this._source);
                  return this._fullRequestReader;
                }
                getRangeReader(begin, end) {
                  const reader = new PDFNetworkStreamRangeRequestReader(this._manager, begin, end);
                  reader.onClosed = this._onRangeRequestReaderClosed.bind(this);
                  this._rangeRequestReaders.push(reader);
                  return reader;
                }
                cancelAllRequests(reason) {
                  var _this$_fullRequestRea;
                  (_this$_fullRequestRea = this._fullRequestReader) === null || _this$_fullRequestRea === void 0 ? void 0 : _this$_fullRequestRea.cancel(reason);
                  for (const reader of this._rangeRequestReaders.slice(0)) {
                    reader.cancel(reason);
                  }
                }
              }
              exports2.PDFNetworkStream = PDFNetworkStream;
              class PDFNetworkStreamFullRequestReader {
                constructor(manager, source) {
                  this._manager = manager;
                  const args = {
                    onHeadersReceived: this._onHeadersReceived.bind(this),
                    onDone: this._onDone.bind(this),
                    onError: this._onError.bind(this),
                    onProgress: this._onProgress.bind(this)
                  };
                  this._url = source.url;
                  this._fullRequestId = manager.requestFull(args);
                  this._headersReceivedCapability = (0, _util2.createPromiseCapability)();
                  this._disableRange = source.disableRange || false;
                  this._contentLength = source.length;
                  this._rangeChunkSize = source.rangeChunkSize;
                  if (!this._rangeChunkSize && !this._disableRange) {
                    this._disableRange = true;
                  }
                  this._isStreamingSupported = false;
                  this._isRangeSupported = false;
                  this._cachedChunks = [];
                  this._requests = [];
                  this._done = false;
                  this._storedError = void 0;
                  this._filename = null;
                  this.onProgress = null;
                }
                _onHeadersReceived() {
                  const fullRequestXhrId = this._fullRequestId;
                  const fullRequestXhr = this._manager.getRequestXhr(fullRequestXhrId);
                  const getResponseHeader = (name) => {
                    return fullRequestXhr.getResponseHeader(name);
                  };
                  const {
                    allowRangeRequests,
                    suggestedLength
                  } = (0, _network_utils.validateRangeRequestCapabilities)({
                    getResponseHeader,
                    isHttp: this._manager.isHttp,
                    rangeChunkSize: this._rangeChunkSize,
                    disableRange: this._disableRange
                  });
                  if (allowRangeRequests) {
                    this._isRangeSupported = true;
                  }
                  this._contentLength = suggestedLength || this._contentLength;
                  this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);
                  if (this._isRangeSupported) {
                    this._manager.abortRequest(fullRequestXhrId);
                  }
                  this._headersReceivedCapability.resolve();
                }
                _onDone(data) {
                  if (data) {
                    if (this._requests.length > 0) {
                      const requestCapability = this._requests.shift();
                      requestCapability.resolve({
                        value: data.chunk,
                        done: false
                      });
                    } else {
                      this._cachedChunks.push(data.chunk);
                    }
                  }
                  this._done = true;
                  if (this._cachedChunks.length > 0) {
                    return;
                  }
                  for (const requestCapability of this._requests) {
                    requestCapability.resolve({
                      value: void 0,
                      done: true
                    });
                  }
                  this._requests.length = 0;
                }
                _onError(status) {
                  this._storedError = (0, _network_utils.createResponseStatusError)(status, this._url);
                  this._headersReceivedCapability.reject(this._storedError);
                  for (const requestCapability of this._requests) {
                    requestCapability.reject(this._storedError);
                  }
                  this._requests.length = 0;
                  this._cachedChunks.length = 0;
                }
                _onProgress(evt) {
                  var _this$onProgress;
                  (_this$onProgress = this.onProgress) === null || _this$onProgress === void 0 ? void 0 : _this$onProgress.call(this, {
                    loaded: evt.loaded,
                    total: evt.lengthComputable ? evt.total : this._contentLength
                  });
                }
                get filename() {
                  return this._filename;
                }
                get isRangeSupported() {
                  return this._isRangeSupported;
                }
                get isStreamingSupported() {
                  return this._isStreamingSupported;
                }
                get contentLength() {
                  return this._contentLength;
                }
                get headersReady() {
                  return this._headersReceivedCapability.promise;
                }
                async read() {
                  if (this._storedError) {
                    throw this._storedError;
                  }
                  if (this._cachedChunks.length > 0) {
                    const chunk = this._cachedChunks.shift();
                    return {
                      value: chunk,
                      done: false
                    };
                  }
                  if (this._done) {
                    return {
                      value: void 0,
                      done: true
                    };
                  }
                  const requestCapability = (0, _util2.createPromiseCapability)();
                  this._requests.push(requestCapability);
                  return requestCapability.promise;
                }
                cancel(reason) {
                  this._done = true;
                  this._headersReceivedCapability.reject(reason);
                  for (const requestCapability of this._requests) {
                    requestCapability.resolve({
                      value: void 0,
                      done: true
                    });
                  }
                  this._requests.length = 0;
                  if (this._manager.isPendingRequest(this._fullRequestId)) {
                    this._manager.abortRequest(this._fullRequestId);
                  }
                  this._fullRequestReader = null;
                }
              }
              class PDFNetworkStreamRangeRequestReader {
                constructor(manager, begin, end) {
                  this._manager = manager;
                  const args = {
                    onDone: this._onDone.bind(this),
                    onError: this._onError.bind(this),
                    onProgress: this._onProgress.bind(this)
                  };
                  this._url = manager.url;
                  this._requestId = manager.requestRange(begin, end, args);
                  this._requests = [];
                  this._queuedChunk = null;
                  this._done = false;
                  this._storedError = void 0;
                  this.onProgress = null;
                  this.onClosed = null;
                }
                _close() {
                  var _this$onClosed;
                  (_this$onClosed = this.onClosed) === null || _this$onClosed === void 0 ? void 0 : _this$onClosed.call(this, this);
                }
                _onDone(data) {
                  const chunk = data.chunk;
                  if (this._requests.length > 0) {
                    const requestCapability = this._requests.shift();
                    requestCapability.resolve({
                      value: chunk,
                      done: false
                    });
                  } else {
                    this._queuedChunk = chunk;
                  }
                  this._done = true;
                  for (const requestCapability of this._requests) {
                    requestCapability.resolve({
                      value: void 0,
                      done: true
                    });
                  }
                  this._requests.length = 0;
                  this._close();
                }
                _onError(status) {
                  this._storedError = (0, _network_utils.createResponseStatusError)(status, this._url);
                  for (const requestCapability of this._requests) {
                    requestCapability.reject(this._storedError);
                  }
                  this._requests.length = 0;
                  this._queuedChunk = null;
                }
                _onProgress(evt) {
                  if (!this.isStreamingSupported) {
                    var _this$onProgress2;
                    (_this$onProgress2 = this.onProgress) === null || _this$onProgress2 === void 0 ? void 0 : _this$onProgress2.call(this, {
                      loaded: evt.loaded
                    });
                  }
                }
                get isStreamingSupported() {
                  return false;
                }
                async read() {
                  if (this._storedError) {
                    throw this._storedError;
                  }
                  if (this._queuedChunk !== null) {
                    const chunk = this._queuedChunk;
                    this._queuedChunk = null;
                    return {
                      value: chunk,
                      done: false
                    };
                  }
                  if (this._done) {
                    return {
                      value: void 0,
                      done: true
                    };
                  }
                  const requestCapability = (0, _util2.createPromiseCapability)();
                  this._requests.push(requestCapability);
                  return requestCapability.promise;
                }
                cancel(reason) {
                  this._done = true;
                  for (const requestCapability of this._requests) {
                    requestCapability.resolve({
                      value: void 0,
                      done: true
                    });
                  }
                  this._requests.length = 0;
                  if (this._manager.isPendingRequest(this._requestId)) {
                    this._manager.abortRequest(this._requestId);
                  }
                  this._close();
                }
              }
            },
            /* 161 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.PDFFetchStream = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              var _network_utils = __w_pdfjs_require__2(158);
              ;
              function createFetchOptions(headers, withCredentials, abortController) {
                return {
                  method: "GET",
                  headers,
                  signal: abortController.signal,
                  mode: "cors",
                  credentials: withCredentials ? "include" : "same-origin",
                  redirect: "follow"
                };
              }
              function createHeaders(httpHeaders) {
                const headers = new Headers();
                for (const property in httpHeaders) {
                  const value = httpHeaders[property];
                  if (typeof value === "undefined") {
                    continue;
                  }
                  headers.append(property, value);
                }
                return headers;
              }
              class PDFFetchStream {
                constructor(source) {
                  this.source = source;
                  this.isHttp = /^https?:/i.test(source.url);
                  this.httpHeaders = this.isHttp && source.httpHeaders || {};
                  this._fullRequestReader = null;
                  this._rangeRequestReaders = [];
                }
                get _progressiveDataLength() {
                  var _this$_fullRequestRea, _this$_fullRequestRea2;
                  return (_this$_fullRequestRea = (_this$_fullRequestRea2 = this._fullRequestReader) === null || _this$_fullRequestRea2 === void 0 ? void 0 : _this$_fullRequestRea2._loaded) !== null && _this$_fullRequestRea !== void 0 ? _this$_fullRequestRea : 0;
                }
                getFullReader() {
                  (0, _util2.assert)(!this._fullRequestReader, "PDFFetchStream.getFullReader can only be called once.");
                  this._fullRequestReader = new PDFFetchStreamReader(this);
                  return this._fullRequestReader;
                }
                getRangeReader(begin, end) {
                  if (end <= this._progressiveDataLength) {
                    return null;
                  }
                  const reader = new PDFFetchStreamRangeReader(this, begin, end);
                  this._rangeRequestReaders.push(reader);
                  return reader;
                }
                cancelAllRequests(reason) {
                  if (this._fullRequestReader) {
                    this._fullRequestReader.cancel(reason);
                  }
                  for (const reader of this._rangeRequestReaders.slice(0)) {
                    reader.cancel(reason);
                  }
                }
              }
              exports2.PDFFetchStream = PDFFetchStream;
              class PDFFetchStreamReader {
                constructor(stream) {
                  this._stream = stream;
                  this._reader = null;
                  this._loaded = 0;
                  this._filename = null;
                  const source = stream.source;
                  this._withCredentials = source.withCredentials || false;
                  this._contentLength = source.length;
                  this._headersCapability = (0, _util2.createPromiseCapability)();
                  this._disableRange = source.disableRange || false;
                  this._rangeChunkSize = source.rangeChunkSize;
                  if (!this._rangeChunkSize && !this._disableRange) {
                    this._disableRange = true;
                  }
                  this._abortController = new AbortController();
                  this._isStreamingSupported = !source.disableStream;
                  this._isRangeSupported = !source.disableRange;
                  this._headers = createHeaders(this._stream.httpHeaders);
                  const url = source.url;
                  fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then((response) => {
                    if (!(0, _network_utils.validateResponseStatus)(response.status)) {
                      throw (0, _network_utils.createResponseStatusError)(response.status, url);
                    }
                    this._reader = response.body.getReader();
                    this._headersCapability.resolve();
                    const getResponseHeader = (name) => {
                      return response.headers.get(name);
                    };
                    const {
                      allowRangeRequests,
                      suggestedLength
                    } = (0, _network_utils.validateRangeRequestCapabilities)({
                      getResponseHeader,
                      isHttp: this._stream.isHttp,
                      rangeChunkSize: this._rangeChunkSize,
                      disableRange: this._disableRange
                    });
                    this._isRangeSupported = allowRangeRequests;
                    this._contentLength = suggestedLength || this._contentLength;
                    this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);
                    if (!this._isStreamingSupported && this._isRangeSupported) {
                      this.cancel(new _util2.AbortException("Streaming is disabled."));
                    }
                  }).catch(this._headersCapability.reject);
                  this.onProgress = null;
                }
                get headersReady() {
                  return this._headersCapability.promise;
                }
                get filename() {
                  return this._filename;
                }
                get contentLength() {
                  return this._contentLength;
                }
                get isRangeSupported() {
                  return this._isRangeSupported;
                }
                get isStreamingSupported() {
                  return this._isStreamingSupported;
                }
                async read() {
                  await this._headersCapability.promise;
                  const {
                    value,
                    done
                  } = await this._reader.read();
                  if (done) {
                    return {
                      value,
                      done
                    };
                  }
                  this._loaded += value.byteLength;
                  if (this.onProgress) {
                    this.onProgress({
                      loaded: this._loaded,
                      total: this._contentLength
                    });
                  }
                  const buffer = new Uint8Array(value).buffer;
                  return {
                    value: buffer,
                    done: false
                  };
                }
                cancel(reason) {
                  if (this._reader) {
                    this._reader.cancel(reason);
                  }
                  this._abortController.abort();
                }
              }
              class PDFFetchStreamRangeReader {
                constructor(stream, begin, end) {
                  this._stream = stream;
                  this._reader = null;
                  this._loaded = 0;
                  const source = stream.source;
                  this._withCredentials = source.withCredentials || false;
                  this._readCapability = (0, _util2.createPromiseCapability)();
                  this._isStreamingSupported = !source.disableStream;
                  this._abortController = new AbortController();
                  this._headers = createHeaders(this._stream.httpHeaders);
                  this._headers.append("Range", `bytes=${begin}-${end - 1}`);
                  const url = source.url;
                  fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then((response) => {
                    if (!(0, _network_utils.validateResponseStatus)(response.status)) {
                      throw (0, _network_utils.createResponseStatusError)(response.status, url);
                    }
                    this._readCapability.resolve();
                    this._reader = response.body.getReader();
                  }).catch(this._readCapability.reject);
                  this.onProgress = null;
                }
                get isStreamingSupported() {
                  return this._isStreamingSupported;
                }
                async read() {
                  await this._readCapability.promise;
                  const {
                    value,
                    done
                  } = await this._reader.read();
                  if (done) {
                    return {
                      value,
                      done
                    };
                  }
                  this._loaded += value.byteLength;
                  if (this.onProgress) {
                    this.onProgress({
                      loaded: this._loaded
                    });
                  }
                  const buffer = new Uint8Array(value).buffer;
                  return {
                    value: buffer,
                    done: false
                  };
                }
                cancel(reason) {
                  if (this._reader) {
                    this._reader.cancel(reason);
                  }
                  this._abortController.abort();
                }
              }
            }
            /******/
          ];
          var __webpack_module_cache__ = {};
          function __w_pdfjs_require__(moduleId) {
            var cachedModule = __webpack_module_cache__[moduleId];
            if (cachedModule !== void 0) {
              return cachedModule.exports;
            }
            var module2 = __webpack_module_cache__[moduleId] = {
              /******/
              // no module.id needed
              /******/
              // no module.loaded needed
              /******/
              exports: {}
              /******/
            };
            __webpack_modules__[moduleId](module2, module2.exports, __w_pdfjs_require__);
            return module2.exports;
          }
          var __webpack_exports__ = {};
          (() => {
            "use strict";
            var exports2 = __webpack_exports__;
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            Object.defineProperty(exports2, "AnnotationEditorLayer", {
              enumerable: true,
              get: function() {
                return _annotation_editor_layer.AnnotationEditorLayer;
              }
            });
            Object.defineProperty(exports2, "AnnotationEditorParamsType", {
              enumerable: true,
              get: function() {
                return _util2.AnnotationEditorParamsType;
              }
            });
            Object.defineProperty(exports2, "AnnotationEditorType", {
              enumerable: true,
              get: function() {
                return _util2.AnnotationEditorType;
              }
            });
            Object.defineProperty(exports2, "AnnotationEditorUIManager", {
              enumerable: true,
              get: function() {
                return _tools.AnnotationEditorUIManager;
              }
            });
            Object.defineProperty(exports2, "AnnotationLayer", {
              enumerable: true,
              get: function() {
                return _annotation_layer.AnnotationLayer;
              }
            });
            Object.defineProperty(exports2, "AnnotationMode", {
              enumerable: true,
              get: function() {
                return _util2.AnnotationMode;
              }
            });
            Object.defineProperty(exports2, "CMapCompressionType", {
              enumerable: true,
              get: function() {
                return _util2.CMapCompressionType;
              }
            });
            Object.defineProperty(exports2, "GlobalWorkerOptions", {
              enumerable: true,
              get: function() {
                return _worker_options2.GlobalWorkerOptions;
              }
            });
            Object.defineProperty(exports2, "InvalidPDFException", {
              enumerable: true,
              get: function() {
                return _util2.InvalidPDFException;
              }
            });
            Object.defineProperty(exports2, "LoopbackPort", {
              enumerable: true,
              get: function() {
                return _api.LoopbackPort;
              }
            });
            Object.defineProperty(exports2, "MissingPDFException", {
              enumerable: true,
              get: function() {
                return _util2.MissingPDFException;
              }
            });
            Object.defineProperty(exports2, "OPS", {
              enumerable: true,
              get: function() {
                return _util2.OPS;
              }
            });
            Object.defineProperty(exports2, "PDFDataRangeTransport", {
              enumerable: true,
              get: function() {
                return _api.PDFDataRangeTransport;
              }
            });
            Object.defineProperty(exports2, "PDFDateString", {
              enumerable: true,
              get: function() {
                return _display_utils2.PDFDateString;
              }
            });
            Object.defineProperty(exports2, "PDFWorker", {
              enumerable: true,
              get: function() {
                return _api.PDFWorker;
              }
            });
            Object.defineProperty(exports2, "PasswordResponses", {
              enumerable: true,
              get: function() {
                return _util2.PasswordResponses;
              }
            });
            Object.defineProperty(exports2, "PermissionFlag", {
              enumerable: true,
              get: function() {
                return _util2.PermissionFlag;
              }
            });
            Object.defineProperty(exports2, "PixelsPerInch", {
              enumerable: true,
              get: function() {
                return _display_utils2.PixelsPerInch;
              }
            });
            Object.defineProperty(exports2, "RenderingCancelledException", {
              enumerable: true,
              get: function() {
                return _display_utils2.RenderingCancelledException;
              }
            });
            Object.defineProperty(exports2, "SVGGraphics", {
              enumerable: true,
              get: function() {
                return _svg.SVGGraphics;
              }
            });
            Object.defineProperty(exports2, "UNSUPPORTED_FEATURES", {
              enumerable: true,
              get: function() {
                return _util2.UNSUPPORTED_FEATURES;
              }
            });
            Object.defineProperty(exports2, "UnexpectedResponseException", {
              enumerable: true,
              get: function() {
                return _util2.UnexpectedResponseException;
              }
            });
            Object.defineProperty(exports2, "Util", {
              enumerable: true,
              get: function() {
                return _util2.Util;
              }
            });
            Object.defineProperty(exports2, "VerbosityLevel", {
              enumerable: true,
              get: function() {
                return _util2.VerbosityLevel;
              }
            });
            Object.defineProperty(exports2, "XfaLayer", {
              enumerable: true,
              get: function() {
                return _xfa_layer.XfaLayer;
              }
            });
            Object.defineProperty(exports2, "build", {
              enumerable: true,
              get: function() {
                return _api.build;
              }
            });
            Object.defineProperty(exports2, "createPromiseCapability", {
              enumerable: true,
              get: function() {
                return _util2.createPromiseCapability;
              }
            });
            Object.defineProperty(exports2, "createValidAbsoluteUrl", {
              enumerable: true,
              get: function() {
                return _util2.createValidAbsoluteUrl;
              }
            });
            Object.defineProperty(exports2, "getDocument", {
              enumerable: true,
              get: function() {
                return _api.getDocument;
              }
            });
            Object.defineProperty(exports2, "getFilenameFromUrl", {
              enumerable: true,
              get: function() {
                return _display_utils2.getFilenameFromUrl;
              }
            });
            Object.defineProperty(exports2, "getPdfFilenameFromUrl", {
              enumerable: true,
              get: function() {
                return _display_utils2.getPdfFilenameFromUrl;
              }
            });
            Object.defineProperty(exports2, "getXfaPageViewport", {
              enumerable: true,
              get: function() {
                return _display_utils2.getXfaPageViewport;
              }
            });
            Object.defineProperty(exports2, "isPdfFile", {
              enumerable: true,
              get: function() {
                return _display_utils2.isPdfFile;
              }
            });
            Object.defineProperty(exports2, "loadScript", {
              enumerable: true,
              get: function() {
                return _display_utils2.loadScript;
              }
            });
            Object.defineProperty(exports2, "renderTextLayer", {
              enumerable: true,
              get: function() {
                return _text_layer.renderTextLayer;
              }
            });
            Object.defineProperty(exports2, "shadow", {
              enumerable: true,
              get: function() {
                return _util2.shadow;
              }
            });
            Object.defineProperty(exports2, "version", {
              enumerable: true,
              get: function() {
                return _api.version;
              }
            });
            var _util2 = __w_pdfjs_require__(1);
            var _api = __w_pdfjs_require__(129);
            var _display_utils2 = __w_pdfjs_require__(133);
            var _annotation_editor_layer = __w_pdfjs_require__(147);
            var _tools = __w_pdfjs_require__(132);
            var _annotation_layer = __w_pdfjs_require__(152);
            var _worker_options2 = __w_pdfjs_require__(140);
            var _is_node2 = __w_pdfjs_require__(3);
            var _text_layer = __w_pdfjs_require__(155);
            var _svg = __w_pdfjs_require__(156);
            var _xfa_layer = __w_pdfjs_require__(154);
            const pdfjsVersion = "2.16.105";
            const pdfjsBuild = "172ccdbe5";
            {
              if (_is_node2.isNodeJS) {
                const {
                  PDFNodeStream
                } = __w_pdfjs_require__(157);
                (0, _api.setPDFNetworkStreamFactory)((params) => {
                  return new PDFNodeStream(params);
                });
              } else {
                const {
                  PDFNetworkStream
                } = __w_pdfjs_require__(160);
                const {
                  PDFFetchStream
                } = __w_pdfjs_require__(161);
                (0, _api.setPDFNetworkStreamFactory)((params) => {
                  if ((0, _display_utils2.isValidFetchUrl)(params.url)) {
                    return new PDFFetchStream(params);
                  }
                  return new PDFNetworkStream(params);
                });
              }
            }
          })();
          return __webpack_exports__;
        })()
      );
    });
  }
});

// node_modules/react-pdf-highlighter/node_modules/pdfjs-dist/legacy/web/pdf_viewer.js
var require_pdf_viewer = __commonJS({
  "node_modules/react-pdf-highlighter/node_modules/pdfjs-dist/legacy/web/pdf_viewer.js"(exports2, module2) {
    (function webpackUniversalModuleDefinition(root, factory) {
      if (typeof exports2 === "object" && typeof module2 === "object")
        module2.exports = factory();
      else if (typeof define === "function" && define.amd)
        define("pdfjs-dist/web/pdf_viewer", [], factory);
      else if (typeof exports2 === "object")
        exports2["pdfjs-dist/web/pdf_viewer"] = factory();
      else
        root["pdfjs-dist/web/pdf_viewer"] = root.pdfjsViewer = factory();
    })(globalThis, () => {
      return (
        /******/
        (() => {
          "use strict";
          var __webpack_modules__2 = [
            ,
            /* 1 */
            /***/
            (__unused_webpack_module2, exports3, __w_pdfjs_require__3) => {
              Object.defineProperty(exports3, "__esModule", {
                value: true
              });
              exports3.DefaultXfaLayerFactory = exports3.DefaultTextLayerFactory = exports3.DefaultStructTreeLayerFactory = exports3.DefaultAnnotationLayerFactory = exports3.DefaultAnnotationEditorLayerFactory = void 0;
              var _annotation_editor_layer_builder = __w_pdfjs_require__3(2);
              var _annotation_layer_builder = __w_pdfjs_require__3(5);
              var _l10n_utils = __w_pdfjs_require__3(4);
              var _pdf_link_service = __w_pdfjs_require__3(6);
              var _struct_tree_layer_builder = __w_pdfjs_require__3(8);
              var _text_layer_builder = __w_pdfjs_require__3(9);
              var _xfa_layer_builder = __w_pdfjs_require__3(10);
              class DefaultAnnotationLayerFactory {
                createAnnotationLayerBuilder(_ref) {
                  let {
                    pageDiv,
                    pdfPage,
                    annotationStorage = null,
                    imageResourcesPath = "",
                    renderForms = true,
                    l10n = _l10n_utils.NullL10n,
                    enableScripting = false,
                    hasJSActionsPromise = null,
                    mouseState = null,
                    fieldObjectsPromise = null,
                    annotationCanvasMap = null,
                    accessibilityManager = null
                  } = _ref;
                  return new _annotation_layer_builder.AnnotationLayerBuilder({
                    pageDiv,
                    pdfPage,
                    imageResourcesPath,
                    renderForms,
                    linkService: new _pdf_link_service.SimpleLinkService(),
                    l10n,
                    annotationStorage,
                    enableScripting,
                    hasJSActionsPromise,
                    fieldObjectsPromise,
                    mouseState,
                    annotationCanvasMap,
                    accessibilityManager
                  });
                }
              }
              exports3.DefaultAnnotationLayerFactory = DefaultAnnotationLayerFactory;
              class DefaultAnnotationEditorLayerFactory {
                createAnnotationEditorLayerBuilder(_ref2) {
                  let {
                    uiManager = null,
                    pageDiv,
                    pdfPage,
                    accessibilityManager = null,
                    l10n,
                    annotationStorage = null
                  } = _ref2;
                  return new _annotation_editor_layer_builder.AnnotationEditorLayerBuilder({
                    uiManager,
                    pageDiv,
                    pdfPage,
                    accessibilityManager,
                    l10n,
                    annotationStorage
                  });
                }
              }
              exports3.DefaultAnnotationEditorLayerFactory = DefaultAnnotationEditorLayerFactory;
              class DefaultStructTreeLayerFactory {
                createStructTreeLayerBuilder(_ref3) {
                  let {
                    pdfPage
                  } = _ref3;
                  return new _struct_tree_layer_builder.StructTreeLayerBuilder({
                    pdfPage
                  });
                }
              }
              exports3.DefaultStructTreeLayerFactory = DefaultStructTreeLayerFactory;
              class DefaultTextLayerFactory {
                createTextLayerBuilder(_ref4) {
                  let {
                    textLayerDiv,
                    pageIndex,
                    viewport,
                    enhanceTextSelection = false,
                    eventBus,
                    highlighter,
                    accessibilityManager = null
                  } = _ref4;
                  return new _text_layer_builder.TextLayerBuilder({
                    textLayerDiv,
                    pageIndex,
                    viewport,
                    enhanceTextSelection,
                    eventBus,
                    highlighter,
                    accessibilityManager
                  });
                }
              }
              exports3.DefaultTextLayerFactory = DefaultTextLayerFactory;
              class DefaultXfaLayerFactory {
                createXfaLayerBuilder(_ref5) {
                  let {
                    pageDiv,
                    pdfPage,
                    annotationStorage = null
                  } = _ref5;
                  return new _xfa_layer_builder.XfaLayerBuilder({
                    pageDiv,
                    pdfPage,
                    annotationStorage,
                    linkService: new _pdf_link_service.SimpleLinkService()
                  });
                }
              }
              exports3.DefaultXfaLayerFactory = DefaultXfaLayerFactory;
            },
            /* 2 */
            /***/
            (__unused_webpack_module2, exports3, __w_pdfjs_require__3) => {
              Object.defineProperty(exports3, "__esModule", {
                value: true
              });
              exports3.AnnotationEditorLayerBuilder = void 0;
              var _pdfjsLib = __w_pdfjs_require__3(3);
              var _l10n_utils = __w_pdfjs_require__3(4);
              function _classPrivateFieldInitSpec2(obj, privateMap, value) {
                _checkPrivateRedeclaration2(obj, privateMap);
                privateMap.set(obj, value);
              }
              function _checkPrivateRedeclaration2(obj, privateCollection) {
                if (privateCollection.has(obj)) {
                  throw new TypeError("Cannot initialize the same private elements twice on an object");
                }
              }
              function _classPrivateFieldGet2(receiver, privateMap) {
                var descriptor = _classExtractFieldDescriptor2(receiver, privateMap, "get");
                return _classApplyDescriptorGet2(receiver, descriptor);
              }
              function _classApplyDescriptorGet2(receiver, descriptor) {
                if (descriptor.get) {
                  return descriptor.get.call(receiver);
                }
                return descriptor.value;
              }
              function _classPrivateFieldSet2(receiver, privateMap, value) {
                var descriptor = _classExtractFieldDescriptor2(receiver, privateMap, "set");
                _classApplyDescriptorSet2(receiver, descriptor, value);
                return value;
              }
              function _classExtractFieldDescriptor2(receiver, privateMap, action) {
                if (!privateMap.has(receiver)) {
                  throw new TypeError("attempted to " + action + " private field on non-instance");
                }
                return privateMap.get(receiver);
              }
              function _classApplyDescriptorSet2(receiver, descriptor, value) {
                if (descriptor.set) {
                  descriptor.set.call(receiver, value);
                } else {
                  if (!descriptor.writable) {
                    throw new TypeError("attempted to set read only private field");
                  }
                  descriptor.value = value;
                }
              }
              var _uiManager = /* @__PURE__ */ new WeakMap();
              class AnnotationEditorLayerBuilder {
                constructor(options) {
                  _classPrivateFieldInitSpec2(this, _uiManager, {
                    writable: true,
                    value: void 0
                  });
                  this.pageDiv = options.pageDiv;
                  this.pdfPage = options.pdfPage;
                  this.annotationStorage = options.annotationStorage || null;
                  this.accessibilityManager = options.accessibilityManager;
                  this.l10n = options.l10n || _l10n_utils.NullL10n;
                  this.annotationEditorLayer = null;
                  this.div = null;
                  this._cancelled = false;
                  _classPrivateFieldSet2(this, _uiManager, options.uiManager);
                }
                async render(viewport) {
                  let intent = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "display";
                  if (intent !== "display") {
                    return;
                  }
                  if (this._cancelled) {
                    return;
                  }
                  const clonedViewport = viewport.clone({
                    dontFlip: true
                  });
                  if (this.div) {
                    this.annotationEditorLayer.update({
                      viewport: clonedViewport
                    });
                    this.show();
                    return;
                  }
                  this.div = document.createElement("div");
                  this.div.className = "annotationEditorLayer";
                  this.div.tabIndex = 0;
                  this.pageDiv.append(this.div);
                  this.annotationEditorLayer = new _pdfjsLib.AnnotationEditorLayer({
                    uiManager: _classPrivateFieldGet2(this, _uiManager),
                    div: this.div,
                    annotationStorage: this.annotationStorage,
                    accessibilityManager: this.accessibilityManager,
                    pageIndex: this.pdfPage._pageIndex,
                    l10n: this.l10n,
                    viewport: clonedViewport
                  });
                  const parameters = {
                    viewport: clonedViewport,
                    div: this.div,
                    annotations: null,
                    intent
                  };
                  this.annotationEditorLayer.render(parameters);
                }
                cancel() {
                  this._cancelled = true;
                  this.destroy();
                }
                hide() {
                  if (!this.div) {
                    return;
                  }
                  this.div.hidden = true;
                }
                show() {
                  if (!this.div) {
                    return;
                  }
                  this.div.hidden = false;
                }
                destroy() {
                  if (!this.div) {
                    return;
                  }
                  this.pageDiv = null;
                  this.annotationEditorLayer.destroy();
                  this.div.remove();
                }
              }
              exports3.AnnotationEditorLayerBuilder = AnnotationEditorLayerBuilder;
            },
            /* 3 */
            /***/
            (module3) => {
              let pdfjsLib;
              if (typeof window !== "undefined" && window["pdfjs-dist/build/pdf"]) {
                pdfjsLib = window["pdfjs-dist/build/pdf"];
              } else {
                pdfjsLib = require_pdf();
              }
              module3.exports = pdfjsLib;
            },
            /* 4 */
            /***/
            (__unused_webpack_module2, exports3) => {
              Object.defineProperty(exports3, "__esModule", {
                value: true
              });
              exports3.NullL10n = void 0;
              exports3.fixupLangCode = fixupLangCode;
              exports3.getL10nFallback = getL10nFallback;
              const DEFAULT_L10N_STRINGS = {
                of_pages: "of {{pagesCount}}",
                page_of_pages: "({{pageNumber}} of {{pagesCount}})",
                document_properties_kb: "{{size_kb}} KB ({{size_b}} bytes)",
                document_properties_mb: "{{size_mb}} MB ({{size_b}} bytes)",
                document_properties_date_string: "{{date}}, {{time}}",
                document_properties_page_size_unit_inches: "in",
                document_properties_page_size_unit_millimeters: "mm",
                document_properties_page_size_orientation_portrait: "portrait",
                document_properties_page_size_orientation_landscape: "landscape",
                document_properties_page_size_name_a3: "A3",
                document_properties_page_size_name_a4: "A4",
                document_properties_page_size_name_letter: "Letter",
                document_properties_page_size_name_legal: "Legal",
                document_properties_page_size_dimension_string: "{{width}} × {{height}} {{unit}} ({{orientation}})",
                document_properties_page_size_dimension_name_string: "{{width}} × {{height}} {{unit}} ({{name}}, {{orientation}})",
                document_properties_linearized_yes: "Yes",
                document_properties_linearized_no: "No",
                print_progress_percent: "{{progress}}%",
                "toggle_sidebar.title": "Toggle Sidebar",
                "toggle_sidebar_notification2.title": "Toggle Sidebar (document contains outline/attachments/layers)",
                additional_layers: "Additional Layers",
                page_landmark: "Page {{page}}",
                thumb_page_title: "Page {{page}}",
                thumb_page_canvas: "Thumbnail of Page {{page}}",
                find_reached_top: "Reached top of document, continued from bottom",
                find_reached_bottom: "Reached end of document, continued from top",
                "find_match_count[one]": "{{current}} of {{total}} match",
                "find_match_count[other]": "{{current}} of {{total}} matches",
                "find_match_count_limit[one]": "More than {{limit}} match",
                "find_match_count_limit[other]": "More than {{limit}} matches",
                find_not_found: "Phrase not found",
                error_version_info: "PDF.js v{{version}} (build: {{build}})",
                error_message: "Message: {{message}}",
                error_stack: "Stack: {{stack}}",
                error_file: "File: {{file}}",
                error_line: "Line: {{line}}",
                rendering_error: "An error occurred while rendering the page.",
                page_scale_width: "Page Width",
                page_scale_fit: "Page Fit",
                page_scale_auto: "Automatic Zoom",
                page_scale_actual: "Actual Size",
                page_scale_percent: "{{scale}}%",
                loading: "Loading…",
                loading_error: "An error occurred while loading the PDF.",
                invalid_file_error: "Invalid or corrupted PDF file.",
                missing_file_error: "Missing PDF file.",
                unexpected_response_error: "Unexpected server response.",
                printing_not_supported: "Warning: Printing is not fully supported by this browser.",
                printing_not_ready: "Warning: The PDF is not fully loaded for printing.",
                web_fonts_disabled: "Web fonts are disabled: unable to use embedded PDF fonts.",
                free_text_default_content: "Enter text…",
                editor_free_text_aria_label: "FreeText Editor",
                editor_ink_aria_label: "Ink Editor",
                editor_ink_canvas_aria_label: "User-created image"
              };
              function getL10nFallback(key, args) {
                switch (key) {
                  case "find_match_count":
                    key = `find_match_count[${args.total === 1 ? "one" : "other"}]`;
                    break;
                  case "find_match_count_limit":
                    key = `find_match_count_limit[${args.limit === 1 ? "one" : "other"}]`;
                    break;
                }
                return DEFAULT_L10N_STRINGS[key] || "";
              }
              const PARTIAL_LANG_CODES = {
                en: "en-US",
                es: "es-ES",
                fy: "fy-NL",
                ga: "ga-IE",
                gu: "gu-IN",
                hi: "hi-IN",
                hy: "hy-AM",
                nb: "nb-NO",
                ne: "ne-NP",
                nn: "nn-NO",
                pa: "pa-IN",
                pt: "pt-PT",
                sv: "sv-SE",
                zh: "zh-CN"
              };
              function fixupLangCode(langCode) {
                return PARTIAL_LANG_CODES[langCode === null || langCode === void 0 ? void 0 : langCode.toLowerCase()] || langCode;
              }
              function formatL10nValue(text, args) {
                if (!args) {
                  return text;
                }
                return text.replace(/\{\{\s*(\w+)\s*\}\}/g, (all, name) => {
                  return name in args ? args[name] : "{{" + name + "}}";
                });
              }
              const NullL10n2 = {
                async getLanguage() {
                  return "en-us";
                },
                async getDirection() {
                  return "ltr";
                },
                async get(key) {
                  let args = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
                  let fallback = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : getL10nFallback(key, args);
                  return formatL10nValue(fallback, args);
                },
                async translate(element) {
                }
              };
              exports3.NullL10n = NullL10n2;
            },
            /* 5 */
            /***/
            (__unused_webpack_module2, exports3, __w_pdfjs_require__3) => {
              Object.defineProperty(exports3, "__esModule", {
                value: true
              });
              exports3.AnnotationLayerBuilder = void 0;
              var _pdfjsLib = __w_pdfjs_require__3(3);
              var _l10n_utils = __w_pdfjs_require__3(4);
              class AnnotationLayerBuilder {
                constructor(_ref) {
                  let {
                    pageDiv,
                    pdfPage,
                    linkService,
                    downloadManager,
                    annotationStorage = null,
                    imageResourcesPath = "",
                    renderForms = true,
                    l10n = _l10n_utils.NullL10n,
                    enableScripting = false,
                    hasJSActionsPromise = null,
                    fieldObjectsPromise = null,
                    mouseState = null,
                    annotationCanvasMap = null,
                    accessibilityManager = null
                  } = _ref;
                  this.pageDiv = pageDiv;
                  this.pdfPage = pdfPage;
                  this.linkService = linkService;
                  this.downloadManager = downloadManager;
                  this.imageResourcesPath = imageResourcesPath;
                  this.renderForms = renderForms;
                  this.l10n = l10n;
                  this.annotationStorage = annotationStorage;
                  this.enableScripting = enableScripting;
                  this._hasJSActionsPromise = hasJSActionsPromise;
                  this._fieldObjectsPromise = fieldObjectsPromise;
                  this._mouseState = mouseState;
                  this._annotationCanvasMap = annotationCanvasMap;
                  this._accessibilityManager = accessibilityManager;
                  this.div = null;
                  this._cancelled = false;
                }
                async render(viewport) {
                  let intent = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "display";
                  const [annotations, hasJSActions = false, fieldObjects = null] = await Promise.all([this.pdfPage.getAnnotations({
                    intent
                  }), this._hasJSActionsPromise, this._fieldObjectsPromise]);
                  if (this._cancelled || annotations.length === 0) {
                    return;
                  }
                  const parameters = {
                    viewport: viewport.clone({
                      dontFlip: true
                    }),
                    div: this.div,
                    annotations,
                    page: this.pdfPage,
                    imageResourcesPath: this.imageResourcesPath,
                    renderForms: this.renderForms,
                    linkService: this.linkService,
                    downloadManager: this.downloadManager,
                    annotationStorage: this.annotationStorage,
                    enableScripting: this.enableScripting,
                    hasJSActions,
                    fieldObjects,
                    mouseState: this._mouseState,
                    annotationCanvasMap: this._annotationCanvasMap,
                    accessibilityManager: this._accessibilityManager
                  };
                  if (this.div) {
                    _pdfjsLib.AnnotationLayer.update(parameters);
                  } else {
                    this.div = document.createElement("div");
                    this.div.className = "annotationLayer";
                    this.pageDiv.append(this.div);
                    parameters.div = this.div;
                    _pdfjsLib.AnnotationLayer.render(parameters);
                    this.l10n.translate(this.div);
                  }
                }
                cancel() {
                  this._cancelled = true;
                }
                hide() {
                  if (!this.div) {
                    return;
                  }
                  this.div.hidden = true;
                }
              }
              exports3.AnnotationLayerBuilder = AnnotationLayerBuilder;
            },
            /* 6 */
            /***/
            (__unused_webpack_module2, exports3, __w_pdfjs_require__3) => {
              Object.defineProperty(exports3, "__esModule", {
                value: true
              });
              exports3.SimpleLinkService = exports3.PDFLinkService = exports3.LinkTarget = void 0;
              var _ui_utils = __w_pdfjs_require__3(7);
              function _classPrivateMethodInitSpec2(obj, privateSet) {
                _checkPrivateRedeclaration2(obj, privateSet);
                privateSet.add(obj);
              }
              function _classPrivateFieldInitSpec2(obj, privateMap, value) {
                _checkPrivateRedeclaration2(obj, privateMap);
                privateMap.set(obj, value);
              }
              function _checkPrivateRedeclaration2(obj, privateCollection) {
                if (privateCollection.has(obj)) {
                  throw new TypeError("Cannot initialize the same private elements twice on an object");
                }
              }
              function _classStaticPrivateMethodGet(receiver, classConstructor, method) {
                _classCheckPrivateStaticAccess2(receiver, classConstructor);
                return method;
              }
              function _classCheckPrivateStaticAccess2(receiver, classConstructor) {
                if (receiver !== classConstructor) {
                  throw new TypeError("Private static access of wrong provenance");
                }
              }
              function _classPrivateMethodGet2(receiver, privateSet, fn) {
                if (!privateSet.has(receiver)) {
                  throw new TypeError("attempted to get private field on non-instance");
                }
                return fn;
              }
              function _classPrivateFieldGet2(receiver, privateMap) {
                var descriptor = _classExtractFieldDescriptor2(receiver, privateMap, "get");
                return _classApplyDescriptorGet2(receiver, descriptor);
              }
              function _classExtractFieldDescriptor2(receiver, privateMap, action) {
                if (!privateMap.has(receiver)) {
                  throw new TypeError("attempted to " + action + " private field on non-instance");
                }
                return privateMap.get(receiver);
              }
              function _classApplyDescriptorGet2(receiver, descriptor) {
                if (descriptor.get) {
                  return descriptor.get.call(receiver);
                }
                return descriptor.value;
              }
              const DEFAULT_LINK_REL = "noopener noreferrer nofollow";
              const LinkTarget = {
                NONE: 0,
                SELF: 1,
                BLANK: 2,
                PARENT: 3,
                TOP: 4
              };
              exports3.LinkTarget = LinkTarget;
              function addLinkAttributes(link) {
                let {
                  url,
                  target,
                  rel,
                  enabled = true
                } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                if (!url || typeof url !== "string") {
                  throw new Error('A valid "url" parameter must provided.');
                }
                const urlNullRemoved = (0, _ui_utils.removeNullCharacters)(url);
                if (enabled) {
                  link.href = link.title = urlNullRemoved;
                } else {
                  link.href = "";
                  link.title = `Disabled: ${urlNullRemoved}`;
                  link.onclick = () => {
                    return false;
                  };
                }
                let targetStr = "";
                switch (target) {
                  case LinkTarget.NONE:
                    break;
                  case LinkTarget.SELF:
                    targetStr = "_self";
                    break;
                  case LinkTarget.BLANK:
                    targetStr = "_blank";
                    break;
                  case LinkTarget.PARENT:
                    targetStr = "_parent";
                    break;
                  case LinkTarget.TOP:
                    targetStr = "_top";
                    break;
                }
                link.target = targetStr;
                link.rel = typeof rel === "string" ? rel : DEFAULT_LINK_REL;
              }
              var _pagesRefCache = /* @__PURE__ */ new WeakMap();
              var _goToDestinationHelper = /* @__PURE__ */ new WeakSet();
              class PDFLinkService2 {
                constructor() {
                  let {
                    eventBus,
                    externalLinkTarget = null,
                    externalLinkRel = null,
                    ignoreDestinationZoom = false
                  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                  _classPrivateMethodInitSpec2(this, _goToDestinationHelper);
                  _classPrivateFieldInitSpec2(this, _pagesRefCache, {
                    writable: true,
                    value: /* @__PURE__ */ new Map()
                  });
                  this.eventBus = eventBus;
                  this.externalLinkTarget = externalLinkTarget;
                  this.externalLinkRel = externalLinkRel;
                  this.externalLinkEnabled = true;
                  this._ignoreDestinationZoom = ignoreDestinationZoom;
                  this.baseUrl = null;
                  this.pdfDocument = null;
                  this.pdfViewer = null;
                  this.pdfHistory = null;
                }
                setDocument(pdfDocument) {
                  let baseUrl = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
                  this.baseUrl = baseUrl;
                  this.pdfDocument = pdfDocument;
                  _classPrivateFieldGet2(this, _pagesRefCache).clear();
                }
                setViewer(pdfViewer) {
                  this.pdfViewer = pdfViewer;
                }
                setHistory(pdfHistory) {
                  this.pdfHistory = pdfHistory;
                }
                get pagesCount() {
                  return this.pdfDocument ? this.pdfDocument.numPages : 0;
                }
                get page() {
                  return this.pdfViewer.currentPageNumber;
                }
                set page(value) {
                  this.pdfViewer.currentPageNumber = value;
                }
                get rotation() {
                  return this.pdfViewer.pagesRotation;
                }
                set rotation(value) {
                  this.pdfViewer.pagesRotation = value;
                }
                async goToDestination(dest) {
                  if (!this.pdfDocument) {
                    return;
                  }
                  let namedDest, explicitDest;
                  if (typeof dest === "string") {
                    namedDest = dest;
                    explicitDest = await this.pdfDocument.getDestination(dest);
                  } else {
                    namedDest = null;
                    explicitDest = await dest;
                  }
                  if (!Array.isArray(explicitDest)) {
                    console.error(`PDFLinkService.goToDestination: "${explicitDest}" is not a valid destination array, for dest="${dest}".`);
                    return;
                  }
                  _classPrivateMethodGet2(this, _goToDestinationHelper, _goToDestinationHelper2).call(this, dest, namedDest, explicitDest);
                }
                goToPage(val) {
                  if (!this.pdfDocument) {
                    return;
                  }
                  const pageNumber = typeof val === "string" && this.pdfViewer.pageLabelToPageNumber(val) || val | 0;
                  if (!(Number.isInteger(pageNumber) && pageNumber > 0 && pageNumber <= this.pagesCount)) {
                    console.error(`PDFLinkService.goToPage: "${val}" is not a valid page.`);
                    return;
                  }
                  if (this.pdfHistory) {
                    this.pdfHistory.pushCurrentPosition();
                    this.pdfHistory.pushPage(pageNumber);
                  }
                  this.pdfViewer.scrollPageIntoView({
                    pageNumber
                  });
                }
                addLinkAttributes(link, url) {
                  let newWindow = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                  addLinkAttributes(link, {
                    url,
                    target: newWindow ? LinkTarget.BLANK : this.externalLinkTarget,
                    rel: this.externalLinkRel,
                    enabled: this.externalLinkEnabled
                  });
                }
                getDestinationHash(dest) {
                  if (typeof dest === "string") {
                    if (dest.length > 0) {
                      return this.getAnchorUrl("#" + escape(dest));
                    }
                  } else if (Array.isArray(dest)) {
                    const str = JSON.stringify(dest);
                    if (str.length > 0) {
                      return this.getAnchorUrl("#" + escape(str));
                    }
                  }
                  return this.getAnchorUrl("");
                }
                getAnchorUrl(anchor) {
                  return (this.baseUrl || "") + anchor;
                }
                setHash(hash) {
                  if (!this.pdfDocument) {
                    return;
                  }
                  let pageNumber, dest;
                  if (hash.includes("=")) {
                    const params = (0, _ui_utils.parseQueryString)(hash);
                    if (params.has("search")) {
                      this.eventBus.dispatch("findfromurlhash", {
                        source: this,
                        query: params.get("search").replace(/"/g, ""),
                        phraseSearch: params.get("phrase") === "true"
                      });
                    }
                    if (params.has("page")) {
                      pageNumber = params.get("page") | 0 || 1;
                    }
                    if (params.has("zoom")) {
                      const zoomArgs = params.get("zoom").split(",");
                      const zoomArg = zoomArgs[0];
                      const zoomArgNumber = parseFloat(zoomArg);
                      if (!zoomArg.includes("Fit")) {
                        dest = [null, {
                          name: "XYZ"
                        }, zoomArgs.length > 1 ? zoomArgs[1] | 0 : null, zoomArgs.length > 2 ? zoomArgs[2] | 0 : null, zoomArgNumber ? zoomArgNumber / 100 : zoomArg];
                      } else {
                        if (zoomArg === "Fit" || zoomArg === "FitB") {
                          dest = [null, {
                            name: zoomArg
                          }];
                        } else if (zoomArg === "FitH" || zoomArg === "FitBH" || zoomArg === "FitV" || zoomArg === "FitBV") {
                          dest = [null, {
                            name: zoomArg
                          }, zoomArgs.length > 1 ? zoomArgs[1] | 0 : null];
                        } else if (zoomArg === "FitR") {
                          if (zoomArgs.length !== 5) {
                            console.error('PDFLinkService.setHash: Not enough parameters for "FitR".');
                          } else {
                            dest = [null, {
                              name: zoomArg
                            }, zoomArgs[1] | 0, zoomArgs[2] | 0, zoomArgs[3] | 0, zoomArgs[4] | 0];
                          }
                        } else {
                          console.error(`PDFLinkService.setHash: "${zoomArg}" is not a valid zoom value.`);
                        }
                      }
                    }
                    if (dest) {
                      this.pdfViewer.scrollPageIntoView({
                        pageNumber: pageNumber || this.page,
                        destArray: dest,
                        allowNegativeOffset: true
                      });
                    } else if (pageNumber) {
                      this.page = pageNumber;
                    }
                    if (params.has("pagemode")) {
                      this.eventBus.dispatch("pagemode", {
                        source: this,
                        mode: params.get("pagemode")
                      });
                    }
                    if (params.has("nameddest")) {
                      this.goToDestination(params.get("nameddest"));
                    }
                  } else {
                    dest = unescape(hash);
                    try {
                      dest = JSON.parse(dest);
                      if (!Array.isArray(dest)) {
                        dest = dest.toString();
                      }
                    } catch (ex) {
                    }
                    if (typeof dest === "string" || _classStaticPrivateMethodGet(PDFLinkService2, PDFLinkService2, _isValidExplicitDestination).call(PDFLinkService2, dest)) {
                      this.goToDestination(dest);
                      return;
                    }
                    console.error(`PDFLinkService.setHash: "${unescape(hash)}" is not a valid destination.`);
                  }
                }
                executeNamedAction(action) {
                  var _this$pdfHistory, _this$pdfHistory2;
                  switch (action) {
                    case "GoBack":
                      (_this$pdfHistory = this.pdfHistory) === null || _this$pdfHistory === void 0 ? void 0 : _this$pdfHistory.back();
                      break;
                    case "GoForward":
                      (_this$pdfHistory2 = this.pdfHistory) === null || _this$pdfHistory2 === void 0 ? void 0 : _this$pdfHistory2.forward();
                      break;
                    case "NextPage":
                      this.pdfViewer.nextPage();
                      break;
                    case "PrevPage":
                      this.pdfViewer.previousPage();
                      break;
                    case "LastPage":
                      this.page = this.pagesCount;
                      break;
                    case "FirstPage":
                      this.page = 1;
                      break;
                    default:
                      break;
                  }
                  this.eventBus.dispatch("namedaction", {
                    source: this,
                    action
                  });
                }
                cachePageRef(pageNum, pageRef) {
                  if (!pageRef) {
                    return;
                  }
                  const refStr = pageRef.gen === 0 ? `${pageRef.num}R` : `${pageRef.num}R${pageRef.gen}`;
                  _classPrivateFieldGet2(this, _pagesRefCache).set(refStr, pageNum);
                }
                _cachedPageNumber(pageRef) {
                  if (!pageRef) {
                    return null;
                  }
                  const refStr = pageRef.gen === 0 ? `${pageRef.num}R` : `${pageRef.num}R${pageRef.gen}`;
                  return _classPrivateFieldGet2(this, _pagesRefCache).get(refStr) || null;
                }
                isPageVisible(pageNumber) {
                  return this.pdfViewer.isPageVisible(pageNumber);
                }
                isPageCached(pageNumber) {
                  return this.pdfViewer.isPageCached(pageNumber);
                }
              }
              exports3.PDFLinkService = PDFLinkService2;
              function _goToDestinationHelper2(rawDest) {
                let namedDest = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
                let explicitDest = arguments.length > 2 ? arguments[2] : void 0;
                const destRef = explicitDest[0];
                let pageNumber;
                if (typeof destRef === "object" && destRef !== null) {
                  pageNumber = this._cachedPageNumber(destRef);
                  if (!pageNumber) {
                    this.pdfDocument.getPageIndex(destRef).then((pageIndex) => {
                      this.cachePageRef(pageIndex + 1, destRef);
                      _classPrivateMethodGet2(this, _goToDestinationHelper, _goToDestinationHelper2).call(this, rawDest, namedDest, explicitDest);
                    }).catch(() => {
                      console.error(`PDFLinkService.#goToDestinationHelper: "${destRef}" is not a valid page reference, for dest="${rawDest}".`);
                    });
                    return;
                  }
                } else if (Number.isInteger(destRef)) {
                  pageNumber = destRef + 1;
                } else {
                  console.error(`PDFLinkService.#goToDestinationHelper: "${destRef}" is not a valid destination reference, for dest="${rawDest}".`);
                  return;
                }
                if (!pageNumber || pageNumber < 1 || pageNumber > this.pagesCount) {
                  console.error(`PDFLinkService.#goToDestinationHelper: "${pageNumber}" is not a valid page number, for dest="${rawDest}".`);
                  return;
                }
                if (this.pdfHistory) {
                  this.pdfHistory.pushCurrentPosition();
                  this.pdfHistory.push({
                    namedDest,
                    explicitDest,
                    pageNumber
                  });
                }
                this.pdfViewer.scrollPageIntoView({
                  pageNumber,
                  destArray: explicitDest,
                  ignoreDestinationZoom: this._ignoreDestinationZoom
                });
              }
              function _isValidExplicitDestination(dest) {
                if (!Array.isArray(dest)) {
                  return false;
                }
                const destLength = dest.length;
                if (destLength < 2) {
                  return false;
                }
                const page = dest[0];
                if (!(typeof page === "object" && Number.isInteger(page.num) && Number.isInteger(page.gen)) && !(Number.isInteger(page) && page >= 0)) {
                  return false;
                }
                const zoom = dest[1];
                if (!(typeof zoom === "object" && typeof zoom.name === "string")) {
                  return false;
                }
                let allowNull = true;
                switch (zoom.name) {
                  case "XYZ":
                    if (destLength !== 5) {
                      return false;
                    }
                    break;
                  case "Fit":
                  case "FitB":
                    return destLength === 2;
                  case "FitH":
                  case "FitBH":
                  case "FitV":
                  case "FitBV":
                    if (destLength !== 3) {
                      return false;
                    }
                    break;
                  case "FitR":
                    if (destLength !== 6) {
                      return false;
                    }
                    allowNull = false;
                    break;
                  default:
                    return false;
                }
                for (let i = 2; i < destLength; i++) {
                  const param = dest[i];
                  if (!(typeof param === "number" || allowNull && param === null)) {
                    return false;
                  }
                }
                return true;
              }
              class SimpleLinkService {
                constructor() {
                  this.externalLinkEnabled = true;
                }
                get pagesCount() {
                  return 0;
                }
                get page() {
                  return 0;
                }
                set page(value) {
                }
                get rotation() {
                  return 0;
                }
                set rotation(value) {
                }
                async goToDestination(dest) {
                }
                goToPage(val) {
                }
                addLinkAttributes(link, url) {
                  let newWindow = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                  addLinkAttributes(link, {
                    url,
                    enabled: this.externalLinkEnabled
                  });
                }
                getDestinationHash(dest) {
                  return "#";
                }
                getAnchorUrl(hash) {
                  return "#";
                }
                setHash(hash) {
                }
                executeNamedAction(action) {
                }
                cachePageRef(pageNum, pageRef) {
                }
                isPageVisible(pageNumber) {
                  return true;
                }
                isPageCached(pageNumber) {
                  return true;
                }
              }
              exports3.SimpleLinkService = SimpleLinkService;
            },
            /* 7 */
            /***/
            (__unused_webpack_module2, exports3) => {
              Object.defineProperty(exports3, "__esModule", {
                value: true
              });
              exports3.animationStarted = exports3.VERTICAL_PADDING = exports3.UNKNOWN_SCALE = exports3.TextLayerMode = exports3.SpreadMode = exports3.SidebarView = exports3.ScrollMode = exports3.SCROLLBAR_PADDING = exports3.RenderingStates = exports3.RendererType = exports3.ProgressBar = exports3.PresentationModeState = exports3.OutputScale = exports3.MIN_SCALE = exports3.MAX_SCALE = exports3.MAX_AUTO_SCALE = exports3.DEFAULT_SCALE_VALUE = exports3.DEFAULT_SCALE_DELTA = exports3.DEFAULT_SCALE = exports3.AutoPrintRegExp = void 0;
              exports3.apiPageLayoutToViewerModes = apiPageLayoutToViewerModes;
              exports3.apiPageModeToSidebarView = apiPageModeToSidebarView;
              exports3.approximateFraction = approximateFraction;
              exports3.backtrackBeforeAllVisibleElements = backtrackBeforeAllVisibleElements;
              exports3.binarySearchFirstItem = binarySearchFirstItem;
              exports3.docStyle = void 0;
              exports3.getActiveOrFocusedElement = getActiveOrFocusedElement;
              exports3.getPageSizeInches = getPageSizeInches;
              exports3.getVisibleElements = getVisibleElements;
              exports3.isPortraitOrientation = isPortraitOrientation;
              exports3.isValidRotation = isValidRotation;
              exports3.isValidScrollMode = isValidScrollMode;
              exports3.isValidSpreadMode = isValidSpreadMode;
              exports3.noContextMenuHandler = noContextMenuHandler;
              exports3.normalizeWheelEventDelta = normalizeWheelEventDelta;
              exports3.normalizeWheelEventDirection = normalizeWheelEventDirection;
              exports3.parseQueryString = parseQueryString;
              exports3.removeNullCharacters = removeNullCharacters;
              exports3.roundToDivide = roundToDivide;
              exports3.scrollIntoView = scrollIntoView;
              exports3.watchScroll = watchScroll;
              function _classPrivateFieldInitSpec2(obj, privateMap, value) {
                _checkPrivateRedeclaration2(obj, privateMap);
                privateMap.set(obj, value);
              }
              function _checkPrivateRedeclaration2(obj, privateCollection) {
                if (privateCollection.has(obj)) {
                  throw new TypeError("Cannot initialize the same private elements twice on an object");
                }
              }
              function _classPrivateFieldGet2(receiver, privateMap) {
                var descriptor = _classExtractFieldDescriptor2(receiver, privateMap, "get");
                return _classApplyDescriptorGet2(receiver, descriptor);
              }
              function _classApplyDescriptorGet2(receiver, descriptor) {
                if (descriptor.get) {
                  return descriptor.get.call(receiver);
                }
                return descriptor.value;
              }
              function _classPrivateFieldSet2(receiver, privateMap, value) {
                var descriptor = _classExtractFieldDescriptor2(receiver, privateMap, "set");
                _classApplyDescriptorSet2(receiver, descriptor, value);
                return value;
              }
              function _classExtractFieldDescriptor2(receiver, privateMap, action) {
                if (!privateMap.has(receiver)) {
                  throw new TypeError("attempted to " + action + " private field on non-instance");
                }
                return privateMap.get(receiver);
              }
              function _classApplyDescriptorSet2(receiver, descriptor, value) {
                if (descriptor.set) {
                  descriptor.set.call(receiver, value);
                } else {
                  if (!descriptor.writable) {
                    throw new TypeError("attempted to set read only private field");
                  }
                  descriptor.value = value;
                }
              }
              const DEFAULT_SCALE_VALUE = "auto";
              exports3.DEFAULT_SCALE_VALUE = DEFAULT_SCALE_VALUE;
              const DEFAULT_SCALE = 1;
              exports3.DEFAULT_SCALE = DEFAULT_SCALE;
              const DEFAULT_SCALE_DELTA = 1.1;
              exports3.DEFAULT_SCALE_DELTA = DEFAULT_SCALE_DELTA;
              const MIN_SCALE = 0.1;
              exports3.MIN_SCALE = MIN_SCALE;
              const MAX_SCALE = 10;
              exports3.MAX_SCALE = MAX_SCALE;
              const UNKNOWN_SCALE = 0;
              exports3.UNKNOWN_SCALE = UNKNOWN_SCALE;
              const MAX_AUTO_SCALE = 1.25;
              exports3.MAX_AUTO_SCALE = MAX_AUTO_SCALE;
              const SCROLLBAR_PADDING = 40;
              exports3.SCROLLBAR_PADDING = SCROLLBAR_PADDING;
              const VERTICAL_PADDING = 5;
              exports3.VERTICAL_PADDING = VERTICAL_PADDING;
              const RenderingStates = {
                INITIAL: 0,
                RUNNING: 1,
                PAUSED: 2,
                FINISHED: 3
              };
              exports3.RenderingStates = RenderingStates;
              const PresentationModeState = {
                UNKNOWN: 0,
                NORMAL: 1,
                CHANGING: 2,
                FULLSCREEN: 3
              };
              exports3.PresentationModeState = PresentationModeState;
              const SidebarView = {
                UNKNOWN: -1,
                NONE: 0,
                THUMBS: 1,
                OUTLINE: 2,
                ATTACHMENTS: 3,
                LAYERS: 4
              };
              exports3.SidebarView = SidebarView;
              const RendererType = {
                CANVAS: "canvas",
                SVG: "svg"
              };
              exports3.RendererType = RendererType;
              const TextLayerMode = {
                DISABLE: 0,
                ENABLE: 1,
                ENABLE_ENHANCE: 2
              };
              exports3.TextLayerMode = TextLayerMode;
              const ScrollMode = {
                UNKNOWN: -1,
                VERTICAL: 0,
                HORIZONTAL: 1,
                WRAPPED: 2,
                PAGE: 3
              };
              exports3.ScrollMode = ScrollMode;
              const SpreadMode = {
                UNKNOWN: -1,
                NONE: 0,
                ODD: 1,
                EVEN: 2
              };
              exports3.SpreadMode = SpreadMode;
              const AutoPrintRegExp = /\bprint\s*\(/;
              exports3.AutoPrintRegExp = AutoPrintRegExp;
              class OutputScale {
                constructor() {
                  const pixelRatio = window.devicePixelRatio || 1;
                  this.sx = pixelRatio;
                  this.sy = pixelRatio;
                }
                get scaled() {
                  return this.sx !== 1 || this.sy !== 1;
                }
              }
              exports3.OutputScale = OutputScale;
              function scrollIntoView(element, spot) {
                let scrollMatches = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                let parent = element.offsetParent;
                if (!parent) {
                  console.error("offsetParent is not set -- cannot scroll");
                  return;
                }
                let offsetY = element.offsetTop + element.clientTop;
                let offsetX = element.offsetLeft + element.clientLeft;
                while (parent.clientHeight === parent.scrollHeight && parent.clientWidth === parent.scrollWidth || scrollMatches && (parent.classList.contains("markedContent") || getComputedStyle(parent).overflow === "hidden")) {
                  offsetY += parent.offsetTop;
                  offsetX += parent.offsetLeft;
                  parent = parent.offsetParent;
                  if (!parent) {
                    return;
                  }
                }
                if (spot) {
                  if (spot.top !== void 0) {
                    offsetY += spot.top;
                  }
                  if (spot.left !== void 0) {
                    offsetX += spot.left;
                    parent.scrollLeft = offsetX;
                  }
                }
                parent.scrollTop = offsetY;
              }
              function watchScroll(viewAreaElement, callback) {
                const debounceScroll = function(evt) {
                  if (rAF) {
                    return;
                  }
                  rAF = window.requestAnimationFrame(function viewAreaElementScrolled() {
                    rAF = null;
                    const currentX = viewAreaElement.scrollLeft;
                    const lastX = state.lastX;
                    if (currentX !== lastX) {
                      state.right = currentX > lastX;
                    }
                    state.lastX = currentX;
                    const currentY = viewAreaElement.scrollTop;
                    const lastY = state.lastY;
                    if (currentY !== lastY) {
                      state.down = currentY > lastY;
                    }
                    state.lastY = currentY;
                    callback(state);
                  });
                };
                const state = {
                  right: true,
                  down: true,
                  lastX: viewAreaElement.scrollLeft,
                  lastY: viewAreaElement.scrollTop,
                  _eventHandler: debounceScroll
                };
                let rAF = null;
                viewAreaElement.addEventListener("scroll", debounceScroll, true);
                return state;
              }
              function parseQueryString(query) {
                const params = /* @__PURE__ */ new Map();
                for (const [key, value] of new URLSearchParams(query)) {
                  params.set(key.toLowerCase(), value);
                }
                return params;
              }
              const NullCharactersRegExp = /\x00/g;
              const InvisibleCharactersRegExp = /[\x01-\x1F]/g;
              function removeNullCharacters(str) {
                let replaceInvisible = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                if (typeof str !== "string") {
                  console.error(`The argument must be a string.`);
                  return str;
                }
                if (replaceInvisible) {
                  str = str.replace(InvisibleCharactersRegExp, " ");
                }
                return str.replace(NullCharactersRegExp, "");
              }
              function binarySearchFirstItem(items, condition) {
                let start = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
                let minIndex = start;
                let maxIndex = items.length - 1;
                if (maxIndex < 0 || !condition(items[maxIndex])) {
                  return items.length;
                }
                if (condition(items[minIndex])) {
                  return minIndex;
                }
                while (minIndex < maxIndex) {
                  const currentIndex = minIndex + maxIndex >> 1;
                  const currentItem = items[currentIndex];
                  if (condition(currentItem)) {
                    maxIndex = currentIndex;
                  } else {
                    minIndex = currentIndex + 1;
                  }
                }
                return minIndex;
              }
              function approximateFraction(x) {
                if (Math.floor(x) === x) {
                  return [x, 1];
                }
                const xinv = 1 / x;
                const limit = 8;
                if (xinv > limit) {
                  return [1, limit];
                } else if (Math.floor(xinv) === xinv) {
                  return [1, xinv];
                }
                const x_ = x > 1 ? xinv : x;
                let a = 0, b = 1, c = 1, d = 1;
                while (true) {
                  const p = a + c, q = b + d;
                  if (q > limit) {
                    break;
                  }
                  if (x_ <= p / q) {
                    c = p;
                    d = q;
                  } else {
                    a = p;
                    b = q;
                  }
                }
                let result;
                if (x_ - a / b < c / d - x_) {
                  result = x_ === x ? [a, b] : [b, a];
                } else {
                  result = x_ === x ? [c, d] : [d, c];
                }
                return result;
              }
              function roundToDivide(x, div) {
                const r2 = x % div;
                return r2 === 0 ? x : Math.round(x - r2 + div);
              }
              function getPageSizeInches(_ref) {
                let {
                  view,
                  userUnit,
                  rotate
                } = _ref;
                const [x1, y1, x2, y2] = view;
                const changeOrientation = rotate % 180 !== 0;
                const width = (x2 - x1) / 72 * userUnit;
                const height = (y2 - y1) / 72 * userUnit;
                return {
                  width: changeOrientation ? height : width,
                  height: changeOrientation ? width : height
                };
              }
              function backtrackBeforeAllVisibleElements(index, views, top) {
                if (index < 2) {
                  return index;
                }
                let elt = views[index].div;
                let pageTop = elt.offsetTop + elt.clientTop;
                if (pageTop >= top) {
                  elt = views[index - 1].div;
                  pageTop = elt.offsetTop + elt.clientTop;
                }
                for (let i = index - 2; i >= 0; --i) {
                  elt = views[i].div;
                  if (elt.offsetTop + elt.clientTop + elt.clientHeight <= pageTop) {
                    break;
                  }
                  index = i;
                }
                return index;
              }
              function getVisibleElements(_ref2) {
                let {
                  scrollEl,
                  views,
                  sortByVisibility = false,
                  horizontal = false,
                  rtl = false
                } = _ref2;
                const top = scrollEl.scrollTop, bottom = top + scrollEl.clientHeight;
                const left = scrollEl.scrollLeft, right = left + scrollEl.clientWidth;
                function isElementBottomAfterViewTop(view) {
                  const element = view.div;
                  const elementBottom = element.offsetTop + element.clientTop + element.clientHeight;
                  return elementBottom > top;
                }
                function isElementNextAfterViewHorizontally(view) {
                  const element = view.div;
                  const elementLeft = element.offsetLeft + element.clientLeft;
                  const elementRight = elementLeft + element.clientWidth;
                  return rtl ? elementLeft < right : elementRight > left;
                }
                const visible = [], ids = /* @__PURE__ */ new Set(), numViews = views.length;
                let firstVisibleElementInd = binarySearchFirstItem(views, horizontal ? isElementNextAfterViewHorizontally : isElementBottomAfterViewTop);
                if (firstVisibleElementInd > 0 && firstVisibleElementInd < numViews && !horizontal) {
                  firstVisibleElementInd = backtrackBeforeAllVisibleElements(firstVisibleElementInd, views, top);
                }
                let lastEdge = horizontal ? right : -1;
                for (let i = firstVisibleElementInd; i < numViews; i++) {
                  const view = views[i], element = view.div;
                  const currentWidth = element.offsetLeft + element.clientLeft;
                  const currentHeight = element.offsetTop + element.clientTop;
                  const viewWidth = element.clientWidth, viewHeight = element.clientHeight;
                  const viewRight = currentWidth + viewWidth;
                  const viewBottom = currentHeight + viewHeight;
                  if (lastEdge === -1) {
                    if (viewBottom >= bottom) {
                      lastEdge = viewBottom;
                    }
                  } else if ((horizontal ? currentWidth : currentHeight) > lastEdge) {
                    break;
                  }
                  if (viewBottom <= top || currentHeight >= bottom || viewRight <= left || currentWidth >= right) {
                    continue;
                  }
                  const hiddenHeight = Math.max(0, top - currentHeight) + Math.max(0, viewBottom - bottom);
                  const hiddenWidth = Math.max(0, left - currentWidth) + Math.max(0, viewRight - right);
                  const fractionHeight = (viewHeight - hiddenHeight) / viewHeight, fractionWidth = (viewWidth - hiddenWidth) / viewWidth;
                  const percent = fractionHeight * fractionWidth * 100 | 0;
                  visible.push({
                    id: view.id,
                    x: currentWidth,
                    y: currentHeight,
                    view,
                    percent,
                    widthPercent: fractionWidth * 100 | 0
                  });
                  ids.add(view.id);
                }
                const first = visible[0], last = visible.at(-1);
                if (sortByVisibility) {
                  visible.sort(function(a, b) {
                    const pc = a.percent - b.percent;
                    if (Math.abs(pc) > 1e-3) {
                      return -pc;
                    }
                    return a.id - b.id;
                  });
                }
                return {
                  first,
                  last,
                  views: visible,
                  ids
                };
              }
              function noContextMenuHandler(evt) {
                evt.preventDefault();
              }
              function normalizeWheelEventDirection(evt) {
                let delta = Math.hypot(evt.deltaX, evt.deltaY);
                const angle = Math.atan2(evt.deltaY, evt.deltaX);
                if (-0.25 * Math.PI < angle && angle < 0.75 * Math.PI) {
                  delta = -delta;
                }
                return delta;
              }
              function normalizeWheelEventDelta(evt) {
                let delta = normalizeWheelEventDirection(evt);
                const MOUSE_DOM_DELTA_PIXEL_MODE = 0;
                const MOUSE_DOM_DELTA_LINE_MODE = 1;
                const MOUSE_PIXELS_PER_LINE = 30;
                const MOUSE_LINES_PER_PAGE = 30;
                if (evt.deltaMode === MOUSE_DOM_DELTA_PIXEL_MODE) {
                  delta /= MOUSE_PIXELS_PER_LINE * MOUSE_LINES_PER_PAGE;
                } else if (evt.deltaMode === MOUSE_DOM_DELTA_LINE_MODE) {
                  delta /= MOUSE_LINES_PER_PAGE;
                }
                return delta;
              }
              function isValidRotation(angle) {
                return Number.isInteger(angle) && angle % 90 === 0;
              }
              function isValidScrollMode(mode) {
                return Number.isInteger(mode) && Object.values(ScrollMode).includes(mode) && mode !== ScrollMode.UNKNOWN;
              }
              function isValidSpreadMode(mode) {
                return Number.isInteger(mode) && Object.values(SpreadMode).includes(mode) && mode !== SpreadMode.UNKNOWN;
              }
              function isPortraitOrientation(size) {
                return size.width <= size.height;
              }
              const animationStarted = new Promise(function(resolve) {
                window.requestAnimationFrame(resolve);
              });
              exports3.animationStarted = animationStarted;
              const docStyle = document.documentElement.style;
              exports3.docStyle = docStyle;
              function clamp3(v, min, max) {
                return Math.min(Math.max(v, min), max);
              }
              var _classList = /* @__PURE__ */ new WeakMap();
              var _percent = /* @__PURE__ */ new WeakMap();
              var _visible = /* @__PURE__ */ new WeakMap();
              class ProgressBar {
                constructor(id) {
                  _classPrivateFieldInitSpec2(this, _classList, {
                    writable: true,
                    value: null
                  });
                  _classPrivateFieldInitSpec2(this, _percent, {
                    writable: true,
                    value: 0
                  });
                  _classPrivateFieldInitSpec2(this, _visible, {
                    writable: true,
                    value: true
                  });
                  if (arguments.length > 1) {
                    throw new Error("ProgressBar no longer accepts any additional options, please use CSS rules to modify its appearance instead.");
                  }
                  const bar = document.getElementById(id);
                  _classPrivateFieldSet2(this, _classList, bar.classList);
                }
                get percent() {
                  return _classPrivateFieldGet2(this, _percent);
                }
                set percent(val) {
                  _classPrivateFieldSet2(this, _percent, clamp3(val, 0, 100));
                  if (isNaN(val)) {
                    _classPrivateFieldGet2(this, _classList).add("indeterminate");
                    return;
                  }
                  _classPrivateFieldGet2(this, _classList).remove("indeterminate");
                  docStyle.setProperty("--progressBar-percent", `${_classPrivateFieldGet2(this, _percent)}%`);
                }
                setWidth(viewer) {
                  if (!viewer) {
                    return;
                  }
                  const container = viewer.parentNode;
                  const scrollbarWidth = container.offsetWidth - viewer.offsetWidth;
                  if (scrollbarWidth > 0) {
                    docStyle.setProperty("--progressBar-end-offset", `${scrollbarWidth}px`);
                  }
                }
                hide() {
                  if (!_classPrivateFieldGet2(this, _visible)) {
                    return;
                  }
                  _classPrivateFieldSet2(this, _visible, false);
                  _classPrivateFieldGet2(this, _classList).add("hidden");
                }
                show() {
                  if (_classPrivateFieldGet2(this, _visible)) {
                    return;
                  }
                  _classPrivateFieldSet2(this, _visible, true);
                  _classPrivateFieldGet2(this, _classList).remove("hidden");
                }
              }
              exports3.ProgressBar = ProgressBar;
              function getActiveOrFocusedElement() {
                let curRoot = document;
                let curActiveOrFocused = curRoot.activeElement || curRoot.querySelector(":focus");
                while ((_curActiveOrFocused = curActiveOrFocused) !== null && _curActiveOrFocused !== void 0 && _curActiveOrFocused.shadowRoot) {
                  var _curActiveOrFocused;
                  curRoot = curActiveOrFocused.shadowRoot;
                  curActiveOrFocused = curRoot.activeElement || curRoot.querySelector(":focus");
                }
                return curActiveOrFocused;
              }
              function apiPageLayoutToViewerModes(layout) {
                let scrollMode = ScrollMode.VERTICAL, spreadMode = SpreadMode.NONE;
                switch (layout) {
                  case "SinglePage":
                    scrollMode = ScrollMode.PAGE;
                    break;
                  case "OneColumn":
                    break;
                  case "TwoPageLeft":
                    scrollMode = ScrollMode.PAGE;
                  case "TwoColumnLeft":
                    spreadMode = SpreadMode.ODD;
                    break;
                  case "TwoPageRight":
                    scrollMode = ScrollMode.PAGE;
                  case "TwoColumnRight":
                    spreadMode = SpreadMode.EVEN;
                    break;
                }
                return {
                  scrollMode,
                  spreadMode
                };
              }
              function apiPageModeToSidebarView(mode) {
                switch (mode) {
                  case "UseNone":
                    return SidebarView.NONE;
                  case "UseThumbs":
                    return SidebarView.THUMBS;
                  case "UseOutlines":
                    return SidebarView.OUTLINE;
                  case "UseAttachments":
                    return SidebarView.ATTACHMENTS;
                  case "UseOC":
                    return SidebarView.LAYERS;
                }
                return SidebarView.NONE;
              }
            },
            /* 8 */
            /***/
            (__unused_webpack_module2, exports3) => {
              Object.defineProperty(exports3, "__esModule", {
                value: true
              });
              exports3.StructTreeLayerBuilder = void 0;
              const PDF_ROLE_TO_HTML_ROLE = {
                Document: null,
                DocumentFragment: null,
                Part: "group",
                Sect: "group",
                Div: "group",
                Aside: "note",
                NonStruct: "none",
                P: null,
                H: "heading",
                Title: null,
                FENote: "note",
                Sub: "group",
                Lbl: null,
                Span: null,
                Em: null,
                Strong: null,
                Link: "link",
                Annot: "note",
                Form: "form",
                Ruby: null,
                RB: null,
                RT: null,
                RP: null,
                Warichu: null,
                WT: null,
                WP: null,
                L: "list",
                LI: "listitem",
                LBody: null,
                Table: "table",
                TR: "row",
                TH: "columnheader",
                TD: "cell",
                THead: "columnheader",
                TBody: null,
                TFoot: null,
                Caption: null,
                Figure: "figure",
                Formula: null,
                Artifact: null
              };
              const HEADING_PATTERN = /^H(\d+)$/;
              class StructTreeLayerBuilder {
                constructor(_ref) {
                  let {
                    pdfPage
                  } = _ref;
                  this.pdfPage = pdfPage;
                }
                render(structTree) {
                  return this._walk(structTree);
                }
                _setAttributes(structElement, htmlElement) {
                  if (structElement.alt !== void 0) {
                    htmlElement.setAttribute("aria-label", structElement.alt);
                  }
                  if (structElement.id !== void 0) {
                    htmlElement.setAttribute("aria-owns", structElement.id);
                  }
                  if (structElement.lang !== void 0) {
                    htmlElement.setAttribute("lang", structElement.lang);
                  }
                }
                _walk(node) {
                  if (!node) {
                    return null;
                  }
                  const element = document.createElement("span");
                  if ("role" in node) {
                    const {
                      role
                    } = node;
                    const match = role.match(HEADING_PATTERN);
                    if (match) {
                      element.setAttribute("role", "heading");
                      element.setAttribute("aria-level", match[1]);
                    } else if (PDF_ROLE_TO_HTML_ROLE[role]) {
                      element.setAttribute("role", PDF_ROLE_TO_HTML_ROLE[role]);
                    }
                  }
                  this._setAttributes(node, element);
                  if (node.children) {
                    if (node.children.length === 1 && "id" in node.children[0]) {
                      this._setAttributes(node.children[0], element);
                    } else {
                      for (const kid of node.children) {
                        element.append(this._walk(kid));
                      }
                    }
                  }
                  return element;
                }
              }
              exports3.StructTreeLayerBuilder = StructTreeLayerBuilder;
            },
            /* 9 */
            /***/
            (__unused_webpack_module2, exports3, __w_pdfjs_require__3) => {
              Object.defineProperty(exports3, "__esModule", {
                value: true
              });
              exports3.TextLayerBuilder = void 0;
              var _pdfjsLib = __w_pdfjs_require__3(3);
              const EXPAND_DIVS_TIMEOUT = 300;
              class TextLayerBuilder {
                constructor(_ref) {
                  let {
                    textLayerDiv,
                    eventBus,
                    pageIndex,
                    viewport,
                    highlighter = null,
                    enhanceTextSelection = false,
                    accessibilityManager = null
                  } = _ref;
                  this.textLayerDiv = textLayerDiv;
                  this.eventBus = eventBus;
                  this.textContent = null;
                  this.textContentItemsStr = [];
                  this.textContentStream = null;
                  this.renderingDone = false;
                  this.pageNumber = pageIndex + 1;
                  this.viewport = viewport;
                  this.textDivs = [];
                  this.textLayerRenderTask = null;
                  this.highlighter = highlighter;
                  this.enhanceTextSelection = enhanceTextSelection;
                  this.accessibilityManager = accessibilityManager;
                  this._bindMouse();
                }
                _finishRendering() {
                  this.renderingDone = true;
                  if (!this.enhanceTextSelection) {
                    const endOfContent = document.createElement("div");
                    endOfContent.className = "endOfContent";
                    this.textLayerDiv.append(endOfContent);
                  }
                  this.eventBus.dispatch("textlayerrendered", {
                    source: this,
                    pageNumber: this.pageNumber,
                    numTextDivs: this.textDivs.length
                  });
                }
                render() {
                  var _this$highlighter, _this$accessibilityMa;
                  let timeout = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
                  if (!(this.textContent || this.textContentStream) || this.renderingDone) {
                    return;
                  }
                  this.cancel();
                  this.textDivs.length = 0;
                  (_this$highlighter = this.highlighter) === null || _this$highlighter === void 0 ? void 0 : _this$highlighter.setTextMapping(this.textDivs, this.textContentItemsStr);
                  (_this$accessibilityMa = this.accessibilityManager) === null || _this$accessibilityMa === void 0 ? void 0 : _this$accessibilityMa.setTextMapping(this.textDivs);
                  const textLayerFrag = document.createDocumentFragment();
                  this.textLayerRenderTask = (0, _pdfjsLib.renderTextLayer)({
                    textContent: this.textContent,
                    textContentStream: this.textContentStream,
                    container: textLayerFrag,
                    viewport: this.viewport,
                    textDivs: this.textDivs,
                    textContentItemsStr: this.textContentItemsStr,
                    timeout,
                    enhanceTextSelection: this.enhanceTextSelection
                  });
                  this.textLayerRenderTask.promise.then(() => {
                    var _this$highlighter2, _this$accessibilityMa2;
                    this.textLayerDiv.append(textLayerFrag);
                    this._finishRendering();
                    (_this$highlighter2 = this.highlighter) === null || _this$highlighter2 === void 0 ? void 0 : _this$highlighter2.enable();
                    (_this$accessibilityMa2 = this.accessibilityManager) === null || _this$accessibilityMa2 === void 0 ? void 0 : _this$accessibilityMa2.enable();
                  }, function(reason) {
                  });
                }
                cancel() {
                  var _this$highlighter3, _this$accessibilityMa3;
                  if (this.textLayerRenderTask) {
                    this.textLayerRenderTask.cancel();
                    this.textLayerRenderTask = null;
                  }
                  (_this$highlighter3 = this.highlighter) === null || _this$highlighter3 === void 0 ? void 0 : _this$highlighter3.disable();
                  (_this$accessibilityMa3 = this.accessibilityManager) === null || _this$accessibilityMa3 === void 0 ? void 0 : _this$accessibilityMa3.disable();
                }
                setTextContentStream(readableStream) {
                  this.cancel();
                  this.textContentStream = readableStream;
                }
                setTextContent(textContent) {
                  this.cancel();
                  this.textContent = textContent;
                }
                _bindMouse() {
                  const div = this.textLayerDiv;
                  let expandDivsTimer = null;
                  div.addEventListener("mousedown", (evt) => {
                    if (this.enhanceTextSelection && this.textLayerRenderTask) {
                      this.textLayerRenderTask.expandTextDivs(true);
                      if (expandDivsTimer) {
                        clearTimeout(expandDivsTimer);
                        expandDivsTimer = null;
                      }
                      return;
                    }
                    const end = div.querySelector(".endOfContent");
                    if (!end) {
                      return;
                    }
                    let adjustTop = evt.target !== div;
                    adjustTop = adjustTop && window.getComputedStyle(end).getPropertyValue("-moz-user-select") !== "none";
                    if (adjustTop) {
                      const divBounds = div.getBoundingClientRect();
                      const r2 = Math.max(0, (evt.pageY - divBounds.top) / divBounds.height);
                      end.style.top = (r2 * 100).toFixed(2) + "%";
                    }
                    end.classList.add("active");
                  });
                  div.addEventListener("mouseup", () => {
                    if (this.enhanceTextSelection && this.textLayerRenderTask) {
                      expandDivsTimer = setTimeout(() => {
                        if (this.textLayerRenderTask) {
                          this.textLayerRenderTask.expandTextDivs(false);
                        }
                        expandDivsTimer = null;
                      }, EXPAND_DIVS_TIMEOUT);
                      return;
                    }
                    const end = div.querySelector(".endOfContent");
                    if (!end) {
                      return;
                    }
                    end.style.top = "";
                    end.classList.remove("active");
                  });
                }
              }
              exports3.TextLayerBuilder = TextLayerBuilder;
            },
            /* 10 */
            /***/
            (__unused_webpack_module2, exports3, __w_pdfjs_require__3) => {
              Object.defineProperty(exports3, "__esModule", {
                value: true
              });
              exports3.XfaLayerBuilder = void 0;
              var _pdfjsLib = __w_pdfjs_require__3(3);
              class XfaLayerBuilder {
                constructor(_ref) {
                  let {
                    pageDiv,
                    pdfPage,
                    annotationStorage = null,
                    linkService,
                    xfaHtml = null
                  } = _ref;
                  this.pageDiv = pageDiv;
                  this.pdfPage = pdfPage;
                  this.annotationStorage = annotationStorage;
                  this.linkService = linkService;
                  this.xfaHtml = xfaHtml;
                  this.div = null;
                  this._cancelled = false;
                }
                render(viewport) {
                  let intent = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "display";
                  if (intent === "print") {
                    const parameters = {
                      viewport: viewport.clone({
                        dontFlip: true
                      }),
                      div: this.div,
                      xfaHtml: this.xfaHtml,
                      annotationStorage: this.annotationStorage,
                      linkService: this.linkService,
                      intent
                    };
                    const div = document.createElement("div");
                    this.pageDiv.append(div);
                    parameters.div = div;
                    const result = _pdfjsLib.XfaLayer.render(parameters);
                    return Promise.resolve(result);
                  }
                  return this.pdfPage.getXfa().then((xfaHtml) => {
                    if (this._cancelled || !xfaHtml) {
                      return {
                        textDivs: []
                      };
                    }
                    const parameters = {
                      viewport: viewport.clone({
                        dontFlip: true
                      }),
                      div: this.div,
                      xfaHtml,
                      annotationStorage: this.annotationStorage,
                      linkService: this.linkService,
                      intent
                    };
                    if (this.div) {
                      return _pdfjsLib.XfaLayer.update(parameters);
                    }
                    this.div = document.createElement("div");
                    this.pageDiv.append(this.div);
                    parameters.div = this.div;
                    return _pdfjsLib.XfaLayer.render(parameters);
                  }).catch((error) => {
                    console.error(error);
                  });
                }
                cancel() {
                  this._cancelled = true;
                }
                hide() {
                  if (!this.div) {
                    return;
                  }
                  this.div.hidden = true;
                }
              }
              exports3.XfaLayerBuilder = XfaLayerBuilder;
            },
            /* 11 */
            /***/
            (__unused_webpack_module2, exports3, __w_pdfjs_require__3) => {
              Object.defineProperty(exports3, "__esModule", {
                value: true
              });
              exports3.PDFViewer = exports3.PDFSinglePageViewer = void 0;
              var _ui_utils = __w_pdfjs_require__3(7);
              var _base_viewer = __w_pdfjs_require__3(12);
              class PDFViewer2 extends _base_viewer.BaseViewer {
              }
              exports3.PDFViewer = PDFViewer2;
              class PDFSinglePageViewer extends _base_viewer.BaseViewer {
                _resetView() {
                  super._resetView();
                  this._scrollMode = _ui_utils.ScrollMode.PAGE;
                  this._spreadMode = _ui_utils.SpreadMode.NONE;
                }
                set scrollMode(mode) {
                }
                _updateScrollMode() {
                }
                set spreadMode(mode) {
                }
                _updateSpreadMode() {
                }
              }
              exports3.PDFSinglePageViewer = PDFSinglePageViewer;
            },
            /* 12 */
            /***/
            (__unused_webpack_module2, exports3, __w_pdfjs_require__3) => {
              Object.defineProperty(exports3, "__esModule", {
                value: true
              });
              exports3.PagesCountLimit = exports3.PDFPageViewBuffer = exports3.BaseViewer = void 0;
              var _pdfjsLib = __w_pdfjs_require__3(3);
              var _ui_utils = __w_pdfjs_require__3(7);
              var _annotation_editor_layer_builder = __w_pdfjs_require__3(2);
              var _annotation_layer_builder = __w_pdfjs_require__3(5);
              var _l10n_utils = __w_pdfjs_require__3(4);
              var _pdf_page_view = __w_pdfjs_require__3(13);
              var _pdf_rendering_queue = __w_pdfjs_require__3(16);
              var _pdf_link_service = __w_pdfjs_require__3(6);
              var _struct_tree_layer_builder = __w_pdfjs_require__3(8);
              var _text_highlighter = __w_pdfjs_require__3(17);
              var _text_layer_builder = __w_pdfjs_require__3(9);
              var _xfa_layer_builder = __w_pdfjs_require__3(10);
              let _Symbol$iterator;
              function _classPrivateMethodInitSpec2(obj, privateSet) {
                _checkPrivateRedeclaration2(obj, privateSet);
                privateSet.add(obj);
              }
              function _classPrivateFieldInitSpec2(obj, privateMap, value) {
                _checkPrivateRedeclaration2(obj, privateMap);
                privateMap.set(obj, value);
              }
              function _checkPrivateRedeclaration2(obj, privateCollection) {
                if (privateCollection.has(obj)) {
                  throw new TypeError("Cannot initialize the same private elements twice on an object");
                }
              }
              function _classPrivateMethodGet2(receiver, privateSet, fn) {
                if (!privateSet.has(receiver)) {
                  throw new TypeError("attempted to get private field on non-instance");
                }
                return fn;
              }
              function _classPrivateFieldGet2(receiver, privateMap) {
                var descriptor = _classExtractFieldDescriptor2(receiver, privateMap, "get");
                return _classApplyDescriptorGet2(receiver, descriptor);
              }
              function _classApplyDescriptorGet2(receiver, descriptor) {
                if (descriptor.get) {
                  return descriptor.get.call(receiver);
                }
                return descriptor.value;
              }
              function _classPrivateFieldSet2(receiver, privateMap, value) {
                var descriptor = _classExtractFieldDescriptor2(receiver, privateMap, "set");
                _classApplyDescriptorSet2(receiver, descriptor, value);
                return value;
              }
              function _classExtractFieldDescriptor2(receiver, privateMap, action) {
                if (!privateMap.has(receiver)) {
                  throw new TypeError("attempted to " + action + " private field on non-instance");
                }
                return privateMap.get(receiver);
              }
              function _classApplyDescriptorSet2(receiver, descriptor, value) {
                if (descriptor.set) {
                  descriptor.set.call(receiver, value);
                } else {
                  if (!descriptor.writable) {
                    throw new TypeError("attempted to set read only private field");
                  }
                  descriptor.value = value;
                }
              }
              const DEFAULT_CACHE_SIZE = 10;
              const ENABLE_PERMISSIONS_CLASS = "enablePermissions";
              const PagesCountLimit = {
                FORCE_SCROLL_MODE_PAGE: 15e3,
                FORCE_LAZY_PAGE_INIT: 7500,
                PAUSE_EAGER_PAGE_INIT: 250
              };
              exports3.PagesCountLimit = PagesCountLimit;
              function isValidAnnotationEditorMode(mode) {
                return Object.values(_pdfjsLib.AnnotationEditorType).includes(mode) && mode !== _pdfjsLib.AnnotationEditorType.DISABLE;
              }
              var _buf = /* @__PURE__ */ new WeakMap();
              var _size = /* @__PURE__ */ new WeakMap();
              var _destroyFirstView = /* @__PURE__ */ new WeakSet();
              _Symbol$iterator = Symbol.iterator;
              class PDFPageViewBuffer {
                constructor(size) {
                  _classPrivateMethodInitSpec2(this, _destroyFirstView);
                  _classPrivateFieldInitSpec2(this, _buf, {
                    writable: true,
                    value: /* @__PURE__ */ new Set()
                  });
                  _classPrivateFieldInitSpec2(this, _size, {
                    writable: true,
                    value: 0
                  });
                  _classPrivateFieldSet2(this, _size, size);
                }
                push(view) {
                  const buf = _classPrivateFieldGet2(this, _buf);
                  if (buf.has(view)) {
                    buf.delete(view);
                  }
                  buf.add(view);
                  if (buf.size > _classPrivateFieldGet2(this, _size)) {
                    _classPrivateMethodGet2(this, _destroyFirstView, _destroyFirstView2).call(this);
                  }
                }
                resize(newSize) {
                  let idsToKeep = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
                  _classPrivateFieldSet2(this, _size, newSize);
                  const buf = _classPrivateFieldGet2(this, _buf);
                  if (idsToKeep) {
                    const ii = buf.size;
                    let i = 1;
                    for (const view of buf) {
                      if (idsToKeep.has(view.id)) {
                        buf.delete(view);
                        buf.add(view);
                      }
                      if (++i > ii) {
                        break;
                      }
                    }
                  }
                  while (buf.size > _classPrivateFieldGet2(this, _size)) {
                    _classPrivateMethodGet2(this, _destroyFirstView, _destroyFirstView2).call(this);
                  }
                }
                has(view) {
                  return _classPrivateFieldGet2(this, _buf).has(view);
                }
                [_Symbol$iterator]() {
                  return _classPrivateFieldGet2(this, _buf).keys();
                }
              }
              exports3.PDFPageViewBuffer = PDFPageViewBuffer;
              function _destroyFirstView2() {
                const firstView = _classPrivateFieldGet2(this, _buf).keys().next().value;
                firstView === null || firstView === void 0 ? void 0 : firstView.destroy();
                _classPrivateFieldGet2(this, _buf).delete(firstView);
              }
              var _buffer = /* @__PURE__ */ new WeakMap();
              var _annotationEditorMode = /* @__PURE__ */ new WeakMap();
              var _annotationEditorUIManager = /* @__PURE__ */ new WeakMap();
              var _annotationMode = /* @__PURE__ */ new WeakMap();
              var _enablePermissions = /* @__PURE__ */ new WeakMap();
              var _previousContainerHeight = /* @__PURE__ */ new WeakMap();
              var _scrollModePageState = /* @__PURE__ */ new WeakMap();
              var _onVisibilityChange = /* @__PURE__ */ new WeakMap();
              var _initializePermissions = /* @__PURE__ */ new WeakSet();
              var _onePageRenderedOrForceFetch = /* @__PURE__ */ new WeakSet();
              var _ensurePageViewVisible = /* @__PURE__ */ new WeakSet();
              var _scrollIntoView = /* @__PURE__ */ new WeakSet();
              var _isSameScale = /* @__PURE__ */ new WeakSet();
              var _resetCurrentPageView = /* @__PURE__ */ new WeakSet();
              var _ensurePdfPageLoaded = /* @__PURE__ */ new WeakSet();
              var _getScrollAhead = /* @__PURE__ */ new WeakSet();
              var _toggleLoadingIconSpinner = /* @__PURE__ */ new WeakSet();
              class BaseViewer {
                constructor(options) {
                  var _this$container, _this$viewer, _options$textLayerMod, _options$annotationMo, _options$annotationEd;
                  _classPrivateMethodInitSpec2(this, _toggleLoadingIconSpinner);
                  _classPrivateMethodInitSpec2(this, _getScrollAhead);
                  _classPrivateMethodInitSpec2(this, _ensurePdfPageLoaded);
                  _classPrivateMethodInitSpec2(this, _resetCurrentPageView);
                  _classPrivateMethodInitSpec2(this, _isSameScale);
                  _classPrivateMethodInitSpec2(this, _scrollIntoView);
                  _classPrivateMethodInitSpec2(this, _ensurePageViewVisible);
                  _classPrivateMethodInitSpec2(this, _onePageRenderedOrForceFetch);
                  _classPrivateMethodInitSpec2(this, _initializePermissions);
                  _classPrivateFieldInitSpec2(this, _buffer, {
                    writable: true,
                    value: null
                  });
                  _classPrivateFieldInitSpec2(this, _annotationEditorMode, {
                    writable: true,
                    value: _pdfjsLib.AnnotationEditorType.DISABLE
                  });
                  _classPrivateFieldInitSpec2(this, _annotationEditorUIManager, {
                    writable: true,
                    value: null
                  });
                  _classPrivateFieldInitSpec2(this, _annotationMode, {
                    writable: true,
                    value: _pdfjsLib.AnnotationMode.ENABLE_FORMS
                  });
                  _classPrivateFieldInitSpec2(this, _enablePermissions, {
                    writable: true,
                    value: false
                  });
                  _classPrivateFieldInitSpec2(this, _previousContainerHeight, {
                    writable: true,
                    value: 0
                  });
                  _classPrivateFieldInitSpec2(this, _scrollModePageState, {
                    writable: true,
                    value: null
                  });
                  _classPrivateFieldInitSpec2(this, _onVisibilityChange, {
                    writable: true,
                    value: null
                  });
                  if (this.constructor === BaseViewer) {
                    throw new Error("Cannot initialize BaseViewer.");
                  }
                  const viewerVersion = "2.16.105";
                  if (_pdfjsLib.version !== viewerVersion) {
                    throw new Error(`The API version "${_pdfjsLib.version}" does not match the Viewer version "${viewerVersion}".`);
                  }
                  this.container = options.container;
                  this.viewer = options.viewer || options.container.firstElementChild;
                  if (!(((_this$container = this.container) === null || _this$container === void 0 ? void 0 : _this$container.tagName.toUpperCase()) === "DIV" && ((_this$viewer = this.viewer) === null || _this$viewer === void 0 ? void 0 : _this$viewer.tagName.toUpperCase()) === "DIV")) {
                    throw new Error("Invalid `container` and/or `viewer` option.");
                  }
                  if (this.container.offsetParent && getComputedStyle(this.container).position !== "absolute") {
                    throw new Error("The `container` must be absolutely positioned.");
                  }
                  this.eventBus = options.eventBus;
                  this.linkService = options.linkService || new _pdf_link_service.SimpleLinkService();
                  this.downloadManager = options.downloadManager || null;
                  this.findController = options.findController || null;
                  this._scriptingManager = options.scriptingManager || null;
                  this.removePageBorders = options.removePageBorders || false;
                  this.textLayerMode = (_options$textLayerMod = options.textLayerMode) !== null && _options$textLayerMod !== void 0 ? _options$textLayerMod : _ui_utils.TextLayerMode.ENABLE;
                  _classPrivateFieldSet2(this, _annotationMode, (_options$annotationMo = options.annotationMode) !== null && _options$annotationMo !== void 0 ? _options$annotationMo : _pdfjsLib.AnnotationMode.ENABLE_FORMS);
                  _classPrivateFieldSet2(this, _annotationEditorMode, (_options$annotationEd = options.annotationEditorMode) !== null && _options$annotationEd !== void 0 ? _options$annotationEd : _pdfjsLib.AnnotationEditorType.DISABLE);
                  this.imageResourcesPath = options.imageResourcesPath || "";
                  this.enablePrintAutoRotate = options.enablePrintAutoRotate || false;
                  this.renderer = options.renderer || _ui_utils.RendererType.CANVAS;
                  this.useOnlyCssZoom = options.useOnlyCssZoom || false;
                  this.maxCanvasPixels = options.maxCanvasPixels;
                  this.l10n = options.l10n || _l10n_utils.NullL10n;
                  _classPrivateFieldSet2(this, _enablePermissions, options.enablePermissions || false);
                  this.pageColors = options.pageColors || null;
                  if (this.pageColors && !(CSS.supports("color", this.pageColors.background) && CSS.supports("color", this.pageColors.foreground))) {
                    if (this.pageColors.background || this.pageColors.foreground) {
                      console.warn("BaseViewer: Ignoring `pageColors`-option, since the browser doesn't support the values used.");
                    }
                    this.pageColors = null;
                  }
                  this.defaultRenderingQueue = !options.renderingQueue;
                  if (this.defaultRenderingQueue) {
                    this.renderingQueue = new _pdf_rendering_queue.PDFRenderingQueue();
                    this.renderingQueue.setViewer(this);
                  } else {
                    this.renderingQueue = options.renderingQueue;
                  }
                  this.scroll = (0, _ui_utils.watchScroll)(this.container, this._scrollUpdate.bind(this));
                  this.presentationModeState = _ui_utils.PresentationModeState.UNKNOWN;
                  this._onBeforeDraw = this._onAfterDraw = null;
                  this._resetView();
                  if (this.removePageBorders) {
                    this.viewer.classList.add("removePageBorders");
                  }
                  this.updateContainerHeightCss();
                }
                get pagesCount() {
                  return this._pages.length;
                }
                getPageView(index) {
                  return this._pages[index];
                }
                get pageViewsReady() {
                  if (!this._pagesCapability.settled) {
                    return false;
                  }
                  return this._pages.every(function(pageView) {
                    return pageView === null || pageView === void 0 ? void 0 : pageView.pdfPage;
                  });
                }
                get renderForms() {
                  return _classPrivateFieldGet2(this, _annotationMode) === _pdfjsLib.AnnotationMode.ENABLE_FORMS;
                }
                get enableScripting() {
                  return !!this._scriptingManager;
                }
                get currentPageNumber() {
                  return this._currentPageNumber;
                }
                set currentPageNumber(val) {
                  if (!Number.isInteger(val)) {
                    throw new Error("Invalid page number.");
                  }
                  if (!this.pdfDocument) {
                    return;
                  }
                  if (!this._setCurrentPageNumber(val, true)) {
                    console.error(`currentPageNumber: "${val}" is not a valid page.`);
                  }
                }
                _setCurrentPageNumber(val) {
                  var _this$_pageLabels, _this$_pageLabels2;
                  let resetCurrentPageView = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                  if (this._currentPageNumber === val) {
                    if (resetCurrentPageView) {
                      _classPrivateMethodGet2(this, _resetCurrentPageView, _resetCurrentPageView2).call(this);
                    }
                    return true;
                  }
                  if (!(0 < val && val <= this.pagesCount)) {
                    return false;
                  }
                  const previous = this._currentPageNumber;
                  this._currentPageNumber = val;
                  this.eventBus.dispatch("pagechanging", {
                    source: this,
                    pageNumber: val,
                    pageLabel: (_this$_pageLabels = (_this$_pageLabels2 = this._pageLabels) === null || _this$_pageLabels2 === void 0 ? void 0 : _this$_pageLabels2[val - 1]) !== null && _this$_pageLabels !== void 0 ? _this$_pageLabels : null,
                    previous
                  });
                  if (resetCurrentPageView) {
                    _classPrivateMethodGet2(this, _resetCurrentPageView, _resetCurrentPageView2).call(this);
                  }
                  return true;
                }
                get currentPageLabel() {
                  var _this$_pageLabels3, _this$_pageLabels4;
                  return (_this$_pageLabels3 = (_this$_pageLabels4 = this._pageLabels) === null || _this$_pageLabels4 === void 0 ? void 0 : _this$_pageLabels4[this._currentPageNumber - 1]) !== null && _this$_pageLabels3 !== void 0 ? _this$_pageLabels3 : null;
                }
                set currentPageLabel(val) {
                  if (!this.pdfDocument) {
                    return;
                  }
                  let page = val | 0;
                  if (this._pageLabels) {
                    const i = this._pageLabels.indexOf(val);
                    if (i >= 0) {
                      page = i + 1;
                    }
                  }
                  if (!this._setCurrentPageNumber(page, true)) {
                    console.error(`currentPageLabel: "${val}" is not a valid page.`);
                  }
                }
                get currentScale() {
                  return this._currentScale !== _ui_utils.UNKNOWN_SCALE ? this._currentScale : _ui_utils.DEFAULT_SCALE;
                }
                set currentScale(val) {
                  if (isNaN(val)) {
                    throw new Error("Invalid numeric scale.");
                  }
                  if (!this.pdfDocument) {
                    return;
                  }
                  this._setScale(val, false);
                }
                get currentScaleValue() {
                  return this._currentScaleValue;
                }
                set currentScaleValue(val) {
                  if (!this.pdfDocument) {
                    return;
                  }
                  this._setScale(val, false);
                }
                get pagesRotation() {
                  return this._pagesRotation;
                }
                set pagesRotation(rotation) {
                  if (!(0, _ui_utils.isValidRotation)(rotation)) {
                    throw new Error("Invalid pages rotation angle.");
                  }
                  if (!this.pdfDocument) {
                    return;
                  }
                  rotation %= 360;
                  if (rotation < 0) {
                    rotation += 360;
                  }
                  if (this._pagesRotation === rotation) {
                    return;
                  }
                  this._pagesRotation = rotation;
                  const pageNumber = this._currentPageNumber;
                  const updateArgs = {
                    rotation
                  };
                  for (const pageView of this._pages) {
                    pageView.update(updateArgs);
                  }
                  if (this._currentScaleValue) {
                    this._setScale(this._currentScaleValue, true);
                  }
                  this.eventBus.dispatch("rotationchanging", {
                    source: this,
                    pagesRotation: rotation,
                    pageNumber
                  });
                  if (this.defaultRenderingQueue) {
                    this.update();
                  }
                }
                get firstPagePromise() {
                  return this.pdfDocument ? this._firstPageCapability.promise : null;
                }
                get onePageRendered() {
                  return this.pdfDocument ? this._onePageRenderedCapability.promise : null;
                }
                get pagesPromise() {
                  return this.pdfDocument ? this._pagesCapability.promise : null;
                }
                setDocument(pdfDocument) {
                  if (this.pdfDocument) {
                    this.eventBus.dispatch("pagesdestroy", {
                      source: this
                    });
                    this._cancelRendering();
                    this._resetView();
                    if (this.findController) {
                      this.findController.setDocument(null);
                    }
                    if (this._scriptingManager) {
                      this._scriptingManager.setDocument(null);
                    }
                    if (_classPrivateFieldGet2(this, _annotationEditorUIManager)) {
                      _classPrivateFieldGet2(this, _annotationEditorUIManager).destroy();
                      _classPrivateFieldSet2(this, _annotationEditorUIManager, null);
                    }
                  }
                  this.pdfDocument = pdfDocument;
                  if (!pdfDocument) {
                    return;
                  }
                  const isPureXfa = pdfDocument.isPureXfa;
                  const pagesCount = pdfDocument.numPages;
                  const firstPagePromise = pdfDocument.getPage(1);
                  const optionalContentConfigPromise = pdfDocument.getOptionalContentConfig();
                  const permissionsPromise = _classPrivateFieldGet2(this, _enablePermissions) ? pdfDocument.getPermissions() : Promise.resolve();
                  if (pagesCount > PagesCountLimit.FORCE_SCROLL_MODE_PAGE) {
                    console.warn("Forcing PAGE-scrolling for performance reasons, given the length of the document.");
                    const mode = this._scrollMode = _ui_utils.ScrollMode.PAGE;
                    this.eventBus.dispatch("scrollmodechanged", {
                      source: this,
                      mode
                    });
                  }
                  this._pagesCapability.promise.then(() => {
                    this.eventBus.dispatch("pagesloaded", {
                      source: this,
                      pagesCount
                    });
                  }, () => {
                  });
                  this._onBeforeDraw = (evt) => {
                    const pageView = this._pages[evt.pageNumber - 1];
                    if (!pageView) {
                      return;
                    }
                    _classPrivateFieldGet2(this, _buffer).push(pageView);
                  };
                  this.eventBus._on("pagerender", this._onBeforeDraw);
                  this._onAfterDraw = (evt) => {
                    if (evt.cssTransform || this._onePageRenderedCapability.settled) {
                      return;
                    }
                    this._onePageRenderedCapability.resolve({
                      timestamp: evt.timestamp
                    });
                    this.eventBus._off("pagerendered", this._onAfterDraw);
                    this._onAfterDraw = null;
                    if (_classPrivateFieldGet2(this, _onVisibilityChange)) {
                      document.removeEventListener("visibilitychange", _classPrivateFieldGet2(this, _onVisibilityChange));
                      _classPrivateFieldSet2(this, _onVisibilityChange, null);
                    }
                  };
                  this.eventBus._on("pagerendered", this._onAfterDraw);
                  Promise.all([firstPagePromise, permissionsPromise]).then((_ref) => {
                    let [firstPdfPage, permissions] = _ref;
                    if (pdfDocument !== this.pdfDocument) {
                      return;
                    }
                    this._firstPageCapability.resolve(firstPdfPage);
                    this._optionalContentConfigPromise = optionalContentConfigPromise;
                    const {
                      annotationEditorMode,
                      annotationMode,
                      textLayerMode
                    } = _classPrivateMethodGet2(this, _initializePermissions, _initializePermissions2).call(this, permissions);
                    if (annotationEditorMode !== _pdfjsLib.AnnotationEditorType.DISABLE) {
                      const mode = annotationEditorMode;
                      if (isPureXfa) {
                        console.warn("Warning: XFA-editing is not implemented.");
                      } else if (isValidAnnotationEditorMode(mode)) {
                        _classPrivateFieldSet2(this, _annotationEditorUIManager, new _pdfjsLib.AnnotationEditorUIManager(this.container, this.eventBus));
                        if (mode !== _pdfjsLib.AnnotationEditorType.NONE) {
                          _classPrivateFieldGet2(this, _annotationEditorUIManager).updateMode(mode);
                        }
                      } else {
                        console.error(`Invalid AnnotationEditor mode: ${mode}`);
                      }
                    }
                    const viewerElement = this._scrollMode === _ui_utils.ScrollMode.PAGE ? null : this.viewer;
                    const scale = this.currentScale;
                    const viewport = firstPdfPage.getViewport({
                      scale: scale * _pdfjsLib.PixelsPerInch.PDF_TO_CSS_UNITS
                    });
                    const textLayerFactory = textLayerMode !== _ui_utils.TextLayerMode.DISABLE && !isPureXfa ? this : null;
                    const annotationLayerFactory = annotationMode !== _pdfjsLib.AnnotationMode.DISABLE ? this : null;
                    const xfaLayerFactory = isPureXfa ? this : null;
                    const annotationEditorLayerFactory = _classPrivateFieldGet2(this, _annotationEditorUIManager) ? this : null;
                    for (let pageNum = 1; pageNum <= pagesCount; ++pageNum) {
                      const pageView = new _pdf_page_view.PDFPageView({
                        container: viewerElement,
                        eventBus: this.eventBus,
                        id: pageNum,
                        scale,
                        defaultViewport: viewport.clone(),
                        optionalContentConfigPromise,
                        renderingQueue: this.renderingQueue,
                        textLayerFactory,
                        textLayerMode,
                        annotationLayerFactory,
                        annotationMode,
                        xfaLayerFactory,
                        annotationEditorLayerFactory,
                        textHighlighterFactory: this,
                        structTreeLayerFactory: this,
                        imageResourcesPath: this.imageResourcesPath,
                        renderer: this.renderer,
                        useOnlyCssZoom: this.useOnlyCssZoom,
                        maxCanvasPixels: this.maxCanvasPixels,
                        pageColors: this.pageColors,
                        l10n: this.l10n
                      });
                      this._pages.push(pageView);
                    }
                    const firstPageView = this._pages[0];
                    if (firstPageView) {
                      firstPageView.setPdfPage(firstPdfPage);
                      this.linkService.cachePageRef(1, firstPdfPage.ref);
                    }
                    if (this._scrollMode === _ui_utils.ScrollMode.PAGE) {
                      _classPrivateMethodGet2(this, _ensurePageViewVisible, _ensurePageViewVisible2).call(this);
                    } else if (this._spreadMode !== _ui_utils.SpreadMode.NONE) {
                      this._updateSpreadMode();
                    }
                    _classPrivateMethodGet2(this, _onePageRenderedOrForceFetch, _onePageRenderedOrForceFetch2).call(this).then(async () => {
                      if (this.findController) {
                        this.findController.setDocument(pdfDocument);
                      }
                      if (this._scriptingManager) {
                        this._scriptingManager.setDocument(pdfDocument);
                      }
                      if (_classPrivateFieldGet2(this, _annotationEditorUIManager)) {
                        this.eventBus.dispatch("annotationeditormodechanged", {
                          source: this,
                          mode: _classPrivateFieldGet2(this, _annotationEditorMode)
                        });
                      }
                      if (pdfDocument.loadingParams.disableAutoFetch || pagesCount > PagesCountLimit.FORCE_LAZY_PAGE_INIT) {
                        this._pagesCapability.resolve();
                        return;
                      }
                      let getPagesLeft = pagesCount - 1;
                      if (getPagesLeft <= 0) {
                        this._pagesCapability.resolve();
                        return;
                      }
                      for (let pageNum = 2; pageNum <= pagesCount; ++pageNum) {
                        const promise = pdfDocument.getPage(pageNum).then((pdfPage) => {
                          const pageView = this._pages[pageNum - 1];
                          if (!pageView.pdfPage) {
                            pageView.setPdfPage(pdfPage);
                          }
                          this.linkService.cachePageRef(pageNum, pdfPage.ref);
                          if (--getPagesLeft === 0) {
                            this._pagesCapability.resolve();
                          }
                        }, (reason) => {
                          console.error(`Unable to get page ${pageNum} to initialize viewer`, reason);
                          if (--getPagesLeft === 0) {
                            this._pagesCapability.resolve();
                          }
                        });
                        if (pageNum % PagesCountLimit.PAUSE_EAGER_PAGE_INIT === 0) {
                          await promise;
                        }
                      }
                    });
                    this.eventBus.dispatch("pagesinit", {
                      source: this
                    });
                    pdfDocument.getMetadata().then((_ref2) => {
                      let {
                        info
                      } = _ref2;
                      if (pdfDocument !== this.pdfDocument) {
                        return;
                      }
                      if (info.Language) {
                        this.viewer.lang = info.Language;
                      }
                    });
                    if (this.defaultRenderingQueue) {
                      this.update();
                    }
                  }).catch((reason) => {
                    console.error("Unable to initialize viewer", reason);
                    this._pagesCapability.reject(reason);
                  });
                }
                setPageLabels(labels) {
                  if (!this.pdfDocument) {
                    return;
                  }
                  if (!labels) {
                    this._pageLabels = null;
                  } else if (!(Array.isArray(labels) && this.pdfDocument.numPages === labels.length)) {
                    this._pageLabels = null;
                    console.error(`setPageLabels: Invalid page labels.`);
                  } else {
                    this._pageLabels = labels;
                  }
                  for (let i = 0, ii = this._pages.length; i < ii; i++) {
                    var _this$_pageLabels$i, _this$_pageLabels5;
                    this._pages[i].setPageLabel((_this$_pageLabels$i = (_this$_pageLabels5 = this._pageLabels) === null || _this$_pageLabels5 === void 0 ? void 0 : _this$_pageLabels5[i]) !== null && _this$_pageLabels$i !== void 0 ? _this$_pageLabels$i : null);
                  }
                }
                _resetView() {
                  this._pages = [];
                  this._currentPageNumber = 1;
                  this._currentScale = _ui_utils.UNKNOWN_SCALE;
                  this._currentScaleValue = null;
                  this._pageLabels = null;
                  _classPrivateFieldSet2(this, _buffer, new PDFPageViewBuffer(DEFAULT_CACHE_SIZE));
                  this._location = null;
                  this._pagesRotation = 0;
                  this._optionalContentConfigPromise = null;
                  this._firstPageCapability = (0, _pdfjsLib.createPromiseCapability)();
                  this._onePageRenderedCapability = (0, _pdfjsLib.createPromiseCapability)();
                  this._pagesCapability = (0, _pdfjsLib.createPromiseCapability)();
                  this._scrollMode = _ui_utils.ScrollMode.VERTICAL;
                  this._previousScrollMode = _ui_utils.ScrollMode.UNKNOWN;
                  this._spreadMode = _ui_utils.SpreadMode.NONE;
                  _classPrivateFieldSet2(this, _scrollModePageState, {
                    previousPageNumber: 1,
                    scrollDown: true,
                    pages: []
                  });
                  if (this._onBeforeDraw) {
                    this.eventBus._off("pagerender", this._onBeforeDraw);
                    this._onBeforeDraw = null;
                  }
                  if (this._onAfterDraw) {
                    this.eventBus._off("pagerendered", this._onAfterDraw);
                    this._onAfterDraw = null;
                  }
                  if (_classPrivateFieldGet2(this, _onVisibilityChange)) {
                    document.removeEventListener("visibilitychange", _classPrivateFieldGet2(this, _onVisibilityChange));
                    _classPrivateFieldSet2(this, _onVisibilityChange, null);
                  }
                  this.viewer.textContent = "";
                  this._updateScrollMode();
                  this.viewer.removeAttribute("lang");
                  this.viewer.classList.remove(ENABLE_PERMISSIONS_CLASS);
                }
                _scrollUpdate() {
                  if (this.pagesCount === 0) {
                    return;
                  }
                  this.update();
                }
                _setScaleUpdatePages(newScale, newValue) {
                  let noScroll = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                  let preset = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
                  this._currentScaleValue = newValue.toString();
                  if (_classPrivateMethodGet2(this, _isSameScale, _isSameScale2).call(this, newScale)) {
                    if (preset) {
                      this.eventBus.dispatch("scalechanging", {
                        source: this,
                        scale: newScale,
                        presetValue: newValue
                      });
                    }
                    return;
                  }
                  _ui_utils.docStyle.setProperty("--scale-factor", newScale * _pdfjsLib.PixelsPerInch.PDF_TO_CSS_UNITS);
                  const updateArgs = {
                    scale: newScale
                  };
                  for (const pageView of this._pages) {
                    pageView.update(updateArgs);
                  }
                  this._currentScale = newScale;
                  if (!noScroll) {
                    let page = this._currentPageNumber, dest;
                    if (this._location && !(this.isInPresentationMode || this.isChangingPresentationMode)) {
                      page = this._location.pageNumber;
                      dest = [null, {
                        name: "XYZ"
                      }, this._location.left, this._location.top, null];
                    }
                    this.scrollPageIntoView({
                      pageNumber: page,
                      destArray: dest,
                      allowNegativeOffset: true
                    });
                  }
                  this.eventBus.dispatch("scalechanging", {
                    source: this,
                    scale: newScale,
                    presetValue: preset ? newValue : void 0
                  });
                  if (this.defaultRenderingQueue) {
                    this.update();
                  }
                  this.updateContainerHeightCss();
                }
                get _pageWidthScaleFactor() {
                  if (this._spreadMode !== _ui_utils.SpreadMode.NONE && this._scrollMode !== _ui_utils.ScrollMode.HORIZONTAL) {
                    return 2;
                  }
                  return 1;
                }
                _setScale(value) {
                  let noScroll = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                  let scale = parseFloat(value);
                  if (scale > 0) {
                    this._setScaleUpdatePages(scale, value, noScroll, false);
                  } else {
                    const currentPage = this._pages[this._currentPageNumber - 1];
                    if (!currentPage) {
                      return;
                    }
                    let hPadding = _ui_utils.SCROLLBAR_PADDING, vPadding = _ui_utils.VERTICAL_PADDING;
                    if (this.isInPresentationMode) {
                      hPadding = vPadding = 4;
                    } else if (this.removePageBorders) {
                      hPadding = vPadding = 0;
                    } else if (this._scrollMode === _ui_utils.ScrollMode.HORIZONTAL) {
                      [hPadding, vPadding] = [vPadding, hPadding];
                    }
                    const pageWidthScale = (this.container.clientWidth - hPadding) / currentPage.width * currentPage.scale / this._pageWidthScaleFactor;
                    const pageHeightScale = (this.container.clientHeight - vPadding) / currentPage.height * currentPage.scale;
                    switch (value) {
                      case "page-actual":
                        scale = 1;
                        break;
                      case "page-width":
                        scale = pageWidthScale;
                        break;
                      case "page-height":
                        scale = pageHeightScale;
                        break;
                      case "page-fit":
                        scale = Math.min(pageWidthScale, pageHeightScale);
                        break;
                      case "auto":
                        const horizontalScale = (0, _ui_utils.isPortraitOrientation)(currentPage) ? pageWidthScale : Math.min(pageHeightScale, pageWidthScale);
                        scale = Math.min(_ui_utils.MAX_AUTO_SCALE, horizontalScale);
                        break;
                      default:
                        console.error(`_setScale: "${value}" is an unknown zoom value.`);
                        return;
                    }
                    this._setScaleUpdatePages(scale, value, noScroll, true);
                  }
                }
                pageLabelToPageNumber(label) {
                  if (!this._pageLabels) {
                    return null;
                  }
                  const i = this._pageLabels.indexOf(label);
                  if (i < 0) {
                    return null;
                  }
                  return i + 1;
                }
                scrollPageIntoView(_ref3) {
                  let {
                    pageNumber,
                    destArray = null,
                    allowNegativeOffset = false,
                    ignoreDestinationZoom = false
                  } = _ref3;
                  if (!this.pdfDocument) {
                    return;
                  }
                  const pageView = Number.isInteger(pageNumber) && this._pages[pageNumber - 1];
                  if (!pageView) {
                    console.error(`scrollPageIntoView: "${pageNumber}" is not a valid pageNumber parameter.`);
                    return;
                  }
                  if (this.isInPresentationMode || !destArray) {
                    this._setCurrentPageNumber(pageNumber, true);
                    return;
                  }
                  let x = 0, y = 0;
                  let width = 0, height = 0, widthScale, heightScale;
                  const changeOrientation = pageView.rotation % 180 !== 0;
                  const pageWidth = (changeOrientation ? pageView.height : pageView.width) / pageView.scale / _pdfjsLib.PixelsPerInch.PDF_TO_CSS_UNITS;
                  const pageHeight = (changeOrientation ? pageView.width : pageView.height) / pageView.scale / _pdfjsLib.PixelsPerInch.PDF_TO_CSS_UNITS;
                  let scale = 0;
                  switch (destArray[1].name) {
                    case "XYZ":
                      x = destArray[2];
                      y = destArray[3];
                      scale = destArray[4];
                      x = x !== null ? x : 0;
                      y = y !== null ? y : pageHeight;
                      break;
                    case "Fit":
                    case "FitB":
                      scale = "page-fit";
                      break;
                    case "FitH":
                    case "FitBH":
                      y = destArray[2];
                      scale = "page-width";
                      if (y === null && this._location) {
                        x = this._location.left;
                        y = this._location.top;
                      } else if (typeof y !== "number" || y < 0) {
                        y = pageHeight;
                      }
                      break;
                    case "FitV":
                    case "FitBV":
                      x = destArray[2];
                      width = pageWidth;
                      height = pageHeight;
                      scale = "page-height";
                      break;
                    case "FitR":
                      x = destArray[2];
                      y = destArray[3];
                      width = destArray[4] - x;
                      height = destArray[5] - y;
                      const hPadding = this.removePageBorders ? 0 : _ui_utils.SCROLLBAR_PADDING;
                      const vPadding = this.removePageBorders ? 0 : _ui_utils.VERTICAL_PADDING;
                      widthScale = (this.container.clientWidth - hPadding) / width / _pdfjsLib.PixelsPerInch.PDF_TO_CSS_UNITS;
                      heightScale = (this.container.clientHeight - vPadding) / height / _pdfjsLib.PixelsPerInch.PDF_TO_CSS_UNITS;
                      scale = Math.min(Math.abs(widthScale), Math.abs(heightScale));
                      break;
                    default:
                      console.error(`scrollPageIntoView: "${destArray[1].name}" is not a valid destination type.`);
                      return;
                  }
                  if (!ignoreDestinationZoom) {
                    if (scale && scale !== this._currentScale) {
                      this.currentScaleValue = scale;
                    } else if (this._currentScale === _ui_utils.UNKNOWN_SCALE) {
                      this.currentScaleValue = _ui_utils.DEFAULT_SCALE_VALUE;
                    }
                  }
                  if (scale === "page-fit" && !destArray[4]) {
                    _classPrivateMethodGet2(this, _scrollIntoView, _scrollIntoView2).call(this, pageView);
                    return;
                  }
                  const boundingRect = [pageView.viewport.convertToViewportPoint(x, y), pageView.viewport.convertToViewportPoint(x + width, y + height)];
                  let left = Math.min(boundingRect[0][0], boundingRect[1][0]);
                  let top = Math.min(boundingRect[0][1], boundingRect[1][1]);
                  if (!allowNegativeOffset) {
                    left = Math.max(left, 0);
                    top = Math.max(top, 0);
                  }
                  _classPrivateMethodGet2(this, _scrollIntoView, _scrollIntoView2).call(this, pageView, {
                    left,
                    top
                  });
                }
                _updateLocation(firstPage) {
                  const currentScale = this._currentScale;
                  const currentScaleValue = this._currentScaleValue;
                  const normalizedScaleValue = parseFloat(currentScaleValue) === currentScale ? Math.round(currentScale * 1e4) / 100 : currentScaleValue;
                  const pageNumber = firstPage.id;
                  const currentPageView = this._pages[pageNumber - 1];
                  const container = this.container;
                  const topLeft = currentPageView.getPagePoint(container.scrollLeft - firstPage.x, container.scrollTop - firstPage.y);
                  const intLeft = Math.round(topLeft[0]);
                  const intTop = Math.round(topLeft[1]);
                  let pdfOpenParams = `#page=${pageNumber}`;
                  if (!this.isInPresentationMode) {
                    pdfOpenParams += `&zoom=${normalizedScaleValue},${intLeft},${intTop}`;
                  }
                  this._location = {
                    pageNumber,
                    scale: normalizedScaleValue,
                    top: intTop,
                    left: intLeft,
                    rotation: this._pagesRotation,
                    pdfOpenParams
                  };
                }
                update() {
                  const visible = this._getVisiblePages();
                  const visiblePages = visible.views, numVisiblePages = visiblePages.length;
                  if (numVisiblePages === 0) {
                    return;
                  }
                  const newCacheSize = Math.max(DEFAULT_CACHE_SIZE, 2 * numVisiblePages + 1);
                  _classPrivateFieldGet2(this, _buffer).resize(newCacheSize, visible.ids);
                  this.renderingQueue.renderHighestPriority(visible);
                  const isSimpleLayout = this._spreadMode === _ui_utils.SpreadMode.NONE && (this._scrollMode === _ui_utils.ScrollMode.PAGE || this._scrollMode === _ui_utils.ScrollMode.VERTICAL);
                  const currentId = this._currentPageNumber;
                  let stillFullyVisible = false;
                  for (const page of visiblePages) {
                    if (page.percent < 100) {
                      break;
                    }
                    if (page.id === currentId && isSimpleLayout) {
                      stillFullyVisible = true;
                      break;
                    }
                  }
                  this._setCurrentPageNumber(stillFullyVisible ? currentId : visiblePages[0].id);
                  this._updateLocation(visible.first);
                  this.eventBus.dispatch("updateviewarea", {
                    source: this,
                    location: this._location
                  });
                }
                containsElement(element) {
                  return this.container.contains(element);
                }
                focus() {
                  this.container.focus();
                }
                get _isContainerRtl() {
                  return getComputedStyle(this.container).direction === "rtl";
                }
                get isInPresentationMode() {
                  return this.presentationModeState === _ui_utils.PresentationModeState.FULLSCREEN;
                }
                get isChangingPresentationMode() {
                  return this.presentationModeState === _ui_utils.PresentationModeState.CHANGING;
                }
                get isHorizontalScrollbarEnabled() {
                  return this.isInPresentationMode ? false : this.container.scrollWidth > this.container.clientWidth;
                }
                get isVerticalScrollbarEnabled() {
                  return this.isInPresentationMode ? false : this.container.scrollHeight > this.container.clientHeight;
                }
                _getVisiblePages() {
                  const views = this._scrollMode === _ui_utils.ScrollMode.PAGE ? _classPrivateFieldGet2(this, _scrollModePageState).pages : this._pages, horizontal = this._scrollMode === _ui_utils.ScrollMode.HORIZONTAL, rtl = horizontal && this._isContainerRtl;
                  return (0, _ui_utils.getVisibleElements)({
                    scrollEl: this.container,
                    views,
                    sortByVisibility: true,
                    horizontal,
                    rtl
                  });
                }
                isPageVisible(pageNumber) {
                  if (!this.pdfDocument) {
                    return false;
                  }
                  if (!(Number.isInteger(pageNumber) && pageNumber > 0 && pageNumber <= this.pagesCount)) {
                    console.error(`isPageVisible: "${pageNumber}" is not a valid page.`);
                    return false;
                  }
                  return this._getVisiblePages().ids.has(pageNumber);
                }
                isPageCached(pageNumber) {
                  if (!this.pdfDocument) {
                    return false;
                  }
                  if (!(Number.isInteger(pageNumber) && pageNumber > 0 && pageNumber <= this.pagesCount)) {
                    console.error(`isPageCached: "${pageNumber}" is not a valid page.`);
                    return false;
                  }
                  const pageView = this._pages[pageNumber - 1];
                  return _classPrivateFieldGet2(this, _buffer).has(pageView);
                }
                cleanup() {
                  for (const pageView of this._pages) {
                    if (pageView.renderingState !== _ui_utils.RenderingStates.FINISHED) {
                      pageView.reset();
                    }
                  }
                }
                _cancelRendering() {
                  for (const pageView of this._pages) {
                    pageView.cancelRendering();
                  }
                }
                forceRendering(currentlyVisiblePages) {
                  const visiblePages = currentlyVisiblePages || this._getVisiblePages();
                  const scrollAhead = _classPrivateMethodGet2(this, _getScrollAhead, _getScrollAhead2).call(this, visiblePages);
                  const preRenderExtra = this._spreadMode !== _ui_utils.SpreadMode.NONE && this._scrollMode !== _ui_utils.ScrollMode.HORIZONTAL;
                  const pageView = this.renderingQueue.getHighestPriority(visiblePages, this._pages, scrollAhead, preRenderExtra);
                  _classPrivateMethodGet2(this, _toggleLoadingIconSpinner, _toggleLoadingIconSpinner2).call(this, visiblePages.ids);
                  if (pageView) {
                    _classPrivateMethodGet2(this, _ensurePdfPageLoaded, _ensurePdfPageLoaded2).call(this, pageView).then(() => {
                      this.renderingQueue.renderView(pageView);
                    });
                    return true;
                  }
                  return false;
                }
                createTextLayerBuilder(_ref4) {
                  let {
                    textLayerDiv,
                    pageIndex,
                    viewport,
                    enhanceTextSelection = false,
                    eventBus,
                    highlighter,
                    accessibilityManager = null
                  } = _ref4;
                  return new _text_layer_builder.TextLayerBuilder({
                    textLayerDiv,
                    eventBus,
                    pageIndex,
                    viewport,
                    enhanceTextSelection: this.isInPresentationMode ? false : enhanceTextSelection,
                    highlighter,
                    accessibilityManager
                  });
                }
                createTextHighlighter(_ref5) {
                  let {
                    pageIndex,
                    eventBus
                  } = _ref5;
                  return new _text_highlighter.TextHighlighter({
                    eventBus,
                    pageIndex,
                    findController: this.isInPresentationMode ? null : this.findController
                  });
                }
                createAnnotationLayerBuilder(_ref6) {
                  var _this$pdfDocument, _this$pdfDocument2, _this$_scriptingManag, _this$pdfDocument3;
                  let {
                    pageDiv,
                    pdfPage,
                    annotationStorage = (_this$pdfDocument = this.pdfDocument) === null || _this$pdfDocument === void 0 ? void 0 : _this$pdfDocument.annotationStorage,
                    imageResourcesPath = "",
                    renderForms = true,
                    l10n = _l10n_utils.NullL10n,
                    enableScripting = this.enableScripting,
                    hasJSActionsPromise = (_this$pdfDocument2 = this.pdfDocument) === null || _this$pdfDocument2 === void 0 ? void 0 : _this$pdfDocument2.hasJSActions(),
                    mouseState = (_this$_scriptingManag = this._scriptingManager) === null || _this$_scriptingManag === void 0 ? void 0 : _this$_scriptingManag.mouseState,
                    fieldObjectsPromise = (_this$pdfDocument3 = this.pdfDocument) === null || _this$pdfDocument3 === void 0 ? void 0 : _this$pdfDocument3.getFieldObjects(),
                    annotationCanvasMap = null,
                    accessibilityManager = null
                  } = _ref6;
                  return new _annotation_layer_builder.AnnotationLayerBuilder({
                    pageDiv,
                    pdfPage,
                    annotationStorage,
                    imageResourcesPath,
                    renderForms,
                    linkService: this.linkService,
                    downloadManager: this.downloadManager,
                    l10n,
                    enableScripting,
                    hasJSActionsPromise,
                    mouseState,
                    fieldObjectsPromise,
                    annotationCanvasMap,
                    accessibilityManager
                  });
                }
                createAnnotationEditorLayerBuilder(_ref7) {
                  var _this$pdfDocument4;
                  let {
                    uiManager = _classPrivateFieldGet2(this, _annotationEditorUIManager),
                    pageDiv,
                    pdfPage,
                    accessibilityManager = null,
                    l10n,
                    annotationStorage = (_this$pdfDocument4 = this.pdfDocument) === null || _this$pdfDocument4 === void 0 ? void 0 : _this$pdfDocument4.annotationStorage
                  } = _ref7;
                  return new _annotation_editor_layer_builder.AnnotationEditorLayerBuilder({
                    uiManager,
                    pageDiv,
                    pdfPage,
                    annotationStorage,
                    accessibilityManager,
                    l10n
                  });
                }
                createXfaLayerBuilder(_ref8) {
                  var _this$pdfDocument5;
                  let {
                    pageDiv,
                    pdfPage,
                    annotationStorage = (_this$pdfDocument5 = this.pdfDocument) === null || _this$pdfDocument5 === void 0 ? void 0 : _this$pdfDocument5.annotationStorage
                  } = _ref8;
                  return new _xfa_layer_builder.XfaLayerBuilder({
                    pageDiv,
                    pdfPage,
                    annotationStorage,
                    linkService: this.linkService
                  });
                }
                createStructTreeLayerBuilder(_ref9) {
                  let {
                    pdfPage
                  } = _ref9;
                  return new _struct_tree_layer_builder.StructTreeLayerBuilder({
                    pdfPage
                  });
                }
                get hasEqualPageSizes() {
                  const firstPageView = this._pages[0];
                  for (let i = 1, ii = this._pages.length; i < ii; ++i) {
                    const pageView = this._pages[i];
                    if (pageView.width !== firstPageView.width || pageView.height !== firstPageView.height) {
                      return false;
                    }
                  }
                  return true;
                }
                getPagesOverview() {
                  return this._pages.map((pageView) => {
                    const viewport = pageView.pdfPage.getViewport({
                      scale: 1
                    });
                    if (!this.enablePrintAutoRotate || (0, _ui_utils.isPortraitOrientation)(viewport)) {
                      return {
                        width: viewport.width,
                        height: viewport.height,
                        rotation: viewport.rotation
                      };
                    }
                    return {
                      width: viewport.height,
                      height: viewport.width,
                      rotation: (viewport.rotation - 90) % 360
                    };
                  });
                }
                get optionalContentConfigPromise() {
                  if (!this.pdfDocument) {
                    return Promise.resolve(null);
                  }
                  if (!this._optionalContentConfigPromise) {
                    console.error("optionalContentConfigPromise: Not initialized yet.");
                    return this.pdfDocument.getOptionalContentConfig();
                  }
                  return this._optionalContentConfigPromise;
                }
                set optionalContentConfigPromise(promise) {
                  if (!(promise instanceof Promise)) {
                    throw new Error(`Invalid optionalContentConfigPromise: ${promise}`);
                  }
                  if (!this.pdfDocument) {
                    return;
                  }
                  if (!this._optionalContentConfigPromise) {
                    return;
                  }
                  this._optionalContentConfigPromise = promise;
                  const updateArgs = {
                    optionalContentConfigPromise: promise
                  };
                  for (const pageView of this._pages) {
                    pageView.update(updateArgs);
                  }
                  this.update();
                  this.eventBus.dispatch("optionalcontentconfigchanged", {
                    source: this,
                    promise
                  });
                }
                get scrollMode() {
                  return this._scrollMode;
                }
                set scrollMode(mode) {
                  if (this._scrollMode === mode) {
                    return;
                  }
                  if (!(0, _ui_utils.isValidScrollMode)(mode)) {
                    throw new Error(`Invalid scroll mode: ${mode}`);
                  }
                  if (this.pagesCount > PagesCountLimit.FORCE_SCROLL_MODE_PAGE) {
                    return;
                  }
                  this._previousScrollMode = this._scrollMode;
                  this._scrollMode = mode;
                  this.eventBus.dispatch("scrollmodechanged", {
                    source: this,
                    mode
                  });
                  this._updateScrollMode(this._currentPageNumber);
                }
                _updateScrollMode() {
                  let pageNumber = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
                  const scrollMode = this._scrollMode, viewer = this.viewer;
                  viewer.classList.toggle("scrollHorizontal", scrollMode === _ui_utils.ScrollMode.HORIZONTAL);
                  viewer.classList.toggle("scrollWrapped", scrollMode === _ui_utils.ScrollMode.WRAPPED);
                  if (!this.pdfDocument || !pageNumber) {
                    return;
                  }
                  if (scrollMode === _ui_utils.ScrollMode.PAGE) {
                    _classPrivateMethodGet2(this, _ensurePageViewVisible, _ensurePageViewVisible2).call(this);
                  } else if (this._previousScrollMode === _ui_utils.ScrollMode.PAGE) {
                    this._updateSpreadMode();
                  }
                  if (this._currentScaleValue && isNaN(this._currentScaleValue)) {
                    this._setScale(this._currentScaleValue, true);
                  }
                  this._setCurrentPageNumber(pageNumber, true);
                  this.update();
                }
                get spreadMode() {
                  return this._spreadMode;
                }
                set spreadMode(mode) {
                  if (this._spreadMode === mode) {
                    return;
                  }
                  if (!(0, _ui_utils.isValidSpreadMode)(mode)) {
                    throw new Error(`Invalid spread mode: ${mode}`);
                  }
                  this._spreadMode = mode;
                  this.eventBus.dispatch("spreadmodechanged", {
                    source: this,
                    mode
                  });
                  this._updateSpreadMode(this._currentPageNumber);
                }
                _updateSpreadMode() {
                  let pageNumber = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
                  if (!this.pdfDocument) {
                    return;
                  }
                  const viewer = this.viewer, pages = this._pages;
                  if (this._scrollMode === _ui_utils.ScrollMode.PAGE) {
                    _classPrivateMethodGet2(this, _ensurePageViewVisible, _ensurePageViewVisible2).call(this);
                  } else {
                    viewer.textContent = "";
                    if (this._spreadMode === _ui_utils.SpreadMode.NONE) {
                      for (const pageView of this._pages) {
                        viewer.append(pageView.div);
                      }
                    } else {
                      const parity = this._spreadMode - 1;
                      let spread = null;
                      for (let i = 0, ii = pages.length; i < ii; ++i) {
                        if (spread === null) {
                          spread = document.createElement("div");
                          spread.className = "spread";
                          viewer.append(spread);
                        } else if (i % 2 === parity) {
                          spread = spread.cloneNode(false);
                          viewer.append(spread);
                        }
                        spread.append(pages[i].div);
                      }
                    }
                  }
                  if (!pageNumber) {
                    return;
                  }
                  if (this._currentScaleValue && isNaN(this._currentScaleValue)) {
                    this._setScale(this._currentScaleValue, true);
                  }
                  this._setCurrentPageNumber(pageNumber, true);
                  this.update();
                }
                _getPageAdvance(currentPageNumber) {
                  let previous = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                  switch (this._scrollMode) {
                    case _ui_utils.ScrollMode.WRAPPED: {
                      const {
                        views
                      } = this._getVisiblePages(), pageLayout = /* @__PURE__ */ new Map();
                      for (const {
                        id,
                        y,
                        percent,
                        widthPercent
                      } of views) {
                        if (percent === 0 || widthPercent < 100) {
                          continue;
                        }
                        let yArray = pageLayout.get(y);
                        if (!yArray) {
                          pageLayout.set(y, yArray || (yArray = []));
                        }
                        yArray.push(id);
                      }
                      for (const yArray of pageLayout.values()) {
                        const currentIndex = yArray.indexOf(currentPageNumber);
                        if (currentIndex === -1) {
                          continue;
                        }
                        const numPages = yArray.length;
                        if (numPages === 1) {
                          break;
                        }
                        if (previous) {
                          for (let i = currentIndex - 1, ii = 0; i >= ii; i--) {
                            const currentId = yArray[i], expectedId = yArray[i + 1] - 1;
                            if (currentId < expectedId) {
                              return currentPageNumber - expectedId;
                            }
                          }
                        } else {
                          for (let i = currentIndex + 1, ii = numPages; i < ii; i++) {
                            const currentId = yArray[i], expectedId = yArray[i - 1] + 1;
                            if (currentId > expectedId) {
                              return expectedId - currentPageNumber;
                            }
                          }
                        }
                        if (previous) {
                          const firstId = yArray[0];
                          if (firstId < currentPageNumber) {
                            return currentPageNumber - firstId + 1;
                          }
                        } else {
                          const lastId = yArray[numPages - 1];
                          if (lastId > currentPageNumber) {
                            return lastId - currentPageNumber + 1;
                          }
                        }
                        break;
                      }
                      break;
                    }
                    case _ui_utils.ScrollMode.HORIZONTAL: {
                      break;
                    }
                    case _ui_utils.ScrollMode.PAGE:
                    case _ui_utils.ScrollMode.VERTICAL: {
                      if (this._spreadMode === _ui_utils.SpreadMode.NONE) {
                        break;
                      }
                      const parity = this._spreadMode - 1;
                      if (previous && currentPageNumber % 2 !== parity) {
                        break;
                      } else if (!previous && currentPageNumber % 2 === parity) {
                        break;
                      }
                      const {
                        views
                      } = this._getVisiblePages(), expectedId = previous ? currentPageNumber - 1 : currentPageNumber + 1;
                      for (const {
                        id,
                        percent,
                        widthPercent
                      } of views) {
                        if (id !== expectedId) {
                          continue;
                        }
                        if (percent > 0 && widthPercent === 100) {
                          return 2;
                        }
                        break;
                      }
                      break;
                    }
                  }
                  return 1;
                }
                nextPage() {
                  const currentPageNumber = this._currentPageNumber, pagesCount = this.pagesCount;
                  if (currentPageNumber >= pagesCount) {
                    return false;
                  }
                  const advance = this._getPageAdvance(currentPageNumber, false) || 1;
                  this.currentPageNumber = Math.min(currentPageNumber + advance, pagesCount);
                  return true;
                }
                previousPage() {
                  const currentPageNumber = this._currentPageNumber;
                  if (currentPageNumber <= 1) {
                    return false;
                  }
                  const advance = this._getPageAdvance(currentPageNumber, true) || 1;
                  this.currentPageNumber = Math.max(currentPageNumber - advance, 1);
                  return true;
                }
                increaseScale() {
                  let steps = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
                  let newScale = this._currentScale;
                  do {
                    newScale = (newScale * _ui_utils.DEFAULT_SCALE_DELTA).toFixed(2);
                    newScale = Math.ceil(newScale * 10) / 10;
                    newScale = Math.min(_ui_utils.MAX_SCALE, newScale);
                  } while (--steps > 0 && newScale < _ui_utils.MAX_SCALE);
                  this.currentScaleValue = newScale;
                }
                decreaseScale() {
                  let steps = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
                  let newScale = this._currentScale;
                  do {
                    newScale = (newScale / _ui_utils.DEFAULT_SCALE_DELTA).toFixed(2);
                    newScale = Math.floor(newScale * 10) / 10;
                    newScale = Math.max(_ui_utils.MIN_SCALE, newScale);
                  } while (--steps > 0 && newScale > _ui_utils.MIN_SCALE);
                  this.currentScaleValue = newScale;
                }
                updateContainerHeightCss() {
                  const height = this.container.clientHeight;
                  if (height !== _classPrivateFieldGet2(this, _previousContainerHeight)) {
                    _classPrivateFieldSet2(this, _previousContainerHeight, height);
                    _ui_utils.docStyle.setProperty("--viewer-container-height", `${height}px`);
                  }
                }
                get annotationEditorMode() {
                  return _classPrivateFieldGet2(this, _annotationEditorUIManager) ? _classPrivateFieldGet2(this, _annotationEditorMode) : _pdfjsLib.AnnotationEditorType.DISABLE;
                }
                set annotationEditorMode(mode) {
                  if (!_classPrivateFieldGet2(this, _annotationEditorUIManager)) {
                    throw new Error(`The AnnotationEditor is not enabled.`);
                  }
                  if (_classPrivateFieldGet2(this, _annotationEditorMode) === mode) {
                    return;
                  }
                  if (!isValidAnnotationEditorMode(mode)) {
                    throw new Error(`Invalid AnnotationEditor mode: ${mode}`);
                  }
                  if (!this.pdfDocument) {
                    return;
                  }
                  _classPrivateFieldSet2(this, _annotationEditorMode, mode);
                  this.eventBus.dispatch("annotationeditormodechanged", {
                    source: this,
                    mode
                  });
                  _classPrivateFieldGet2(this, _annotationEditorUIManager).updateMode(mode);
                }
                set annotationEditorParams(_ref10) {
                  let {
                    type,
                    value
                  } = _ref10;
                  if (!_classPrivateFieldGet2(this, _annotationEditorUIManager)) {
                    throw new Error(`The AnnotationEditor is not enabled.`);
                  }
                  _classPrivateFieldGet2(this, _annotationEditorUIManager).updateParams(type, value);
                }
                refresh() {
                  if (!this.pdfDocument) {
                    return;
                  }
                  const updateArgs = {};
                  for (const pageView of this._pages) {
                    pageView.update(updateArgs);
                  }
                  this.update();
                }
              }
              exports3.BaseViewer = BaseViewer;
              function _initializePermissions2(permissions) {
                const params = {
                  annotationEditorMode: _classPrivateFieldGet2(this, _annotationEditorMode),
                  annotationMode: _classPrivateFieldGet2(this, _annotationMode),
                  textLayerMode: this.textLayerMode
                };
                if (!permissions) {
                  return params;
                }
                if (!permissions.includes(_pdfjsLib.PermissionFlag.COPY)) {
                  this.viewer.classList.add(ENABLE_PERMISSIONS_CLASS);
                }
                if (!permissions.includes(_pdfjsLib.PermissionFlag.MODIFY_CONTENTS)) {
                  params.annotationEditorMode = _pdfjsLib.AnnotationEditorType.DISABLE;
                }
                if (!permissions.includes(_pdfjsLib.PermissionFlag.MODIFY_ANNOTATIONS) && !permissions.includes(_pdfjsLib.PermissionFlag.FILL_INTERACTIVE_FORMS) && _classPrivateFieldGet2(this, _annotationMode) === _pdfjsLib.AnnotationMode.ENABLE_FORMS) {
                  params.annotationMode = _pdfjsLib.AnnotationMode.ENABLE;
                }
                return params;
              }
              function _onePageRenderedOrForceFetch2() {
                if (document.visibilityState === "hidden" || !this.container.offsetParent || this._getVisiblePages().views.length === 0) {
                  return Promise.resolve();
                }
                const visibilityChangePromise = new Promise((resolve) => {
                  _classPrivateFieldSet2(this, _onVisibilityChange, () => {
                    if (document.visibilityState !== "hidden") {
                      return;
                    }
                    resolve();
                    document.removeEventListener("visibilitychange", _classPrivateFieldGet2(this, _onVisibilityChange));
                    _classPrivateFieldSet2(this, _onVisibilityChange, null);
                  });
                  document.addEventListener("visibilitychange", _classPrivateFieldGet2(this, _onVisibilityChange));
                });
                return Promise.race([this._onePageRenderedCapability.promise, visibilityChangePromise]);
              }
              function _ensurePageViewVisible2() {
                if (this._scrollMode !== _ui_utils.ScrollMode.PAGE) {
                  throw new Error("#ensurePageViewVisible: Invalid scrollMode value.");
                }
                const pageNumber = this._currentPageNumber, state = _classPrivateFieldGet2(this, _scrollModePageState), viewer = this.viewer;
                viewer.textContent = "";
                state.pages.length = 0;
                if (this._spreadMode === _ui_utils.SpreadMode.NONE && !this.isInPresentationMode) {
                  const pageView = this._pages[pageNumber - 1];
                  viewer.append(pageView.div);
                  state.pages.push(pageView);
                } else {
                  const pageIndexSet = /* @__PURE__ */ new Set(), parity = this._spreadMode - 1;
                  if (parity === -1) {
                    pageIndexSet.add(pageNumber - 1);
                  } else if (pageNumber % 2 !== parity) {
                    pageIndexSet.add(pageNumber - 1);
                    pageIndexSet.add(pageNumber);
                  } else {
                    pageIndexSet.add(pageNumber - 2);
                    pageIndexSet.add(pageNumber - 1);
                  }
                  const spread = document.createElement("div");
                  spread.className = "spread";
                  if (this.isInPresentationMode) {
                    const dummyPage = document.createElement("div");
                    dummyPage.className = "dummyPage";
                    spread.append(dummyPage);
                  }
                  for (const i of pageIndexSet) {
                    const pageView = this._pages[i];
                    if (!pageView) {
                      continue;
                    }
                    spread.append(pageView.div);
                    state.pages.push(pageView);
                  }
                  viewer.append(spread);
                }
                state.scrollDown = pageNumber >= state.previousPageNumber;
                state.previousPageNumber = pageNumber;
              }
              function _scrollIntoView2(pageView) {
                let pageSpot = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
                const {
                  div,
                  id
                } = pageView;
                if (this._scrollMode === _ui_utils.ScrollMode.PAGE) {
                  this._setCurrentPageNumber(id);
                  _classPrivateMethodGet2(this, _ensurePageViewVisible, _ensurePageViewVisible2).call(this);
                  this.update();
                }
                if (!pageSpot && !this.isInPresentationMode) {
                  const left = div.offsetLeft + div.clientLeft, right = left + div.clientWidth;
                  const {
                    scrollLeft,
                    clientWidth
                  } = this.container;
                  if (this._scrollMode === _ui_utils.ScrollMode.HORIZONTAL || left < scrollLeft || right > scrollLeft + clientWidth) {
                    pageSpot = {
                      left: 0,
                      top: 0
                    };
                  }
                }
                (0, _ui_utils.scrollIntoView)(div, pageSpot);
              }
              function _isSameScale2(newScale) {
                return newScale === this._currentScale || Math.abs(newScale - this._currentScale) < 1e-15;
              }
              function _resetCurrentPageView2() {
                const pageView = this._pages[this._currentPageNumber - 1];
                if (this.isInPresentationMode) {
                  this._setScale(this._currentScaleValue, true);
                }
                _classPrivateMethodGet2(this, _scrollIntoView, _scrollIntoView2).call(this, pageView);
              }
              async function _ensurePdfPageLoaded2(pageView) {
                if (pageView.pdfPage) {
                  return pageView.pdfPage;
                }
                try {
                  var _this$linkService$_ca, _this$linkService;
                  const pdfPage = await this.pdfDocument.getPage(pageView.id);
                  if (!pageView.pdfPage) {
                    pageView.setPdfPage(pdfPage);
                  }
                  if (!((_this$linkService$_ca = (_this$linkService = this.linkService)._cachedPageNumber) !== null && _this$linkService$_ca !== void 0 && _this$linkService$_ca.call(_this$linkService, pdfPage.ref))) {
                    this.linkService.cachePageRef(pageView.id, pdfPage.ref);
                  }
                  return pdfPage;
                } catch (reason) {
                  console.error("Unable to get page for page view", reason);
                  return null;
                }
              }
              function _getScrollAhead2(visible) {
                var _visible$first, _visible$last;
                if (((_visible$first = visible.first) === null || _visible$first === void 0 ? void 0 : _visible$first.id) === 1) {
                  return true;
                } else if (((_visible$last = visible.last) === null || _visible$last === void 0 ? void 0 : _visible$last.id) === this.pagesCount) {
                  return false;
                }
                switch (this._scrollMode) {
                  case _ui_utils.ScrollMode.PAGE:
                    return _classPrivateFieldGet2(this, _scrollModePageState).scrollDown;
                  case _ui_utils.ScrollMode.HORIZONTAL:
                    return this.scroll.right;
                }
                return this.scroll.down;
              }
              function _toggleLoadingIconSpinner2(visibleIds) {
                for (const id of visibleIds) {
                  const pageView = this._pages[id - 1];
                  pageView === null || pageView === void 0 ? void 0 : pageView.toggleLoadingIconSpinner(true);
                }
                for (const pageView of _classPrivateFieldGet2(this, _buffer)) {
                  if (visibleIds.has(pageView.id)) {
                    continue;
                  }
                  pageView.toggleLoadingIconSpinner(false);
                }
              }
            },
            /* 13 */
            /***/
            (__unused_webpack_module2, exports3, __w_pdfjs_require__3) => {
              Object.defineProperty(exports3, "__esModule", {
                value: true
              });
              exports3.PDFPageView = void 0;
              var _pdfjsLib = __w_pdfjs_require__3(3);
              var _ui_utils = __w_pdfjs_require__3(7);
              var _app_options = __w_pdfjs_require__3(14);
              var _l10n_utils = __w_pdfjs_require__3(4);
              var _text_accessibility = __w_pdfjs_require__3(15);
              function _classPrivateFieldInitSpec2(obj, privateMap, value) {
                _checkPrivateRedeclaration2(obj, privateMap);
                privateMap.set(obj, value);
              }
              function _checkPrivateRedeclaration2(obj, privateCollection) {
                if (privateCollection.has(obj)) {
                  throw new TypeError("Cannot initialize the same private elements twice on an object");
                }
              }
              function _classPrivateFieldGet2(receiver, privateMap) {
                var descriptor = _classExtractFieldDescriptor2(receiver, privateMap, "get");
                return _classApplyDescriptorGet2(receiver, descriptor);
              }
              function _classApplyDescriptorGet2(receiver, descriptor) {
                if (descriptor.get) {
                  return descriptor.get.call(receiver);
                }
                return descriptor.value;
              }
              function _classPrivateFieldSet2(receiver, privateMap, value) {
                var descriptor = _classExtractFieldDescriptor2(receiver, privateMap, "set");
                _classApplyDescriptorSet2(receiver, descriptor, value);
                return value;
              }
              function _classExtractFieldDescriptor2(receiver, privateMap, action) {
                if (!privateMap.has(receiver)) {
                  throw new TypeError("attempted to " + action + " private field on non-instance");
                }
                return privateMap.get(receiver);
              }
              function _classApplyDescriptorSet2(receiver, descriptor, value) {
                if (descriptor.set) {
                  descriptor.set.call(receiver, value);
                } else {
                  if (!descriptor.writable) {
                    throw new TypeError("attempted to set read only private field");
                  }
                  descriptor.value = value;
                }
              }
              const MAX_CANVAS_PIXELS = _app_options.compatibilityParams.maxCanvasPixels || 16777216;
              var _annotationMode = /* @__PURE__ */ new WeakMap();
              var _useThumbnailCanvas = /* @__PURE__ */ new WeakMap();
              class PDFPageView {
                constructor(options) {
                  var _options$textLayerMod, _options$annotationMo, _options$textHighligh, _this$renderingQueue;
                  _classPrivateFieldInitSpec2(this, _annotationMode, {
                    writable: true,
                    value: _pdfjsLib.AnnotationMode.ENABLE_FORMS
                  });
                  _classPrivateFieldInitSpec2(this, _useThumbnailCanvas, {
                    writable: true,
                    value: {
                      initialOptionalContent: true,
                      regularAnnotations: true
                    }
                  });
                  const container = options.container;
                  const defaultViewport = options.defaultViewport;
                  this.id = options.id;
                  this.renderingId = "page" + this.id;
                  this.pdfPage = null;
                  this.pageLabel = null;
                  this.rotation = 0;
                  this.scale = options.scale || _ui_utils.DEFAULT_SCALE;
                  this.viewport = defaultViewport;
                  this.pdfPageRotate = defaultViewport.rotation;
                  this._optionalContentConfigPromise = options.optionalContentConfigPromise || null;
                  this.hasRestrictedScaling = false;
                  this.textLayerMode = (_options$textLayerMod = options.textLayerMode) !== null && _options$textLayerMod !== void 0 ? _options$textLayerMod : _ui_utils.TextLayerMode.ENABLE;
                  _classPrivateFieldSet2(this, _annotationMode, (_options$annotationMo = options.annotationMode) !== null && _options$annotationMo !== void 0 ? _options$annotationMo : _pdfjsLib.AnnotationMode.ENABLE_FORMS);
                  this.imageResourcesPath = options.imageResourcesPath || "";
                  this.useOnlyCssZoom = options.useOnlyCssZoom || false;
                  this.maxCanvasPixels = options.maxCanvasPixels || MAX_CANVAS_PIXELS;
                  this.pageColors = options.pageColors || null;
                  this.eventBus = options.eventBus;
                  this.renderingQueue = options.renderingQueue;
                  this.textLayerFactory = options.textLayerFactory;
                  this.annotationLayerFactory = options.annotationLayerFactory;
                  this.annotationEditorLayerFactory = options.annotationEditorLayerFactory;
                  this.xfaLayerFactory = options.xfaLayerFactory;
                  this.textHighlighter = (_options$textHighligh = options.textHighlighterFactory) === null || _options$textHighligh === void 0 ? void 0 : _options$textHighligh.createTextHighlighter({
                    pageIndex: this.id - 1,
                    eventBus: this.eventBus
                  });
                  this.structTreeLayerFactory = options.structTreeLayerFactory;
                  this.renderer = options.renderer || _ui_utils.RendererType.CANVAS;
                  this.l10n = options.l10n || _l10n_utils.NullL10n;
                  this.paintTask = null;
                  this.paintedViewportMap = /* @__PURE__ */ new WeakMap();
                  this.renderingState = _ui_utils.RenderingStates.INITIAL;
                  this.resume = null;
                  this._renderError = null;
                  this._isStandalone = !((_this$renderingQueue = this.renderingQueue) !== null && _this$renderingQueue !== void 0 && _this$renderingQueue.hasViewer());
                  this._annotationCanvasMap = null;
                  this.annotationLayer = null;
                  this.annotationEditorLayer = null;
                  this.textLayer = null;
                  this.zoomLayer = null;
                  this.xfaLayer = null;
                  this.structTreeLayer = null;
                  const div = document.createElement("div");
                  div.className = "page";
                  div.style.width = Math.floor(this.viewport.width) + "px";
                  div.style.height = Math.floor(this.viewport.height) + "px";
                  div.setAttribute("data-page-number", this.id);
                  div.setAttribute("role", "region");
                  this.l10n.get("page_landmark", {
                    page: this.id
                  }).then((msg) => {
                    div.setAttribute("aria-label", msg);
                  });
                  this.div = div;
                  container === null || container === void 0 ? void 0 : container.append(div);
                  if (this._isStandalone) {
                    const {
                      optionalContentConfigPromise
                    } = options;
                    if (optionalContentConfigPromise) {
                      optionalContentConfigPromise.then((optionalContentConfig) => {
                        if (optionalContentConfigPromise !== this._optionalContentConfigPromise) {
                          return;
                        }
                        _classPrivateFieldGet2(this, _useThumbnailCanvas).initialOptionalContent = optionalContentConfig.hasInitialVisibility;
                      });
                    }
                  }
                }
                setPdfPage(pdfPage) {
                  this.pdfPage = pdfPage;
                  this.pdfPageRotate = pdfPage.rotate;
                  const totalRotation = (this.rotation + this.pdfPageRotate) % 360;
                  this.viewport = pdfPage.getViewport({
                    scale: this.scale * _pdfjsLib.PixelsPerInch.PDF_TO_CSS_UNITS,
                    rotation: totalRotation
                  });
                  this.reset();
                }
                destroy() {
                  this.reset();
                  if (this.pdfPage) {
                    this.pdfPage.cleanup();
                  }
                }
                async _renderAnnotationLayer() {
                  let error = null;
                  try {
                    await this.annotationLayer.render(this.viewport, "display");
                  } catch (ex) {
                    console.error(`_renderAnnotationLayer: "${ex}".`);
                    error = ex;
                  } finally {
                    this.eventBus.dispatch("annotationlayerrendered", {
                      source: this,
                      pageNumber: this.id,
                      error
                    });
                  }
                }
                async _renderAnnotationEditorLayer() {
                  let error = null;
                  try {
                    await this.annotationEditorLayer.render(this.viewport, "display");
                  } catch (ex) {
                    console.error(`_renderAnnotationEditorLayer: "${ex}".`);
                    error = ex;
                  } finally {
                    this.eventBus.dispatch("annotationeditorlayerrendered", {
                      source: this,
                      pageNumber: this.id,
                      error
                    });
                  }
                }
                async _renderXfaLayer() {
                  let error = null;
                  try {
                    const result = await this.xfaLayer.render(this.viewport, "display");
                    if (this.textHighlighter) {
                      this._buildXfaTextContentItems(result.textDivs);
                    }
                  } catch (ex) {
                    console.error(`_renderXfaLayer: "${ex}".`);
                    error = ex;
                  } finally {
                    this.eventBus.dispatch("xfalayerrendered", {
                      source: this,
                      pageNumber: this.id,
                      error
                    });
                  }
                }
                async _buildXfaTextContentItems(textDivs) {
                  const text = await this.pdfPage.getTextContent();
                  const items = [];
                  for (const item of text.items) {
                    items.push(item.str);
                  }
                  this.textHighlighter.setTextMapping(textDivs, items);
                  this.textHighlighter.enable();
                }
                _resetZoomLayer() {
                  let removeFromDOM = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
                  if (!this.zoomLayer) {
                    return;
                  }
                  const zoomLayerCanvas = this.zoomLayer.firstChild;
                  this.paintedViewportMap.delete(zoomLayerCanvas);
                  zoomLayerCanvas.width = 0;
                  zoomLayerCanvas.height = 0;
                  if (removeFromDOM) {
                    this.zoomLayer.remove();
                  }
                  this.zoomLayer = null;
                }
                reset() {
                  var _this$annotationLayer, _this$annotationEdito, _this$xfaLayer;
                  let {
                    keepZoomLayer = false,
                    keepAnnotationLayer = false,
                    keepAnnotationEditorLayer = false,
                    keepXfaLayer = false
                  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                  this.cancelRendering({
                    keepAnnotationLayer,
                    keepAnnotationEditorLayer,
                    keepXfaLayer
                  });
                  this.renderingState = _ui_utils.RenderingStates.INITIAL;
                  const div = this.div;
                  div.style.width = Math.floor(this.viewport.width) + "px";
                  div.style.height = Math.floor(this.viewport.height) + "px";
                  const childNodes = div.childNodes, zoomLayerNode = keepZoomLayer && this.zoomLayer || null, annotationLayerNode = keepAnnotationLayer && ((_this$annotationLayer = this.annotationLayer) === null || _this$annotationLayer === void 0 ? void 0 : _this$annotationLayer.div) || null, annotationEditorLayerNode = keepAnnotationEditorLayer && ((_this$annotationEdito = this.annotationEditorLayer) === null || _this$annotationEdito === void 0 ? void 0 : _this$annotationEdito.div) || null, xfaLayerNode = keepXfaLayer && ((_this$xfaLayer = this.xfaLayer) === null || _this$xfaLayer === void 0 ? void 0 : _this$xfaLayer.div) || null;
                  for (let i = childNodes.length - 1; i >= 0; i--) {
                    const node = childNodes[i];
                    switch (node) {
                      case zoomLayerNode:
                      case annotationLayerNode:
                      case annotationEditorLayerNode:
                      case xfaLayerNode:
                        continue;
                    }
                    node.remove();
                  }
                  div.removeAttribute("data-loaded");
                  if (annotationLayerNode) {
                    this.annotationLayer.hide();
                  }
                  if (annotationEditorLayerNode) {
                    this.annotationEditorLayer.hide();
                  } else {
                    var _this$annotationEdito2;
                    (_this$annotationEdito2 = this.annotationEditorLayer) === null || _this$annotationEdito2 === void 0 ? void 0 : _this$annotationEdito2.destroy();
                  }
                  if (xfaLayerNode) {
                    this.xfaLayer.hide();
                  }
                  if (!zoomLayerNode) {
                    if (this.canvas) {
                      this.paintedViewportMap.delete(this.canvas);
                      this.canvas.width = 0;
                      this.canvas.height = 0;
                      delete this.canvas;
                    }
                    this._resetZoomLayer();
                  }
                  if (this.svg) {
                    this.paintedViewportMap.delete(this.svg);
                    delete this.svg;
                  }
                  this.loadingIconDiv = document.createElement("div");
                  this.loadingIconDiv.className = "loadingIcon notVisible";
                  if (this._isStandalone) {
                    this.toggleLoadingIconSpinner(true);
                  }
                  this.loadingIconDiv.setAttribute("role", "img");
                  this.l10n.get("loading").then((msg) => {
                    var _this$loadingIconDiv;
                    (_this$loadingIconDiv = this.loadingIconDiv) === null || _this$loadingIconDiv === void 0 ? void 0 : _this$loadingIconDiv.setAttribute("aria-label", msg);
                  });
                  div.append(this.loadingIconDiv);
                }
                update(_ref) {
                  let {
                    scale = 0,
                    rotation = null,
                    optionalContentConfigPromise = null
                  } = _ref;
                  this.scale = scale || this.scale;
                  if (typeof rotation === "number") {
                    this.rotation = rotation;
                  }
                  if (optionalContentConfigPromise instanceof Promise) {
                    this._optionalContentConfigPromise = optionalContentConfigPromise;
                    optionalContentConfigPromise.then((optionalContentConfig) => {
                      if (optionalContentConfigPromise !== this._optionalContentConfigPromise) {
                        return;
                      }
                      _classPrivateFieldGet2(this, _useThumbnailCanvas).initialOptionalContent = optionalContentConfig.hasInitialVisibility;
                    });
                  }
                  const totalRotation = (this.rotation + this.pdfPageRotate) % 360;
                  this.viewport = this.viewport.clone({
                    scale: this.scale * _pdfjsLib.PixelsPerInch.PDF_TO_CSS_UNITS,
                    rotation: totalRotation
                  });
                  if (this._isStandalone) {
                    _ui_utils.docStyle.setProperty("--scale-factor", this.viewport.scale);
                  }
                  if (this.svg) {
                    this.cssTransform({
                      target: this.svg,
                      redrawAnnotationLayer: true,
                      redrawAnnotationEditorLayer: true,
                      redrawXfaLayer: true
                    });
                    this.eventBus.dispatch("pagerendered", {
                      source: this,
                      pageNumber: this.id,
                      cssTransform: true,
                      timestamp: performance.now(),
                      error: this._renderError
                    });
                    return;
                  }
                  let isScalingRestricted = false;
                  if (this.canvas && this.maxCanvasPixels > 0) {
                    const outputScale = this.outputScale;
                    if ((Math.floor(this.viewport.width) * outputScale.sx | 0) * (Math.floor(this.viewport.height) * outputScale.sy | 0) > this.maxCanvasPixels) {
                      isScalingRestricted = true;
                    }
                  }
                  if (this.canvas) {
                    if (this.useOnlyCssZoom || this.hasRestrictedScaling && isScalingRestricted) {
                      this.cssTransform({
                        target: this.canvas,
                        redrawAnnotationLayer: true,
                        redrawAnnotationEditorLayer: true,
                        redrawXfaLayer: true
                      });
                      this.eventBus.dispatch("pagerendered", {
                        source: this,
                        pageNumber: this.id,
                        cssTransform: true,
                        timestamp: performance.now(),
                        error: this._renderError
                      });
                      return;
                    }
                    if (!this.zoomLayer && !this.canvas.hidden) {
                      this.zoomLayer = this.canvas.parentNode;
                      this.zoomLayer.style.position = "absolute";
                    }
                  }
                  if (this.zoomLayer) {
                    this.cssTransform({
                      target: this.zoomLayer.firstChild
                    });
                  }
                  this.reset({
                    keepZoomLayer: true,
                    keepAnnotationLayer: true,
                    keepAnnotationEditorLayer: true,
                    keepXfaLayer: true
                  });
                }
                cancelRendering() {
                  let {
                    keepAnnotationLayer = false,
                    keepAnnotationEditorLayer = false,
                    keepXfaLayer = false
                  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                  if (this.paintTask) {
                    this.paintTask.cancel();
                    this.paintTask = null;
                  }
                  this.resume = null;
                  if (this.textLayer) {
                    this.textLayer.cancel();
                    this.textLayer = null;
                  }
                  if (this.annotationLayer && (!keepAnnotationLayer || !this.annotationLayer.div)) {
                    this.annotationLayer.cancel();
                    this.annotationLayer = null;
                    this._annotationCanvasMap = null;
                  }
                  if (this.annotationEditorLayer && (!keepAnnotationEditorLayer || !this.annotationEditorLayer.div)) {
                    this.annotationEditorLayer.cancel();
                    this.annotationEditorLayer = null;
                  }
                  if (this.xfaLayer && (!keepXfaLayer || !this.xfaLayer.div)) {
                    var _this$textHighlighter;
                    this.xfaLayer.cancel();
                    this.xfaLayer = null;
                    (_this$textHighlighter = this.textHighlighter) === null || _this$textHighlighter === void 0 ? void 0 : _this$textHighlighter.disable();
                  }
                  if (this._onTextLayerRendered) {
                    this.eventBus._off("textlayerrendered", this._onTextLayerRendered);
                    this._onTextLayerRendered = null;
                  }
                }
                cssTransform(_ref2) {
                  let {
                    target,
                    redrawAnnotationLayer = false,
                    redrawAnnotationEditorLayer = false,
                    redrawXfaLayer = false
                  } = _ref2;
                  const width = this.viewport.width;
                  const height = this.viewport.height;
                  const div = this.div;
                  target.style.width = target.parentNode.style.width = div.style.width = Math.floor(width) + "px";
                  target.style.height = target.parentNode.style.height = div.style.height = Math.floor(height) + "px";
                  const relativeRotation = this.viewport.rotation - this.paintedViewportMap.get(target).rotation;
                  const absRotation = Math.abs(relativeRotation);
                  let scaleX = 1, scaleY = 1;
                  if (absRotation === 90 || absRotation === 270) {
                    scaleX = height / width;
                    scaleY = width / height;
                  }
                  target.style.transform = `rotate(${relativeRotation}deg) scale(${scaleX}, ${scaleY})`;
                  if (this.textLayer) {
                    const textLayerViewport = this.textLayer.viewport;
                    const textRelativeRotation = this.viewport.rotation - textLayerViewport.rotation;
                    const textAbsRotation = Math.abs(textRelativeRotation);
                    let scale = width / textLayerViewport.width;
                    if (textAbsRotation === 90 || textAbsRotation === 270) {
                      scale = width / textLayerViewport.height;
                    }
                    const textLayerDiv = this.textLayer.textLayerDiv;
                    let transX, transY;
                    switch (textAbsRotation) {
                      case 0:
                        transX = transY = 0;
                        break;
                      case 90:
                        transX = 0;
                        transY = "-" + textLayerDiv.style.height;
                        break;
                      case 180:
                        transX = "-" + textLayerDiv.style.width;
                        transY = "-" + textLayerDiv.style.height;
                        break;
                      case 270:
                        transX = "-" + textLayerDiv.style.width;
                        transY = 0;
                        break;
                      default:
                        console.error("Bad rotation value.");
                        break;
                    }
                    textLayerDiv.style.transform = `rotate(${textAbsRotation}deg) scale(${scale}) translate(${transX}, ${transY})`;
                    textLayerDiv.style.transformOrigin = "0% 0%";
                  }
                  if (redrawAnnotationLayer && this.annotationLayer) {
                    this._renderAnnotationLayer();
                  }
                  if (redrawAnnotationEditorLayer && this.annotationEditorLayer) {
                    this._renderAnnotationEditorLayer();
                  }
                  if (redrawXfaLayer && this.xfaLayer) {
                    this._renderXfaLayer();
                  }
                }
                get width() {
                  return this.viewport.width;
                }
                get height() {
                  return this.viewport.height;
                }
                getPagePoint(x, y) {
                  return this.viewport.convertToPdfPoint(x, y);
                }
                toggleLoadingIconSpinner() {
                  var _this$loadingIconDiv2;
                  let viewVisible = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
                  (_this$loadingIconDiv2 = this.loadingIconDiv) === null || _this$loadingIconDiv2 === void 0 ? void 0 : _this$loadingIconDiv2.classList.toggle("notVisible", !viewVisible);
                }
                draw() {
                  var _this$annotationLayer2, _this$annotationEdito3, _this$xfaLayer2, _this = this;
                  if (this.renderingState !== _ui_utils.RenderingStates.INITIAL) {
                    console.error("Must be in new state before drawing");
                    this.reset();
                  }
                  const {
                    div,
                    pdfPage
                  } = this;
                  if (!pdfPage) {
                    this.renderingState = _ui_utils.RenderingStates.FINISHED;
                    if (this.loadingIconDiv) {
                      this.loadingIconDiv.remove();
                      delete this.loadingIconDiv;
                    }
                    return Promise.reject(new Error("pdfPage is not loaded"));
                  }
                  this.renderingState = _ui_utils.RenderingStates.RUNNING;
                  const canvasWrapper = document.createElement("div");
                  canvasWrapper.style.width = div.style.width;
                  canvasWrapper.style.height = div.style.height;
                  canvasWrapper.classList.add("canvasWrapper");
                  const lastDivBeforeTextDiv = ((_this$annotationLayer2 = this.annotationLayer) === null || _this$annotationLayer2 === void 0 ? void 0 : _this$annotationLayer2.div) || ((_this$annotationEdito3 = this.annotationEditorLayer) === null || _this$annotationEdito3 === void 0 ? void 0 : _this$annotationEdito3.div);
                  if (lastDivBeforeTextDiv) {
                    lastDivBeforeTextDiv.before(canvasWrapper);
                  } else {
                    div.append(canvasWrapper);
                  }
                  let textLayer = null;
                  if (this.textLayerMode !== _ui_utils.TextLayerMode.DISABLE && this.textLayerFactory) {
                    this._accessibilityManager || (this._accessibilityManager = new _text_accessibility.TextAccessibilityManager());
                    const textLayerDiv = document.createElement("div");
                    textLayerDiv.className = "textLayer";
                    textLayerDiv.style.width = canvasWrapper.style.width;
                    textLayerDiv.style.height = canvasWrapper.style.height;
                    if (lastDivBeforeTextDiv) {
                      lastDivBeforeTextDiv.before(textLayerDiv);
                    } else {
                      div.append(textLayerDiv);
                    }
                    textLayer = this.textLayerFactory.createTextLayerBuilder({
                      textLayerDiv,
                      pageIndex: this.id - 1,
                      viewport: this.viewport,
                      enhanceTextSelection: this.textLayerMode === _ui_utils.TextLayerMode.ENABLE_ENHANCE,
                      eventBus: this.eventBus,
                      highlighter: this.textHighlighter,
                      accessibilityManager: this._accessibilityManager
                    });
                  }
                  this.textLayer = textLayer;
                  if (_classPrivateFieldGet2(this, _annotationMode) !== _pdfjsLib.AnnotationMode.DISABLE && this.annotationLayerFactory) {
                    this._annotationCanvasMap || (this._annotationCanvasMap = /* @__PURE__ */ new Map());
                    this.annotationLayer || (this.annotationLayer = this.annotationLayerFactory.createAnnotationLayerBuilder({
                      pageDiv: div,
                      pdfPage,
                      imageResourcesPath: this.imageResourcesPath,
                      renderForms: _classPrivateFieldGet2(this, _annotationMode) === _pdfjsLib.AnnotationMode.ENABLE_FORMS,
                      l10n: this.l10n,
                      annotationCanvasMap: this._annotationCanvasMap,
                      accessibilityManager: this._accessibilityManager
                    }));
                  }
                  if ((_this$xfaLayer2 = this.xfaLayer) !== null && _this$xfaLayer2 !== void 0 && _this$xfaLayer2.div) {
                    div.append(this.xfaLayer.div);
                  }
                  let renderContinueCallback = null;
                  if (this.renderingQueue) {
                    renderContinueCallback = (cont) => {
                      if (!this.renderingQueue.isHighestPriority(this)) {
                        this.renderingState = _ui_utils.RenderingStates.PAUSED;
                        this.resume = () => {
                          this.renderingState = _ui_utils.RenderingStates.RUNNING;
                          cont();
                        };
                        return;
                      }
                      cont();
                    };
                  }
                  const finishPaintTask = async function() {
                    let error = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
                    if (paintTask === _this.paintTask) {
                      _this.paintTask = null;
                    }
                    if (error instanceof _pdfjsLib.RenderingCancelledException) {
                      _this._renderError = null;
                      return;
                    }
                    _this._renderError = error;
                    _this.renderingState = _ui_utils.RenderingStates.FINISHED;
                    if (_this.loadingIconDiv) {
                      _this.loadingIconDiv.remove();
                      delete _this.loadingIconDiv;
                    }
                    _this._resetZoomLayer(true);
                    _classPrivateFieldGet2(_this, _useThumbnailCanvas).regularAnnotations = !paintTask.separateAnnots;
                    _this.eventBus.dispatch("pagerendered", {
                      source: _this,
                      pageNumber: _this.id,
                      cssTransform: false,
                      timestamp: performance.now(),
                      error: _this._renderError
                    });
                    if (error) {
                      throw error;
                    }
                  };
                  const paintTask = this.renderer === _ui_utils.RendererType.SVG ? this.paintOnSvg(canvasWrapper) : this.paintOnCanvas(canvasWrapper);
                  paintTask.onRenderContinue = renderContinueCallback;
                  this.paintTask = paintTask;
                  const resultPromise = paintTask.promise.then(() => {
                    return finishPaintTask(null).then(() => {
                      if (textLayer) {
                        const readableStream = pdfPage.streamTextContent({
                          includeMarkedContent: true
                        });
                        textLayer.setTextContentStream(readableStream);
                        textLayer.render();
                      }
                      if (this.annotationLayer) {
                        this._renderAnnotationLayer().then(() => {
                          if (this.annotationEditorLayerFactory) {
                            this.annotationEditorLayer || (this.annotationEditorLayer = this.annotationEditorLayerFactory.createAnnotationEditorLayerBuilder({
                              pageDiv: div,
                              pdfPage,
                              l10n: this.l10n,
                              accessibilityManager: this._accessibilityManager
                            }));
                            this._renderAnnotationEditorLayer();
                          }
                        });
                      }
                    });
                  }, function(reason) {
                    return finishPaintTask(reason);
                  });
                  if (this.xfaLayerFactory) {
                    this.xfaLayer || (this.xfaLayer = this.xfaLayerFactory.createXfaLayerBuilder({
                      pageDiv: div,
                      pdfPage
                    }));
                    this._renderXfaLayer();
                  }
                  if (this.structTreeLayerFactory && this.textLayer && this.canvas) {
                    this._onTextLayerRendered = (event) => {
                      if (event.pageNumber !== this.id) {
                        return;
                      }
                      this.eventBus._off("textlayerrendered", this._onTextLayerRendered);
                      this._onTextLayerRendered = null;
                      if (!this.canvas) {
                        return;
                      }
                      this.pdfPage.getStructTree().then((tree) => {
                        if (!tree) {
                          return;
                        }
                        if (!this.canvas) {
                          return;
                        }
                        const treeDom = this.structTreeLayer.render(tree);
                        treeDom.classList.add("structTree");
                        this.canvas.append(treeDom);
                      });
                    };
                    this.eventBus._on("textlayerrendered", this._onTextLayerRendered);
                    this.structTreeLayer = this.structTreeLayerFactory.createStructTreeLayerBuilder({
                      pdfPage
                    });
                  }
                  div.setAttribute("data-loaded", true);
                  this.eventBus.dispatch("pagerender", {
                    source: this,
                    pageNumber: this.id
                  });
                  return resultPromise;
                }
                paintOnCanvas(canvasWrapper) {
                  const renderCapability = (0, _pdfjsLib.createPromiseCapability)();
                  const result = {
                    promise: renderCapability.promise,
                    onRenderContinue(cont) {
                      cont();
                    },
                    cancel() {
                      renderTask.cancel();
                    },
                    get separateAnnots() {
                      return renderTask.separateAnnots;
                    }
                  };
                  const viewport = this.viewport;
                  const canvas = document.createElement("canvas");
                  canvas.setAttribute("role", "presentation");
                  canvas.hidden = true;
                  let isCanvasHidden = true;
                  const showCanvas = function() {
                    if (isCanvasHidden) {
                      canvas.hidden = false;
                      isCanvasHidden = false;
                    }
                  };
                  canvasWrapper.append(canvas);
                  this.canvas = canvas;
                  const ctx = canvas.getContext("2d", {
                    alpha: false
                  });
                  const outputScale = this.outputScale = new _ui_utils.OutputScale();
                  if (this.useOnlyCssZoom) {
                    const actualSizeViewport = viewport.clone({
                      scale: _pdfjsLib.PixelsPerInch.PDF_TO_CSS_UNITS
                    });
                    outputScale.sx *= actualSizeViewport.width / viewport.width;
                    outputScale.sy *= actualSizeViewport.height / viewport.height;
                  }
                  if (this.maxCanvasPixels > 0) {
                    const pixelsInViewport = viewport.width * viewport.height;
                    const maxScale = Math.sqrt(this.maxCanvasPixels / pixelsInViewport);
                    if (outputScale.sx > maxScale || outputScale.sy > maxScale) {
                      outputScale.sx = maxScale;
                      outputScale.sy = maxScale;
                      this.hasRestrictedScaling = true;
                    } else {
                      this.hasRestrictedScaling = false;
                    }
                  }
                  const sfx = (0, _ui_utils.approximateFraction)(outputScale.sx);
                  const sfy = (0, _ui_utils.approximateFraction)(outputScale.sy);
                  canvas.width = (0, _ui_utils.roundToDivide)(viewport.width * outputScale.sx, sfx[0]);
                  canvas.height = (0, _ui_utils.roundToDivide)(viewport.height * outputScale.sy, sfy[0]);
                  canvas.style.width = (0, _ui_utils.roundToDivide)(viewport.width, sfx[1]) + "px";
                  canvas.style.height = (0, _ui_utils.roundToDivide)(viewport.height, sfy[1]) + "px";
                  this.paintedViewportMap.set(canvas, viewport);
                  const transform = outputScale.scaled ? [outputScale.sx, 0, 0, outputScale.sy, 0, 0] : null;
                  const renderContext = {
                    canvasContext: ctx,
                    transform,
                    viewport: this.viewport,
                    annotationMode: _classPrivateFieldGet2(this, _annotationMode),
                    optionalContentConfigPromise: this._optionalContentConfigPromise,
                    annotationCanvasMap: this._annotationCanvasMap,
                    pageColors: this.pageColors
                  };
                  const renderTask = this.pdfPage.render(renderContext);
                  renderTask.onContinue = function(cont) {
                    showCanvas();
                    if (result.onRenderContinue) {
                      result.onRenderContinue(cont);
                    } else {
                      cont();
                    }
                  };
                  renderTask.promise.then(function() {
                    showCanvas();
                    renderCapability.resolve();
                  }, function(error) {
                    showCanvas();
                    renderCapability.reject(error);
                  });
                  return result;
                }
                paintOnSvg(wrapper) {
                  let cancelled = false;
                  const ensureNotCancelled = () => {
                    if (cancelled) {
                      throw new _pdfjsLib.RenderingCancelledException(`Rendering cancelled, page ${this.id}`, "svg");
                    }
                  };
                  const pdfPage = this.pdfPage;
                  const actualSizeViewport = this.viewport.clone({
                    scale: _pdfjsLib.PixelsPerInch.PDF_TO_CSS_UNITS
                  });
                  const promise = pdfPage.getOperatorList({
                    annotationMode: _classPrivateFieldGet2(this, _annotationMode)
                  }).then((opList) => {
                    ensureNotCancelled();
                    const svgGfx = new _pdfjsLib.SVGGraphics(pdfPage.commonObjs, pdfPage.objs);
                    return svgGfx.getSVG(opList, actualSizeViewport).then((svg) => {
                      ensureNotCancelled();
                      this.svg = svg;
                      this.paintedViewportMap.set(svg, actualSizeViewport);
                      svg.style.width = wrapper.style.width;
                      svg.style.height = wrapper.style.height;
                      this.renderingState = _ui_utils.RenderingStates.FINISHED;
                      wrapper.append(svg);
                    });
                  });
                  return {
                    promise,
                    onRenderContinue(cont) {
                      cont();
                    },
                    cancel() {
                      cancelled = true;
                    },
                    get separateAnnots() {
                      return false;
                    }
                  };
                }
                setPageLabel(label) {
                  this.pageLabel = typeof label === "string" ? label : null;
                  if (this.pageLabel !== null) {
                    this.div.setAttribute("data-page-label", this.pageLabel);
                  } else {
                    this.div.removeAttribute("data-page-label");
                  }
                }
                get thumbnailCanvas() {
                  const {
                    initialOptionalContent,
                    regularAnnotations
                  } = _classPrivateFieldGet2(this, _useThumbnailCanvas);
                  return initialOptionalContent && regularAnnotations ? this.canvas : null;
                }
              }
              exports3.PDFPageView = PDFPageView;
            },
            /* 14 */
            /***/
            (__unused_webpack_module2, exports3) => {
              Object.defineProperty(exports3, "__esModule", {
                value: true
              });
              exports3.compatibilityParams = exports3.OptionKind = exports3.AppOptions = void 0;
              const compatibilityParams = /* @__PURE__ */ Object.create(null);
              exports3.compatibilityParams = compatibilityParams;
              {
                const userAgent = navigator.userAgent || "";
                const platform = navigator.platform || "";
                const maxTouchPoints = navigator.maxTouchPoints || 1;
                const isAndroid = /Android/.test(userAgent);
                const isIOS = /\b(iPad|iPhone|iPod)(?=;)/.test(userAgent) || platform === "MacIntel" && maxTouchPoints > 1;
                (function checkCanvasSizeLimitation() {
                  if (isIOS || isAndroid) {
                    compatibilityParams.maxCanvasPixels = 5242880;
                  }
                })();
              }
              const OptionKind = {
                VIEWER: 2,
                API: 4,
                WORKER: 8,
                PREFERENCE: 128
              };
              exports3.OptionKind = OptionKind;
              const defaultOptions = {
                annotationEditorMode: {
                  value: -1,
                  kind: OptionKind.VIEWER + OptionKind.PREFERENCE
                },
                annotationMode: {
                  value: 2,
                  kind: OptionKind.VIEWER + OptionKind.PREFERENCE
                },
                cursorToolOnLoad: {
                  value: 0,
                  kind: OptionKind.VIEWER + OptionKind.PREFERENCE
                },
                defaultZoomValue: {
                  value: "",
                  kind: OptionKind.VIEWER + OptionKind.PREFERENCE
                },
                disableHistory: {
                  value: false,
                  kind: OptionKind.VIEWER
                },
                disablePageLabels: {
                  value: false,
                  kind: OptionKind.VIEWER + OptionKind.PREFERENCE
                },
                enablePermissions: {
                  value: false,
                  kind: OptionKind.VIEWER + OptionKind.PREFERENCE
                },
                enablePrintAutoRotate: {
                  value: true,
                  kind: OptionKind.VIEWER + OptionKind.PREFERENCE
                },
                enableScripting: {
                  value: true,
                  kind: OptionKind.VIEWER + OptionKind.PREFERENCE
                },
                externalLinkRel: {
                  value: "noopener noreferrer nofollow",
                  kind: OptionKind.VIEWER
                },
                externalLinkTarget: {
                  value: 0,
                  kind: OptionKind.VIEWER + OptionKind.PREFERENCE
                },
                historyUpdateUrl: {
                  value: false,
                  kind: OptionKind.VIEWER + OptionKind.PREFERENCE
                },
                ignoreDestinationZoom: {
                  value: false,
                  kind: OptionKind.VIEWER + OptionKind.PREFERENCE
                },
                imageResourcesPath: {
                  value: "./images/",
                  kind: OptionKind.VIEWER
                },
                maxCanvasPixels: {
                  value: 16777216,
                  kind: OptionKind.VIEWER
                },
                forcePageColors: {
                  value: false,
                  kind: OptionKind.VIEWER + OptionKind.PREFERENCE
                },
                pageColorsBackground: {
                  value: "Canvas",
                  kind: OptionKind.VIEWER + OptionKind.PREFERENCE
                },
                pageColorsForeground: {
                  value: "CanvasText",
                  kind: OptionKind.VIEWER + OptionKind.PREFERENCE
                },
                pdfBugEnabled: {
                  value: false,
                  kind: OptionKind.VIEWER + OptionKind.PREFERENCE
                },
                printResolution: {
                  value: 150,
                  kind: OptionKind.VIEWER
                },
                sidebarViewOnLoad: {
                  value: -1,
                  kind: OptionKind.VIEWER + OptionKind.PREFERENCE
                },
                scrollModeOnLoad: {
                  value: -1,
                  kind: OptionKind.VIEWER + OptionKind.PREFERENCE
                },
                spreadModeOnLoad: {
                  value: -1,
                  kind: OptionKind.VIEWER + OptionKind.PREFERENCE
                },
                textLayerMode: {
                  value: 1,
                  kind: OptionKind.VIEWER + OptionKind.PREFERENCE
                },
                useOnlyCssZoom: {
                  value: false,
                  kind: OptionKind.VIEWER + OptionKind.PREFERENCE
                },
                viewerCssTheme: {
                  value: 0,
                  kind: OptionKind.VIEWER + OptionKind.PREFERENCE
                },
                viewOnLoad: {
                  value: 0,
                  kind: OptionKind.VIEWER + OptionKind.PREFERENCE
                },
                cMapPacked: {
                  value: true,
                  kind: OptionKind.API
                },
                cMapUrl: {
                  value: "../web/cmaps/",
                  kind: OptionKind.API
                },
                disableAutoFetch: {
                  value: false,
                  kind: OptionKind.API + OptionKind.PREFERENCE
                },
                disableFontFace: {
                  value: false,
                  kind: OptionKind.API + OptionKind.PREFERENCE
                },
                disableRange: {
                  value: false,
                  kind: OptionKind.API + OptionKind.PREFERENCE
                },
                disableStream: {
                  value: false,
                  kind: OptionKind.API + OptionKind.PREFERENCE
                },
                docBaseUrl: {
                  value: "",
                  kind: OptionKind.API
                },
                enableXfa: {
                  value: true,
                  kind: OptionKind.API + OptionKind.PREFERENCE
                },
                fontExtraProperties: {
                  value: false,
                  kind: OptionKind.API
                },
                isEvalSupported: {
                  value: true,
                  kind: OptionKind.API
                },
                maxImageSize: {
                  value: -1,
                  kind: OptionKind.API
                },
                pdfBug: {
                  value: false,
                  kind: OptionKind.API
                },
                standardFontDataUrl: {
                  value: "../web/standard_fonts/",
                  kind: OptionKind.API
                },
                verbosity: {
                  value: 1,
                  kind: OptionKind.API
                },
                workerPort: {
                  value: null,
                  kind: OptionKind.WORKER
                },
                workerSrc: {
                  value: "../build/pdf.worker.js",
                  kind: OptionKind.WORKER
                }
              };
              {
                defaultOptions.defaultUrl = {
                  value: "compressed.tracemonkey-pldi-09.pdf",
                  kind: OptionKind.VIEWER
                };
                defaultOptions.disablePreferences = {
                  value: false,
                  kind: OptionKind.VIEWER
                };
                defaultOptions.locale = {
                  value: navigator.language || "en-US",
                  kind: OptionKind.VIEWER
                };
                defaultOptions.renderer = {
                  value: "canvas",
                  kind: OptionKind.VIEWER + OptionKind.PREFERENCE
                };
                defaultOptions.sandboxBundleSrc = {
                  value: "../build/pdf.sandbox.js",
                  kind: OptionKind.VIEWER
                };
              }
              const userOptions = /* @__PURE__ */ Object.create(null);
              class AppOptions {
                constructor() {
                  throw new Error("Cannot initialize AppOptions.");
                }
                static get(name) {
                  const userOption = userOptions[name];
                  if (userOption !== void 0) {
                    return userOption;
                  }
                  const defaultOption = defaultOptions[name];
                  if (defaultOption !== void 0) {
                    var _compatibilityParams$;
                    return (_compatibilityParams$ = compatibilityParams[name]) !== null && _compatibilityParams$ !== void 0 ? _compatibilityParams$ : defaultOption.value;
                  }
                  return void 0;
                }
                static getAll() {
                  let kind = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
                  const options = /* @__PURE__ */ Object.create(null);
                  for (const name in defaultOptions) {
                    var _compatibilityParams$2;
                    const defaultOption = defaultOptions[name];
                    if (kind) {
                      if ((kind & defaultOption.kind) === 0) {
                        continue;
                      }
                      if (kind === OptionKind.PREFERENCE) {
                        const value = defaultOption.value, valueType = typeof value;
                        if (valueType === "boolean" || valueType === "string" || valueType === "number" && Number.isInteger(value)) {
                          options[name] = value;
                          continue;
                        }
                        throw new Error(`Invalid type for preference: ${name}`);
                      }
                    }
                    const userOption = userOptions[name];
                    options[name] = userOption !== void 0 ? userOption : (_compatibilityParams$2 = compatibilityParams[name]) !== null && _compatibilityParams$2 !== void 0 ? _compatibilityParams$2 : defaultOption.value;
                  }
                  return options;
                }
                static set(name, value) {
                  userOptions[name] = value;
                }
                static setAll(options) {
                  for (const name in options) {
                    userOptions[name] = options[name];
                  }
                }
                static remove(name) {
                  delete userOptions[name];
                }
                static _hasUserOptions() {
                  return Object.keys(userOptions).length > 0;
                }
              }
              exports3.AppOptions = AppOptions;
            },
            /* 15 */
            /***/
            (__unused_webpack_module2, exports3, __w_pdfjs_require__3) => {
              Object.defineProperty(exports3, "__esModule", {
                value: true
              });
              exports3.TextAccessibilityManager = void 0;
              var _ui_utils = __w_pdfjs_require__3(7);
              function _classPrivateMethodInitSpec2(obj, privateSet) {
                _checkPrivateRedeclaration2(obj, privateSet);
                privateSet.add(obj);
              }
              function _classPrivateFieldInitSpec2(obj, privateMap, value) {
                _checkPrivateRedeclaration2(obj, privateMap);
                privateMap.set(obj, value);
              }
              function _checkPrivateRedeclaration2(obj, privateCollection) {
                if (privateCollection.has(obj)) {
                  throw new TypeError("Cannot initialize the same private elements twice on an object");
                }
              }
              function _classPrivateMethodGet2(receiver, privateSet, fn) {
                if (!privateSet.has(receiver)) {
                  throw new TypeError("attempted to get private field on non-instance");
                }
                return fn;
              }
              function _classStaticPrivateMethodGet(receiver, classConstructor, method) {
                _classCheckPrivateStaticAccess2(receiver, classConstructor);
                return method;
              }
              function _classCheckPrivateStaticAccess2(receiver, classConstructor) {
                if (receiver !== classConstructor) {
                  throw new TypeError("Private static access of wrong provenance");
                }
              }
              function _classPrivateFieldGet2(receiver, privateMap) {
                var descriptor = _classExtractFieldDescriptor2(receiver, privateMap, "get");
                return _classApplyDescriptorGet2(receiver, descriptor);
              }
              function _classApplyDescriptorGet2(receiver, descriptor) {
                if (descriptor.get) {
                  return descriptor.get.call(receiver);
                }
                return descriptor.value;
              }
              function _classPrivateFieldSet2(receiver, privateMap, value) {
                var descriptor = _classExtractFieldDescriptor2(receiver, privateMap, "set");
                _classApplyDescriptorSet2(receiver, descriptor, value);
                return value;
              }
              function _classExtractFieldDescriptor2(receiver, privateMap, action) {
                if (!privateMap.has(receiver)) {
                  throw new TypeError("attempted to " + action + " private field on non-instance");
                }
                return privateMap.get(receiver);
              }
              function _classApplyDescriptorSet2(receiver, descriptor, value) {
                if (descriptor.set) {
                  descriptor.set.call(receiver, value);
                } else {
                  if (!descriptor.writable) {
                    throw new TypeError("attempted to set read only private field");
                  }
                  descriptor.value = value;
                }
              }
              var _enabled = /* @__PURE__ */ new WeakMap();
              var _textChildren = /* @__PURE__ */ new WeakMap();
              var _textNodes = /* @__PURE__ */ new WeakMap();
              var _waitingElements = /* @__PURE__ */ new WeakMap();
              var _addIdToAriaOwns = /* @__PURE__ */ new WeakSet();
              class TextAccessibilityManager {
                constructor() {
                  _classPrivateMethodInitSpec2(this, _addIdToAriaOwns);
                  _classPrivateFieldInitSpec2(this, _enabled, {
                    writable: true,
                    value: false
                  });
                  _classPrivateFieldInitSpec2(this, _textChildren, {
                    writable: true,
                    value: null
                  });
                  _classPrivateFieldInitSpec2(this, _textNodes, {
                    writable: true,
                    value: /* @__PURE__ */ new Map()
                  });
                  _classPrivateFieldInitSpec2(this, _waitingElements, {
                    writable: true,
                    value: /* @__PURE__ */ new Map()
                  });
                }
                setTextMapping(textDivs) {
                  _classPrivateFieldSet2(this, _textChildren, textDivs);
                }
                enable() {
                  if (_classPrivateFieldGet2(this, _enabled)) {
                    throw new Error("TextAccessibilityManager is already enabled.");
                  }
                  if (!_classPrivateFieldGet2(this, _textChildren)) {
                    throw new Error("Text divs and strings have not been set.");
                  }
                  _classPrivateFieldSet2(this, _enabled, true);
                  _classPrivateFieldSet2(this, _textChildren, _classPrivateFieldGet2(this, _textChildren).slice());
                  _classPrivateFieldGet2(this, _textChildren).sort(_classStaticPrivateMethodGet(TextAccessibilityManager, TextAccessibilityManager, _compareElementPositions));
                  if (_classPrivateFieldGet2(this, _textNodes).size > 0) {
                    const textChildren = _classPrivateFieldGet2(this, _textChildren);
                    for (const [id, nodeIndex] of _classPrivateFieldGet2(this, _textNodes)) {
                      const element = document.getElementById(id);
                      if (!element) {
                        _classPrivateFieldGet2(this, _textNodes).delete(id);
                        continue;
                      }
                      _classPrivateMethodGet2(this, _addIdToAriaOwns, _addIdToAriaOwns2).call(this, id, textChildren[nodeIndex]);
                    }
                  }
                  for (const [element, isRemovable] of _classPrivateFieldGet2(this, _waitingElements)) {
                    this.addPointerInTextLayer(element, isRemovable);
                  }
                  _classPrivateFieldGet2(this, _waitingElements).clear();
                }
                disable() {
                  if (!_classPrivateFieldGet2(this, _enabled)) {
                    return;
                  }
                  _classPrivateFieldGet2(this, _waitingElements).clear();
                  _classPrivateFieldSet2(this, _textChildren, null);
                  _classPrivateFieldSet2(this, _enabled, false);
                }
                removePointerInTextLayer(element) {
                  var _owns;
                  if (!_classPrivateFieldGet2(this, _enabled)) {
                    _classPrivateFieldGet2(this, _waitingElements).delete(element);
                    return;
                  }
                  const children = _classPrivateFieldGet2(this, _textChildren);
                  if (!children || children.length === 0) {
                    return;
                  }
                  const {
                    id
                  } = element;
                  const nodeIndex = _classPrivateFieldGet2(this, _textNodes).get(id);
                  if (nodeIndex === void 0) {
                    return;
                  }
                  const node = children[nodeIndex];
                  _classPrivateFieldGet2(this, _textNodes).delete(id);
                  let owns = node.getAttribute("aria-owns");
                  if ((_owns = owns) !== null && _owns !== void 0 && _owns.includes(id)) {
                    owns = owns.split(" ").filter((x) => x !== id).join(" ");
                    if (owns) {
                      node.setAttribute("aria-owns", owns);
                    } else {
                      node.removeAttribute("aria-owns");
                      node.setAttribute("role", "presentation");
                    }
                  }
                }
                addPointerInTextLayer(element, isRemovable) {
                  const {
                    id
                  } = element;
                  if (!id) {
                    return;
                  }
                  if (!_classPrivateFieldGet2(this, _enabled)) {
                    _classPrivateFieldGet2(this, _waitingElements).set(element, isRemovable);
                    return;
                  }
                  if (isRemovable) {
                    this.removePointerInTextLayer(element);
                  }
                  const children = _classPrivateFieldGet2(this, _textChildren);
                  if (!children || children.length === 0) {
                    return;
                  }
                  const index = (0, _ui_utils.binarySearchFirstItem)(children, (node) => _classStaticPrivateMethodGet(TextAccessibilityManager, TextAccessibilityManager, _compareElementPositions).call(TextAccessibilityManager, element, node) < 0);
                  const nodeIndex = Math.max(0, index - 1);
                  _classPrivateMethodGet2(this, _addIdToAriaOwns, _addIdToAriaOwns2).call(this, id, children[nodeIndex]);
                  _classPrivateFieldGet2(this, _textNodes).set(id, nodeIndex);
                }
                moveElementInDOM(container, element, contentElement, isRemovable) {
                  this.addPointerInTextLayer(contentElement, isRemovable);
                  if (!container.hasChildNodes()) {
                    container.append(element);
                    return;
                  }
                  const children = Array.from(container.childNodes).filter((node) => node !== element);
                  if (children.length === 0) {
                    return;
                  }
                  const elementToCompare = contentElement || element;
                  const index = (0, _ui_utils.binarySearchFirstItem)(children, (node) => _classStaticPrivateMethodGet(TextAccessibilityManager, TextAccessibilityManager, _compareElementPositions).call(TextAccessibilityManager, elementToCompare, node) < 0);
                  if (index === 0) {
                    children[0].before(element);
                  } else {
                    children[index - 1].after(element);
                  }
                }
              }
              exports3.TextAccessibilityManager = TextAccessibilityManager;
              function _compareElementPositions(e1, e2) {
                const rect1 = e1.getBoundingClientRect();
                const rect2 = e2.getBoundingClientRect();
                if (rect1.width === 0 && rect1.height === 0) {
                  return 1;
                }
                if (rect2.width === 0 && rect2.height === 0) {
                  return -1;
                }
                const top1 = rect1.y;
                const bot1 = rect1.y + rect1.height;
                const mid1 = rect1.y + rect1.height / 2;
                const top2 = rect2.y;
                const bot2 = rect2.y + rect2.height;
                const mid2 = rect2.y + rect2.height / 2;
                if (mid1 <= top2 && mid2 >= bot1) {
                  return -1;
                }
                if (mid2 <= top1 && mid1 >= bot2) {
                  return 1;
                }
                const centerX1 = rect1.x + rect1.width / 2;
                const centerX2 = rect2.x + rect2.width / 2;
                return centerX1 - centerX2;
              }
              function _addIdToAriaOwns2(id, node) {
                const owns = node.getAttribute("aria-owns");
                if (!(owns !== null && owns !== void 0 && owns.includes(id))) {
                  node.setAttribute("aria-owns", owns ? `${owns} ${id}` : id);
                }
                node.removeAttribute("role");
              }
            },
            /* 16 */
            /***/
            (__unused_webpack_module2, exports3, __w_pdfjs_require__3) => {
              Object.defineProperty(exports3, "__esModule", {
                value: true
              });
              exports3.PDFRenderingQueue = void 0;
              var _pdfjsLib = __w_pdfjs_require__3(3);
              var _ui_utils = __w_pdfjs_require__3(7);
              const CLEANUP_TIMEOUT = 3e4;
              class PDFRenderingQueue {
                constructor() {
                  this.pdfViewer = null;
                  this.pdfThumbnailViewer = null;
                  this.onIdle = null;
                  this.highestPriorityPage = null;
                  this.idleTimeout = null;
                  this.printing = false;
                  this.isThumbnailViewEnabled = false;
                }
                setViewer(pdfViewer) {
                  this.pdfViewer = pdfViewer;
                }
                setThumbnailViewer(pdfThumbnailViewer) {
                  this.pdfThumbnailViewer = pdfThumbnailViewer;
                }
                isHighestPriority(view) {
                  return this.highestPriorityPage === view.renderingId;
                }
                hasViewer() {
                  return !!this.pdfViewer;
                }
                renderHighestPriority(currentlyVisiblePages) {
                  var _this$pdfThumbnailVie;
                  if (this.idleTimeout) {
                    clearTimeout(this.idleTimeout);
                    this.idleTimeout = null;
                  }
                  if (this.pdfViewer.forceRendering(currentlyVisiblePages)) {
                    return;
                  }
                  if (this.isThumbnailViewEnabled && (_this$pdfThumbnailVie = this.pdfThumbnailViewer) !== null && _this$pdfThumbnailVie !== void 0 && _this$pdfThumbnailVie.forceRendering()) {
                    return;
                  }
                  if (this.printing) {
                    return;
                  }
                  if (this.onIdle) {
                    this.idleTimeout = setTimeout(this.onIdle.bind(this), CLEANUP_TIMEOUT);
                  }
                }
                getHighestPriority(visible, views, scrolledDown) {
                  let preRenderExtra = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
                  const visibleViews = visible.views, numVisible = visibleViews.length;
                  if (numVisible === 0) {
                    return null;
                  }
                  for (let i = 0; i < numVisible; i++) {
                    const view = visibleViews[i].view;
                    if (!this.isViewFinished(view)) {
                      return view;
                    }
                  }
                  const firstId = visible.first.id, lastId = visible.last.id;
                  if (lastId - firstId + 1 > numVisible) {
                    const visibleIds = visible.ids;
                    for (let i = 1, ii = lastId - firstId; i < ii; i++) {
                      const holeId = scrolledDown ? firstId + i : lastId - i;
                      if (visibleIds.has(holeId)) {
                        continue;
                      }
                      const holeView = views[holeId - 1];
                      if (!this.isViewFinished(holeView)) {
                        return holeView;
                      }
                    }
                  }
                  let preRenderIndex = scrolledDown ? lastId : firstId - 2;
                  let preRenderView = views[preRenderIndex];
                  if (preRenderView && !this.isViewFinished(preRenderView)) {
                    return preRenderView;
                  }
                  if (preRenderExtra) {
                    preRenderIndex += scrolledDown ? 1 : -1;
                    preRenderView = views[preRenderIndex];
                    if (preRenderView && !this.isViewFinished(preRenderView)) {
                      return preRenderView;
                    }
                  }
                  return null;
                }
                isViewFinished(view) {
                  return view.renderingState === _ui_utils.RenderingStates.FINISHED;
                }
                renderView(view) {
                  switch (view.renderingState) {
                    case _ui_utils.RenderingStates.FINISHED:
                      return false;
                    case _ui_utils.RenderingStates.PAUSED:
                      this.highestPriorityPage = view.renderingId;
                      view.resume();
                      break;
                    case _ui_utils.RenderingStates.RUNNING:
                      this.highestPriorityPage = view.renderingId;
                      break;
                    case _ui_utils.RenderingStates.INITIAL:
                      this.highestPriorityPage = view.renderingId;
                      view.draw().finally(() => {
                        this.renderHighestPriority();
                      }).catch((reason) => {
                        if (reason instanceof _pdfjsLib.RenderingCancelledException) {
                          return;
                        }
                        console.error(`renderView: "${reason}"`);
                      });
                      break;
                  }
                  return true;
                }
              }
              exports3.PDFRenderingQueue = PDFRenderingQueue;
            },
            /* 17 */
            /***/
            (__unused_webpack_module2, exports3) => {
              Object.defineProperty(exports3, "__esModule", {
                value: true
              });
              exports3.TextHighlighter = void 0;
              class TextHighlighter {
                constructor(_ref) {
                  let {
                    findController,
                    eventBus,
                    pageIndex
                  } = _ref;
                  this.findController = findController;
                  this.matches = [];
                  this.eventBus = eventBus;
                  this.pageIdx = pageIndex;
                  this._onUpdateTextLayerMatches = null;
                  this.textDivs = null;
                  this.textContentItemsStr = null;
                  this.enabled = false;
                }
                setTextMapping(divs, texts) {
                  this.textDivs = divs;
                  this.textContentItemsStr = texts;
                }
                enable() {
                  if (!this.textDivs || !this.textContentItemsStr) {
                    throw new Error("Text divs and strings have not been set.");
                  }
                  if (this.enabled) {
                    throw new Error("TextHighlighter is already enabled.");
                  }
                  this.enabled = true;
                  if (!this._onUpdateTextLayerMatches) {
                    this._onUpdateTextLayerMatches = (evt) => {
                      if (evt.pageIndex === this.pageIdx || evt.pageIndex === -1) {
                        this._updateMatches();
                      }
                    };
                    this.eventBus._on("updatetextlayermatches", this._onUpdateTextLayerMatches);
                  }
                  this._updateMatches();
                }
                disable() {
                  if (!this.enabled) {
                    return;
                  }
                  this.enabled = false;
                  if (this._onUpdateTextLayerMatches) {
                    this.eventBus._off("updatetextlayermatches", this._onUpdateTextLayerMatches);
                    this._onUpdateTextLayerMatches = null;
                  }
                }
                _convertMatches(matches, matchesLength) {
                  if (!matches) {
                    return [];
                  }
                  const {
                    textContentItemsStr
                  } = this;
                  let i = 0, iIndex = 0;
                  const end = textContentItemsStr.length - 1;
                  const result = [];
                  for (let m = 0, mm = matches.length; m < mm; m++) {
                    let matchIdx = matches[m];
                    while (i !== end && matchIdx >= iIndex + textContentItemsStr[i].length) {
                      iIndex += textContentItemsStr[i].length;
                      i++;
                    }
                    if (i === textContentItemsStr.length) {
                      console.error("Could not find a matching mapping");
                    }
                    const match = {
                      begin: {
                        divIdx: i,
                        offset: matchIdx - iIndex
                      }
                    };
                    matchIdx += matchesLength[m];
                    while (i !== end && matchIdx > iIndex + textContentItemsStr[i].length) {
                      iIndex += textContentItemsStr[i].length;
                      i++;
                    }
                    match.end = {
                      divIdx: i,
                      offset: matchIdx - iIndex
                    };
                    result.push(match);
                  }
                  return result;
                }
                _renderMatches(matches) {
                  if (matches.length === 0) {
                    return;
                  }
                  const {
                    findController,
                    pageIdx
                  } = this;
                  const {
                    textContentItemsStr,
                    textDivs
                  } = this;
                  const isSelectedPage = pageIdx === findController.selected.pageIdx;
                  const selectedMatchIdx = findController.selected.matchIdx;
                  const highlightAll = findController.state.highlightAll;
                  let prevEnd = null;
                  const infinity = {
                    divIdx: -1,
                    offset: void 0
                  };
                  function beginText(begin, className) {
                    const divIdx = begin.divIdx;
                    textDivs[divIdx].textContent = "";
                    return appendTextToDiv(divIdx, 0, begin.offset, className);
                  }
                  function appendTextToDiv(divIdx, fromOffset, toOffset, className) {
                    let div = textDivs[divIdx];
                    if (div.nodeType === Node.TEXT_NODE) {
                      const span = document.createElement("span");
                      div.before(span);
                      span.append(div);
                      textDivs[divIdx] = span;
                      div = span;
                    }
                    const content = textContentItemsStr[divIdx].substring(fromOffset, toOffset);
                    const node = document.createTextNode(content);
                    if (className) {
                      const span = document.createElement("span");
                      span.className = `${className} appended`;
                      span.append(node);
                      div.append(span);
                      return className.includes("selected") ? span.offsetLeft : 0;
                    }
                    div.append(node);
                    return 0;
                  }
                  let i0 = selectedMatchIdx, i1 = i0 + 1;
                  if (highlightAll) {
                    i0 = 0;
                    i1 = matches.length;
                  } else if (!isSelectedPage) {
                    return;
                  }
                  for (let i = i0; i < i1; i++) {
                    const match = matches[i];
                    const begin = match.begin;
                    const end = match.end;
                    const isSelected = isSelectedPage && i === selectedMatchIdx;
                    const highlightSuffix = isSelected ? " selected" : "";
                    let selectedLeft = 0;
                    if (!prevEnd || begin.divIdx !== prevEnd.divIdx) {
                      if (prevEnd !== null) {
                        appendTextToDiv(prevEnd.divIdx, prevEnd.offset, infinity.offset);
                      }
                      beginText(begin);
                    } else {
                      appendTextToDiv(prevEnd.divIdx, prevEnd.offset, begin.offset);
                    }
                    if (begin.divIdx === end.divIdx) {
                      selectedLeft = appendTextToDiv(begin.divIdx, begin.offset, end.offset, "highlight" + highlightSuffix);
                    } else {
                      selectedLeft = appendTextToDiv(begin.divIdx, begin.offset, infinity.offset, "highlight begin" + highlightSuffix);
                      for (let n0 = begin.divIdx + 1, n1 = end.divIdx; n0 < n1; n0++) {
                        textDivs[n0].className = "highlight middle" + highlightSuffix;
                      }
                      beginText(end, "highlight end" + highlightSuffix);
                    }
                    prevEnd = end;
                    if (isSelected) {
                      findController.scrollMatchIntoView({
                        element: textDivs[begin.divIdx],
                        selectedLeft,
                        pageIndex: pageIdx,
                        matchIndex: selectedMatchIdx
                      });
                    }
                  }
                  if (prevEnd) {
                    appendTextToDiv(prevEnd.divIdx, prevEnd.offset, infinity.offset);
                  }
                }
                _updateMatches() {
                  if (!this.enabled) {
                    return;
                  }
                  const {
                    findController,
                    matches,
                    pageIdx
                  } = this;
                  const {
                    textContentItemsStr,
                    textDivs
                  } = this;
                  let clearedUntilDivIdx = -1;
                  for (let i = 0, ii = matches.length; i < ii; i++) {
                    const match = matches[i];
                    const begin = Math.max(clearedUntilDivIdx, match.begin.divIdx);
                    for (let n = begin, end = match.end.divIdx; n <= end; n++) {
                      const div = textDivs[n];
                      div.textContent = textContentItemsStr[n];
                      div.className = "";
                    }
                    clearedUntilDivIdx = match.end.divIdx + 1;
                  }
                  if (!(findController !== null && findController !== void 0 && findController.highlightMatches)) {
                    return;
                  }
                  const pageMatches = findController.pageMatches[pageIdx] || null;
                  const pageMatchesLength = findController.pageMatchesLength[pageIdx] || null;
                  this.matches = this._convertMatches(pageMatches, pageMatchesLength);
                  this._renderMatches(this.matches);
                }
              }
              exports3.TextHighlighter = TextHighlighter;
            },
            /* 18 */
            /***/
            (__unused_webpack_module2, exports3, __w_pdfjs_require__3) => {
              Object.defineProperty(exports3, "__esModule", {
                value: true
              });
              exports3.DownloadManager = void 0;
              var _pdfjsLib = __w_pdfjs_require__3(3);
              ;
              function download(blobUrl, filename) {
                const a = document.createElement("a");
                if (!a.click) {
                  throw new Error('DownloadManager: "a.click()" is not supported.');
                }
                a.href = blobUrl;
                a.target = "_parent";
                if ("download" in a) {
                  a.download = filename;
                }
                (document.body || document.documentElement).append(a);
                a.click();
                a.remove();
              }
              class DownloadManager {
                constructor() {
                  this._openBlobUrls = /* @__PURE__ */ new WeakMap();
                }
                downloadUrl(url, filename) {
                  if (!(0, _pdfjsLib.createValidAbsoluteUrl)(url, "http://example.com")) {
                    console.error(`downloadUrl - not a valid URL: ${url}`);
                    return;
                  }
                  download(url + "#pdfjs.action=download", filename);
                }
                downloadData(data, filename, contentType) {
                  const blobUrl = URL.createObjectURL(new Blob([data], {
                    type: contentType
                  }));
                  download(blobUrl, filename);
                }
                openOrDownloadData(element, data, filename) {
                  const isPdfData = (0, _pdfjsLib.isPdfFile)(filename);
                  const contentType = isPdfData ? "application/pdf" : "";
                  if (isPdfData) {
                    let blobUrl = this._openBlobUrls.get(element);
                    if (!blobUrl) {
                      blobUrl = URL.createObjectURL(new Blob([data], {
                        type: contentType
                      }));
                      this._openBlobUrls.set(element, blobUrl);
                    }
                    let viewerUrl;
                    viewerUrl = "?file=" + encodeURIComponent(blobUrl + "#" + filename);
                    try {
                      window.open(viewerUrl);
                      return true;
                    } catch (ex) {
                      console.error(`openOrDownloadData: ${ex}`);
                      URL.revokeObjectURL(blobUrl);
                      this._openBlobUrls.delete(element);
                    }
                  }
                  this.downloadData(data, filename, contentType);
                  return false;
                }
                download(blob, url, filename) {
                  const blobUrl = URL.createObjectURL(blob);
                  download(blobUrl, filename);
                }
              }
              exports3.DownloadManager = DownloadManager;
            },
            /* 19 */
            /***/
            (__unused_webpack_module2, exports3) => {
              Object.defineProperty(exports3, "__esModule", {
                value: true
              });
              exports3.WaitOnType = exports3.EventBus = exports3.AutomationEventBus = void 0;
              exports3.waitOnEventOrTimeout = waitOnEventOrTimeout;
              const WaitOnType = {
                EVENT: "event",
                TIMEOUT: "timeout"
              };
              exports3.WaitOnType = WaitOnType;
              function waitOnEventOrTimeout(_ref) {
                let {
                  target,
                  name,
                  delay = 0
                } = _ref;
                return new Promise(function(resolve, reject) {
                  if (typeof target !== "object" || !(name && typeof name === "string") || !(Number.isInteger(delay) && delay >= 0)) {
                    throw new Error("waitOnEventOrTimeout - invalid parameters.");
                  }
                  function handler(type) {
                    if (target instanceof EventBus2) {
                      target._off(name, eventHandler);
                    } else {
                      target.removeEventListener(name, eventHandler);
                    }
                    if (timeout) {
                      clearTimeout(timeout);
                    }
                    resolve(type);
                  }
                  const eventHandler = handler.bind(null, WaitOnType.EVENT);
                  if (target instanceof EventBus2) {
                    target._on(name, eventHandler);
                  } else {
                    target.addEventListener(name, eventHandler);
                  }
                  const timeoutHandler = handler.bind(null, WaitOnType.TIMEOUT);
                  const timeout = setTimeout(timeoutHandler, delay);
                });
              }
              class EventBus2 {
                constructor() {
                  this._listeners = /* @__PURE__ */ Object.create(null);
                }
                on(eventName, listener) {
                  let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
                  this._on(eventName, listener, {
                    external: true,
                    once: options === null || options === void 0 ? void 0 : options.once
                  });
                }
                off(eventName, listener) {
                  let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
                  this._off(eventName, listener, {
                    external: true,
                    once: options === null || options === void 0 ? void 0 : options.once
                  });
                }
                dispatch(eventName, data) {
                  const eventListeners = this._listeners[eventName];
                  if (!eventListeners || eventListeners.length === 0) {
                    return;
                  }
                  let externalListeners;
                  for (const {
                    listener,
                    external,
                    once
                  } of eventListeners.slice(0)) {
                    if (once) {
                      this._off(eventName, listener);
                    }
                    if (external) {
                      (externalListeners || (externalListeners = [])).push(listener);
                      continue;
                    }
                    listener(data);
                  }
                  if (externalListeners) {
                    for (const listener of externalListeners) {
                      listener(data);
                    }
                    externalListeners = null;
                  }
                }
                _on(eventName, listener) {
                  var _this$_listeners;
                  let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
                  const eventListeners = (_this$_listeners = this._listeners)[eventName] || (_this$_listeners[eventName] = []);
                  eventListeners.push({
                    listener,
                    external: (options === null || options === void 0 ? void 0 : options.external) === true,
                    once: (options === null || options === void 0 ? void 0 : options.once) === true
                  });
                }
                _off(eventName, listener) {
                  let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
                  const eventListeners = this._listeners[eventName];
                  if (!eventListeners) {
                    return;
                  }
                  for (let i = 0, ii = eventListeners.length; i < ii; i++) {
                    if (eventListeners[i].listener === listener) {
                      eventListeners.splice(i, 1);
                      return;
                    }
                  }
                }
              }
              exports3.EventBus = EventBus2;
              class AutomationEventBus extends EventBus2 {
                dispatch(eventName, data) {
                  throw new Error("Not implemented: AutomationEventBus.dispatch");
                }
              }
              exports3.AutomationEventBus = AutomationEventBus;
            },
            /* 20 */
            /***/
            (__unused_webpack_module2, exports3, __w_pdfjs_require__3) => {
              Object.defineProperty(exports3, "__esModule", {
                value: true
              });
              exports3.GenericL10n = void 0;
              __w_pdfjs_require__3(21);
              var _l10n_utils = __w_pdfjs_require__3(4);
              const webL10n = document.webL10n;
              class GenericL10n {
                constructor(lang) {
                  this._lang = lang;
                  this._ready = new Promise((resolve, reject) => {
                    webL10n.setLanguage((0, _l10n_utils.fixupLangCode)(lang), () => {
                      resolve(webL10n);
                    });
                  });
                }
                async getLanguage() {
                  const l10n = await this._ready;
                  return l10n.getLanguage();
                }
                async getDirection() {
                  const l10n = await this._ready;
                  return l10n.getDirection();
                }
                async get(key) {
                  let args = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
                  let fallback = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : (0, _l10n_utils.getL10nFallback)(key, args);
                  const l10n = await this._ready;
                  return l10n.get(key, args, fallback);
                }
                async translate(element) {
                  const l10n = await this._ready;
                  return l10n.translate(element);
                }
              }
              exports3.GenericL10n = GenericL10n;
            },
            /* 21 */
            /***/
            () => {
              document.webL10n = function(window2, document2, undefined2) {
                var gL10nData = {};
                var gTextData = "";
                var gTextProp = "textContent";
                var gLanguage = "";
                var gMacros = {};
                var gReadyState = "loading";
                var gAsyncResourceLoading = true;
                function getL10nResourceLinks() {
                  return document2.querySelectorAll('link[type="application/l10n"]');
                }
                function getL10nDictionary() {
                  var script = document2.querySelector('script[type="application/l10n"]');
                  return script ? JSON.parse(script.innerHTML) : null;
                }
                function getTranslatableChildren(element) {
                  return element ? element.querySelectorAll("*[data-l10n-id]") : [];
                }
                function getL10nAttributes(element) {
                  if (!element) return {};
                  var l10nId = element.getAttribute("data-l10n-id");
                  var l10nArgs = element.getAttribute("data-l10n-args");
                  var args = {};
                  if (l10nArgs) {
                    try {
                      args = JSON.parse(l10nArgs);
                    } catch (e) {
                      console.warn("could not parse arguments for #" + l10nId);
                    }
                  }
                  return {
                    id: l10nId,
                    args
                  };
                }
                function xhrLoadText(url, onSuccess, onFailure) {
                  onSuccess = onSuccess || function _onSuccess(data) {
                  };
                  onFailure = onFailure || function _onFailure() {
                  };
                  var xhr = new XMLHttpRequest();
                  xhr.open("GET", url, gAsyncResourceLoading);
                  if (xhr.overrideMimeType) {
                    xhr.overrideMimeType("text/plain; charset=utf-8");
                  }
                  xhr.onreadystatechange = function() {
                    if (xhr.readyState == 4) {
                      if (xhr.status == 200 || xhr.status === 0) {
                        onSuccess(xhr.responseText);
                      } else {
                        onFailure();
                      }
                    }
                  };
                  xhr.onerror = onFailure;
                  xhr.ontimeout = onFailure;
                  try {
                    xhr.send(null);
                  } catch (e) {
                    onFailure();
                  }
                }
                function parseResource(href, lang, successCallback, failureCallback) {
                  var baseURL = href.replace(/[^\/]*$/, "") || "./";
                  function evalString(text) {
                    if (text.lastIndexOf("\\") < 0) return text;
                    return text.replace(/\\\\/g, "\\").replace(/\\n/g, "\n").replace(/\\r/g, "\r").replace(/\\t/g, "	").replace(/\\b/g, "\b").replace(/\\f/g, "\f").replace(/\\{/g, "{").replace(/\\}/g, "}").replace(/\\"/g, '"').replace(/\\'/g, "'");
                  }
                  function parseProperties(text, parsedPropertiesCallback) {
                    var dictionary = {};
                    var reBlank = /^\s*|\s*$/;
                    var reComment = /^\s*#|^\s*$/;
                    var reSection = /^\s*\[(.*)\]\s*$/;
                    var reImport = /^\s*@import\s+url\((.*)\)\s*$/i;
                    var reSplit = /^([^=\s]*)\s*=\s*(.+)$/;
                    function parseRawLines(rawText, extendedSyntax, parsedRawLinesCallback) {
                      var entries = rawText.replace(reBlank, "").split(/[\r\n]+/);
                      var currentLang = "*";
                      var genericLang = lang.split("-", 1)[0];
                      var skipLang = false;
                      var match = "";
                      function nextEntry() {
                        while (true) {
                          if (!entries.length) {
                            parsedRawLinesCallback();
                            return;
                          }
                          var line = entries.shift();
                          if (reComment.test(line)) continue;
                          if (extendedSyntax) {
                            match = reSection.exec(line);
                            if (match) {
                              currentLang = match[1].toLowerCase();
                              skipLang = currentLang !== "*" && currentLang !== lang && currentLang !== genericLang;
                              continue;
                            } else if (skipLang) {
                              continue;
                            }
                            match = reImport.exec(line);
                            if (match) {
                              loadImport(baseURL + match[1], nextEntry);
                              return;
                            }
                          }
                          var tmp = line.match(reSplit);
                          if (tmp && tmp.length == 3) {
                            dictionary[tmp[1]] = evalString(tmp[2]);
                          }
                        }
                      }
                      nextEntry();
                    }
                    function loadImport(url, callback) {
                      xhrLoadText(url, function(content) {
                        parseRawLines(content, false, callback);
                      }, function() {
                        console.warn(url + " not found.");
                        callback();
                      });
                    }
                    parseRawLines(text, true, function() {
                      parsedPropertiesCallback(dictionary);
                    });
                  }
                  xhrLoadText(href, function(response) {
                    gTextData += response;
                    parseProperties(response, function(data) {
                      for (var key in data) {
                        var id, prop, index = key.lastIndexOf(".");
                        if (index > 0) {
                          id = key.substring(0, index);
                          prop = key.substring(index + 1);
                        } else {
                          id = key;
                          prop = gTextProp;
                        }
                        if (!gL10nData[id]) {
                          gL10nData[id] = {};
                        }
                        gL10nData[id][prop] = data[key];
                      }
                      if (successCallback) {
                        successCallback();
                      }
                    });
                  }, failureCallback);
                }
                function loadLocale(lang, callback) {
                  if (lang) {
                    lang = lang.toLowerCase();
                  }
                  callback = callback || function _callback() {
                  };
                  clear();
                  gLanguage = lang;
                  var langLinks = getL10nResourceLinks();
                  var langCount = langLinks.length;
                  if (langCount === 0) {
                    var dict = getL10nDictionary();
                    if (dict && dict.locales && dict.default_locale) {
                      console.log("using the embedded JSON directory, early way out");
                      gL10nData = dict.locales[lang];
                      if (!gL10nData) {
                        var defaultLocale = dict.default_locale.toLowerCase();
                        for (var anyCaseLang in dict.locales) {
                          anyCaseLang = anyCaseLang.toLowerCase();
                          if (anyCaseLang === lang) {
                            gL10nData = dict.locales[lang];
                            break;
                          } else if (anyCaseLang === defaultLocale) {
                            gL10nData = dict.locales[defaultLocale];
                          }
                        }
                      }
                      callback();
                    } else {
                      console.log("no resource to load, early way out");
                    }
                    gReadyState = "complete";
                    return;
                  }
                  var onResourceLoaded = null;
                  var gResourceCount = 0;
                  onResourceLoaded = function() {
                    gResourceCount++;
                    if (gResourceCount >= langCount) {
                      callback();
                      gReadyState = "complete";
                    }
                  };
                  function L10nResourceLink(link) {
                    var href = link.href;
                    this.load = function(lang2, callback2) {
                      parseResource(href, lang2, callback2, function() {
                        console.warn(href + " not found.");
                        console.warn('"' + lang2 + '" resource not found');
                        gLanguage = "";
                        callback2();
                      });
                    };
                  }
                  for (var i = 0; i < langCount; i++) {
                    var resource = new L10nResourceLink(langLinks[i]);
                    resource.load(lang, onResourceLoaded);
                  }
                }
                function clear() {
                  gL10nData = {};
                  gTextData = "";
                  gLanguage = "";
                }
                function getPluralRules(lang) {
                  var locales2rules = {
                    "af": 3,
                    "ak": 4,
                    "am": 4,
                    "ar": 1,
                    "asa": 3,
                    "az": 0,
                    "be": 11,
                    "bem": 3,
                    "bez": 3,
                    "bg": 3,
                    "bh": 4,
                    "bm": 0,
                    "bn": 3,
                    "bo": 0,
                    "br": 20,
                    "brx": 3,
                    "bs": 11,
                    "ca": 3,
                    "cgg": 3,
                    "chr": 3,
                    "cs": 12,
                    "cy": 17,
                    "da": 3,
                    "de": 3,
                    "dv": 3,
                    "dz": 0,
                    "ee": 3,
                    "el": 3,
                    "en": 3,
                    "eo": 3,
                    "es": 3,
                    "et": 3,
                    "eu": 3,
                    "fa": 0,
                    "ff": 5,
                    "fi": 3,
                    "fil": 4,
                    "fo": 3,
                    "fr": 5,
                    "fur": 3,
                    "fy": 3,
                    "ga": 8,
                    "gd": 24,
                    "gl": 3,
                    "gsw": 3,
                    "gu": 3,
                    "guw": 4,
                    "gv": 23,
                    "ha": 3,
                    "haw": 3,
                    "he": 2,
                    "hi": 4,
                    "hr": 11,
                    "hu": 0,
                    "id": 0,
                    "ig": 0,
                    "ii": 0,
                    "is": 3,
                    "it": 3,
                    "iu": 7,
                    "ja": 0,
                    "jmc": 3,
                    "jv": 0,
                    "ka": 0,
                    "kab": 5,
                    "kaj": 3,
                    "kcg": 3,
                    "kde": 0,
                    "kea": 0,
                    "kk": 3,
                    "kl": 3,
                    "km": 0,
                    "kn": 0,
                    "ko": 0,
                    "ksb": 3,
                    "ksh": 21,
                    "ku": 3,
                    "kw": 7,
                    "lag": 18,
                    "lb": 3,
                    "lg": 3,
                    "ln": 4,
                    "lo": 0,
                    "lt": 10,
                    "lv": 6,
                    "mas": 3,
                    "mg": 4,
                    "mk": 16,
                    "ml": 3,
                    "mn": 3,
                    "mo": 9,
                    "mr": 3,
                    "ms": 0,
                    "mt": 15,
                    "my": 0,
                    "nah": 3,
                    "naq": 7,
                    "nb": 3,
                    "nd": 3,
                    "ne": 3,
                    "nl": 3,
                    "nn": 3,
                    "no": 3,
                    "nr": 3,
                    "nso": 4,
                    "ny": 3,
                    "nyn": 3,
                    "om": 3,
                    "or": 3,
                    "pa": 3,
                    "pap": 3,
                    "pl": 13,
                    "ps": 3,
                    "pt": 3,
                    "rm": 3,
                    "ro": 9,
                    "rof": 3,
                    "ru": 11,
                    "rwk": 3,
                    "sah": 0,
                    "saq": 3,
                    "se": 7,
                    "seh": 3,
                    "ses": 0,
                    "sg": 0,
                    "sh": 11,
                    "shi": 19,
                    "sk": 12,
                    "sl": 14,
                    "sma": 7,
                    "smi": 7,
                    "smj": 7,
                    "smn": 7,
                    "sms": 7,
                    "sn": 3,
                    "so": 3,
                    "sq": 3,
                    "sr": 11,
                    "ss": 3,
                    "ssy": 3,
                    "st": 3,
                    "sv": 3,
                    "sw": 3,
                    "syr": 3,
                    "ta": 3,
                    "te": 3,
                    "teo": 3,
                    "th": 0,
                    "ti": 4,
                    "tig": 3,
                    "tk": 3,
                    "tl": 4,
                    "tn": 3,
                    "to": 0,
                    "tr": 0,
                    "ts": 3,
                    "tzm": 22,
                    "uk": 11,
                    "ur": 3,
                    "ve": 3,
                    "vi": 0,
                    "vun": 3,
                    "wa": 4,
                    "wae": 3,
                    "wo": 0,
                    "xh": 3,
                    "xog": 3,
                    "yo": 0,
                    "zh": 0,
                    "zu": 3
                  };
                  function isIn(n, list) {
                    return list.indexOf(n) !== -1;
                  }
                  function isBetween(n, start, end) {
                    return start <= n && n <= end;
                  }
                  var pluralRules = {
                    "0": function(n) {
                      return "other";
                    },
                    "1": function(n) {
                      if (isBetween(n % 100, 3, 10)) return "few";
                      if (n === 0) return "zero";
                      if (isBetween(n % 100, 11, 99)) return "many";
                      if (n == 2) return "two";
                      if (n == 1) return "one";
                      return "other";
                    },
                    "2": function(n) {
                      if (n !== 0 && n % 10 === 0) return "many";
                      if (n == 2) return "two";
                      if (n == 1) return "one";
                      return "other";
                    },
                    "3": function(n) {
                      if (n == 1) return "one";
                      return "other";
                    },
                    "4": function(n) {
                      if (isBetween(n, 0, 1)) return "one";
                      return "other";
                    },
                    "5": function(n) {
                      if (isBetween(n, 0, 2) && n != 2) return "one";
                      return "other";
                    },
                    "6": function(n) {
                      if (n === 0) return "zero";
                      if (n % 10 == 1 && n % 100 != 11) return "one";
                      return "other";
                    },
                    "7": function(n) {
                      if (n == 2) return "two";
                      if (n == 1) return "one";
                      return "other";
                    },
                    "8": function(n) {
                      if (isBetween(n, 3, 6)) return "few";
                      if (isBetween(n, 7, 10)) return "many";
                      if (n == 2) return "two";
                      if (n == 1) return "one";
                      return "other";
                    },
                    "9": function(n) {
                      if (n === 0 || n != 1 && isBetween(n % 100, 1, 19)) return "few";
                      if (n == 1) return "one";
                      return "other";
                    },
                    "10": function(n) {
                      if (isBetween(n % 10, 2, 9) && !isBetween(n % 100, 11, 19)) return "few";
                      if (n % 10 == 1 && !isBetween(n % 100, 11, 19)) return "one";
                      return "other";
                    },
                    "11": function(n) {
                      if (isBetween(n % 10, 2, 4) && !isBetween(n % 100, 12, 14)) return "few";
                      if (n % 10 === 0 || isBetween(n % 10, 5, 9) || isBetween(n % 100, 11, 14)) return "many";
                      if (n % 10 == 1 && n % 100 != 11) return "one";
                      return "other";
                    },
                    "12": function(n) {
                      if (isBetween(n, 2, 4)) return "few";
                      if (n == 1) return "one";
                      return "other";
                    },
                    "13": function(n) {
                      if (isBetween(n % 10, 2, 4) && !isBetween(n % 100, 12, 14)) return "few";
                      if (n != 1 && isBetween(n % 10, 0, 1) || isBetween(n % 10, 5, 9) || isBetween(n % 100, 12, 14)) return "many";
                      if (n == 1) return "one";
                      return "other";
                    },
                    "14": function(n) {
                      if (isBetween(n % 100, 3, 4)) return "few";
                      if (n % 100 == 2) return "two";
                      if (n % 100 == 1) return "one";
                      return "other";
                    },
                    "15": function(n) {
                      if (n === 0 || isBetween(n % 100, 2, 10)) return "few";
                      if (isBetween(n % 100, 11, 19)) return "many";
                      if (n == 1) return "one";
                      return "other";
                    },
                    "16": function(n) {
                      if (n % 10 == 1 && n != 11) return "one";
                      return "other";
                    },
                    "17": function(n) {
                      if (n == 3) return "few";
                      if (n === 0) return "zero";
                      if (n == 6) return "many";
                      if (n == 2) return "two";
                      if (n == 1) return "one";
                      return "other";
                    },
                    "18": function(n) {
                      if (n === 0) return "zero";
                      if (isBetween(n, 0, 2) && n !== 0 && n != 2) return "one";
                      return "other";
                    },
                    "19": function(n) {
                      if (isBetween(n, 2, 10)) return "few";
                      if (isBetween(n, 0, 1)) return "one";
                      return "other";
                    },
                    "20": function(n) {
                      if ((isBetween(n % 10, 3, 4) || n % 10 == 9) && !(isBetween(n % 100, 10, 19) || isBetween(n % 100, 70, 79) || isBetween(n % 100, 90, 99))) return "few";
                      if (n % 1e6 === 0 && n !== 0) return "many";
                      if (n % 10 == 2 && !isIn(n % 100, [12, 72, 92])) return "two";
                      if (n % 10 == 1 && !isIn(n % 100, [11, 71, 91])) return "one";
                      return "other";
                    },
                    "21": function(n) {
                      if (n === 0) return "zero";
                      if (n == 1) return "one";
                      return "other";
                    },
                    "22": function(n) {
                      if (isBetween(n, 0, 1) || isBetween(n, 11, 99)) return "one";
                      return "other";
                    },
                    "23": function(n) {
                      if (isBetween(n % 10, 1, 2) || n % 20 === 0) return "one";
                      return "other";
                    },
                    "24": function(n) {
                      if (isBetween(n, 3, 10) || isBetween(n, 13, 19)) return "few";
                      if (isIn(n, [2, 12])) return "two";
                      if (isIn(n, [1, 11])) return "one";
                      return "other";
                    }
                  };
                  var index = locales2rules[lang.replace(/-.*$/, "")];
                  if (!(index in pluralRules)) {
                    console.warn("plural form unknown for [" + lang + "]");
                    return function() {
                      return "other";
                    };
                  }
                  return pluralRules[index];
                }
                gMacros.plural = function(str, param, key, prop) {
                  var n = parseFloat(param);
                  if (isNaN(n)) return str;
                  if (prop != gTextProp) return str;
                  if (!gMacros._pluralRules) {
                    gMacros._pluralRules = getPluralRules(gLanguage);
                  }
                  var index = "[" + gMacros._pluralRules(n) + "]";
                  if (n === 0 && key + "[zero]" in gL10nData) {
                    str = gL10nData[key + "[zero]"][prop];
                  } else if (n == 1 && key + "[one]" in gL10nData) {
                    str = gL10nData[key + "[one]"][prop];
                  } else if (n == 2 && key + "[two]" in gL10nData) {
                    str = gL10nData[key + "[two]"][prop];
                  } else if (key + index in gL10nData) {
                    str = gL10nData[key + index][prop];
                  } else if (key + "[other]" in gL10nData) {
                    str = gL10nData[key + "[other]"][prop];
                  }
                  return str;
                };
                function getL10nData(key, args, fallback) {
                  var data = gL10nData[key];
                  if (!data) {
                    console.warn("#" + key + " is undefined.");
                    if (!fallback) {
                      return null;
                    }
                    data = fallback;
                  }
                  var rv = {};
                  for (var prop in data) {
                    var str = data[prop];
                    str = substIndexes(str, args, key, prop);
                    str = substArguments(str, args, key);
                    rv[prop] = str;
                  }
                  return rv;
                }
                function substIndexes(str, args, key, prop) {
                  var reIndex = /\{\[\s*([a-zA-Z]+)\(([a-zA-Z]+)\)\s*\]\}/;
                  var reMatch = reIndex.exec(str);
                  if (!reMatch || !reMatch.length) return str;
                  var macroName = reMatch[1];
                  var paramName = reMatch[2];
                  var param;
                  if (args && paramName in args) {
                    param = args[paramName];
                  } else if (paramName in gL10nData) {
                    param = gL10nData[paramName];
                  }
                  if (macroName in gMacros) {
                    var macro = gMacros[macroName];
                    str = macro(str, param, key, prop);
                  }
                  return str;
                }
                function substArguments(str, args, key) {
                  var reArgs = /\{\{\s*(.+?)\s*\}\}/g;
                  return str.replace(reArgs, function(matched_text, arg) {
                    if (args && arg in args) {
                      return args[arg];
                    }
                    if (arg in gL10nData) {
                      return gL10nData[arg];
                    }
                    console.log("argument {{" + arg + "}} for #" + key + " is undefined.");
                    return matched_text;
                  });
                }
                function translateElement(element) {
                  var l10n = getL10nAttributes(element);
                  if (!l10n.id) return;
                  var data = getL10nData(l10n.id, l10n.args);
                  if (!data) {
                    console.warn("#" + l10n.id + " is undefined.");
                    return;
                  }
                  if (data[gTextProp]) {
                    if (getChildElementCount(element) === 0) {
                      element[gTextProp] = data[gTextProp];
                    } else {
                      var children = element.childNodes;
                      var found = false;
                      for (var i = 0, l = children.length; i < l; i++) {
                        if (children[i].nodeType === 3 && /\S/.test(children[i].nodeValue)) {
                          if (found) {
                            children[i].nodeValue = "";
                          } else {
                            children[i].nodeValue = data[gTextProp];
                            found = true;
                          }
                        }
                      }
                      if (!found) {
                        var textNode = document2.createTextNode(data[gTextProp]);
                        element.prepend(textNode);
                      }
                    }
                    delete data[gTextProp];
                  }
                  for (var k in data) {
                    element[k] = data[k];
                  }
                }
                function getChildElementCount(element) {
                  if (element.children) {
                    return element.children.length;
                  }
                  if (typeof element.childElementCount !== "undefined") {
                    return element.childElementCount;
                  }
                  var count = 0;
                  for (var i = 0; i < element.childNodes.length; i++) {
                    count += element.nodeType === 1 ? 1 : 0;
                  }
                  return count;
                }
                function translateFragment(element) {
                  element = element || document2.documentElement;
                  var children = getTranslatableChildren(element);
                  var elementCount = children.length;
                  for (var i = 0; i < elementCount; i++) {
                    translateElement(children[i]);
                  }
                  translateElement(element);
                }
                return {
                  get: function(key, args, fallbackString) {
                    var index = key.lastIndexOf(".");
                    var prop = gTextProp;
                    if (index > 0) {
                      prop = key.substring(index + 1);
                      key = key.substring(0, index);
                    }
                    var fallback;
                    if (fallbackString) {
                      fallback = {};
                      fallback[prop] = fallbackString;
                    }
                    var data = getL10nData(key, args, fallback);
                    if (data && prop in data) {
                      return data[prop];
                    }
                    return "{{" + key + "}}";
                  },
                  getData: function() {
                    return gL10nData;
                  },
                  getText: function() {
                    return gTextData;
                  },
                  getLanguage: function() {
                    return gLanguage;
                  },
                  setLanguage: function(lang, callback) {
                    loadLocale(lang, function() {
                      if (callback) callback();
                    });
                  },
                  getDirection: function() {
                    var rtlList = ["ar", "he", "fa", "ps", "ur"];
                    var shortCode = gLanguage.split("-", 1)[0];
                    return rtlList.indexOf(shortCode) >= 0 ? "rtl" : "ltr";
                  },
                  translate: translateFragment,
                  getReadyState: function() {
                    return gReadyState;
                  },
                  ready: function(callback) {
                    if (!callback) {
                      return;
                    } else if (gReadyState == "complete" || gReadyState == "interactive") {
                      window2.setTimeout(function() {
                        callback();
                      });
                    } else if (document2.addEventListener) {
                      document2.addEventListener("localized", function once() {
                        document2.removeEventListener("localized", once);
                        callback();
                      });
                    }
                  }
                };
              }(window, document);
            },
            /* 22 */
            /***/
            (__unused_webpack_module2, exports3, __w_pdfjs_require__3) => {
              Object.defineProperty(exports3, "__esModule", {
                value: true
              });
              exports3.PDFFindController = exports3.FindState = void 0;
              var _ui_utils = __w_pdfjs_require__3(7);
              var _pdfjsLib = __w_pdfjs_require__3(3);
              var _pdf_find_utils = __w_pdfjs_require__3(23);
              function _classPrivateFieldInitSpec2(obj, privateMap, value) {
                _checkPrivateRedeclaration2(obj, privateMap);
                privateMap.set(obj, value);
              }
              function _classPrivateMethodInitSpec2(obj, privateSet) {
                _checkPrivateRedeclaration2(obj, privateSet);
                privateSet.add(obj);
              }
              function _checkPrivateRedeclaration2(obj, privateCollection) {
                if (privateCollection.has(obj)) {
                  throw new TypeError("Cannot initialize the same private elements twice on an object");
                }
              }
              function _classPrivateFieldGet2(receiver, privateMap) {
                var descriptor = _classExtractFieldDescriptor2(receiver, privateMap, "get");
                return _classApplyDescriptorGet2(receiver, descriptor);
              }
              function _classExtractFieldDescriptor2(receiver, privateMap, action) {
                if (!privateMap.has(receiver)) {
                  throw new TypeError("attempted to " + action + " private field on non-instance");
                }
                return privateMap.get(receiver);
              }
              function _classApplyDescriptorGet2(receiver, descriptor) {
                if (descriptor.get) {
                  return descriptor.get.call(receiver);
                }
                return descriptor.value;
              }
              function _classPrivateMethodGet2(receiver, privateSet, fn) {
                if (!privateSet.has(receiver)) {
                  throw new TypeError("attempted to get private field on non-instance");
                }
                return fn;
              }
              const FindState = {
                FOUND: 0,
                NOT_FOUND: 1,
                WRAPPED: 2,
                PENDING: 3
              };
              exports3.FindState = FindState;
              const FIND_TIMEOUT = 250;
              const MATCH_SCROLL_OFFSET_TOP = -50;
              const MATCH_SCROLL_OFFSET_LEFT = -400;
              const CHARACTERS_TO_NORMALIZE = {
                "‐": "-",
                "‘": "'",
                "’": "'",
                "‚": "'",
                "‛": "'",
                "“": '"',
                "”": '"',
                "„": '"',
                "‟": '"',
                "¼": "1/4",
                "½": "1/2",
                "¾": "3/4"
              };
              const DIACRITICS_EXCEPTION = /* @__PURE__ */ new Set([12441, 12442, 2381, 2509, 2637, 2765, 2893, 3021, 3149, 3277, 3387, 3388, 3405, 3530, 3642, 3770, 3972, 4153, 4154, 5908, 5940, 6098, 6752, 6980, 7082, 7083, 7154, 7155, 11647, 43014, 43052, 43204, 43347, 43456, 43766, 44013, 3158, 3953, 3954, 3962, 3963, 3964, 3965, 3968, 3956]);
              const DIACRITICS_EXCEPTION_STR = [...DIACRITICS_EXCEPTION.values()].map((x) => String.fromCharCode(x)).join("");
              const DIACRITICS_REG_EXP = new RegExp("\\p{M}+", "gu");
              const SPECIAL_CHARS_REG_EXP = new RegExp("([.*+?^${}()|[\\]\\\\])|(\\p{P})|(\\s+)|(\\p{M})|(\\p{L})", "gu");
              const NOT_DIACRITIC_FROM_END_REG_EXP = new RegExp("([^\\p{M}])\\p{M}*$", "u");
              const NOT_DIACRITIC_FROM_START_REG_EXP = new RegExp("^\\p{M}*([^\\p{M}])", "u");
              const SYLLABLES_REG_EXP = /[\uAC00-\uD7AF\uFA6C\uFACF-\uFAD1\uFAD5-\uFAD7]+/g;
              const SYLLABLES_LENGTHS = /* @__PURE__ */ new Map();
              const FIRST_CHAR_SYLLABLES_REG_EXP = "[\\u1100-\\u1112\\ud7a4-\\ud7af\\ud84a\\ud84c\\ud850\\ud854\\ud857\\ud85f]";
              let noSyllablesRegExp = null;
              let withSyllablesRegExp = null;
              function normalize(text) {
                const syllablePositions = [];
                let m;
                while ((m = SYLLABLES_REG_EXP.exec(text)) !== null) {
                  let {
                    index
                  } = m;
                  for (const char of m[0]) {
                    let len = SYLLABLES_LENGTHS.get(char);
                    if (!len) {
                      len = char.normalize("NFD").length;
                      SYLLABLES_LENGTHS.set(char, len);
                    }
                    syllablePositions.push([len, index++]);
                  }
                }
                let normalizationRegex;
                if (syllablePositions.length === 0 && noSyllablesRegExp) {
                  normalizationRegex = noSyllablesRegExp;
                } else if (syllablePositions.length > 0 && withSyllablesRegExp) {
                  normalizationRegex = withSyllablesRegExp;
                } else {
                  const replace = Object.keys(CHARACTERS_TO_NORMALIZE).join("");
                  const regexp = `([${replace}])|(\\p{M}+(?:-\\n)?)|(\\S-\\n)|(\\n)`;
                  if (syllablePositions.length === 0) {
                    normalizationRegex = noSyllablesRegExp = new RegExp(regexp + "|(\\u0000)", "gum");
                  } else {
                    normalizationRegex = withSyllablesRegExp = new RegExp(regexp + `|(${FIRST_CHAR_SYLLABLES_REG_EXP})`, "gum");
                  }
                }
                const rawDiacriticsPositions = [];
                while ((m = DIACRITICS_REG_EXP.exec(text)) !== null) {
                  rawDiacriticsPositions.push([m[0].length, m.index]);
                }
                let normalized = text.normalize("NFD");
                const positions = [[0, 0]];
                let rawDiacriticsIndex = 0;
                let syllableIndex = 0;
                let shift = 0;
                let shiftOrigin = 0;
                let eol = 0;
                let hasDiacritics = false;
                normalized = normalized.replace(normalizationRegex, (match, p1, p2, p3, p4, p5, i) => {
                  var _syllablePositions$sy;
                  i -= shiftOrigin;
                  if (p1) {
                    const replacement = CHARACTERS_TO_NORMALIZE[match];
                    const jj = replacement.length;
                    for (let j = 1; j < jj; j++) {
                      positions.push([i - shift + j, shift - j]);
                    }
                    shift -= jj - 1;
                    return replacement;
                  }
                  if (p2) {
                    var _rawDiacriticsPositio;
                    const hasTrailingDashEOL = p2.endsWith("\n");
                    const len = hasTrailingDashEOL ? p2.length - 2 : p2.length;
                    hasDiacritics = true;
                    let jj = len;
                    if (i + eol === ((_rawDiacriticsPositio = rawDiacriticsPositions[rawDiacriticsIndex]) === null || _rawDiacriticsPositio === void 0 ? void 0 : _rawDiacriticsPositio[1])) {
                      jj -= rawDiacriticsPositions[rawDiacriticsIndex][0];
                      ++rawDiacriticsIndex;
                    }
                    for (let j = 1; j <= jj; j++) {
                      positions.push([i - 1 - shift + j, shift - j]);
                    }
                    shift -= jj;
                    shiftOrigin += jj;
                    if (hasTrailingDashEOL) {
                      i += len - 1;
                      positions.push([i - shift + 1, 1 + shift]);
                      shift += 1;
                      shiftOrigin += 1;
                      eol += 1;
                      return p2.slice(0, len);
                    }
                    return p2;
                  }
                  if (p3) {
                    positions.push([i - shift + 1, 1 + shift]);
                    shift += 1;
                    shiftOrigin += 1;
                    eol += 1;
                    return p3.charAt(0);
                  }
                  if (p4) {
                    positions.push([i - shift + 1, shift - 1]);
                    shift -= 1;
                    shiftOrigin += 1;
                    eol += 1;
                    return " ";
                  }
                  if (i + eol === ((_syllablePositions$sy = syllablePositions[syllableIndex]) === null || _syllablePositions$sy === void 0 ? void 0 : _syllablePositions$sy[1])) {
                    const newCharLen = syllablePositions[syllableIndex][0] - 1;
                    ++syllableIndex;
                    for (let j = 1; j <= newCharLen; j++) {
                      positions.push([i - (shift - j), shift - j]);
                    }
                    shift -= newCharLen;
                    shiftOrigin += newCharLen;
                  }
                  return p5;
                });
                positions.push([normalized.length, shift]);
                return [normalized, positions, hasDiacritics];
              }
              function getOriginalIndex(diffs, pos, len) {
                if (!diffs) {
                  return [pos, len];
                }
                const start = pos;
                const end = pos + len;
                let i = (0, _ui_utils.binarySearchFirstItem)(diffs, (x) => x[0] >= start);
                if (diffs[i][0] > start) {
                  --i;
                }
                let j = (0, _ui_utils.binarySearchFirstItem)(diffs, (x) => x[0] >= end, i);
                if (diffs[j][0] > end) {
                  --j;
                }
                return [start + diffs[i][1], len + diffs[j][1] - diffs[i][1]];
              }
              var _onFind = /* @__PURE__ */ new WeakSet();
              var _reset = /* @__PURE__ */ new WeakSet();
              var _query = /* @__PURE__ */ new WeakMap();
              var _shouldDirtyMatch = /* @__PURE__ */ new WeakSet();
              var _isEntireWord = /* @__PURE__ */ new WeakSet();
              var _calculateRegExpMatch = /* @__PURE__ */ new WeakSet();
              var _convertToRegExpString = /* @__PURE__ */ new WeakSet();
              var _calculateMatch = /* @__PURE__ */ new WeakSet();
              var _extractText = /* @__PURE__ */ new WeakSet();
              var _updatePage = /* @__PURE__ */ new WeakSet();
              var _updateAllPages = /* @__PURE__ */ new WeakSet();
              var _nextMatch = /* @__PURE__ */ new WeakSet();
              var _matchesReady = /* @__PURE__ */ new WeakSet();
              var _nextPageMatch = /* @__PURE__ */ new WeakSet();
              var _advanceOffsetPage = /* @__PURE__ */ new WeakSet();
              var _updateMatch = /* @__PURE__ */ new WeakSet();
              var _onFindBarClose = /* @__PURE__ */ new WeakSet();
              var _requestMatchesCount = /* @__PURE__ */ new WeakSet();
              var _updateUIResultsCount = /* @__PURE__ */ new WeakSet();
              var _updateUIState = /* @__PURE__ */ new WeakSet();
              class PDFFindController {
                constructor(_ref) {
                  let {
                    linkService: _linkService,
                    eventBus
                  } = _ref;
                  _classPrivateMethodInitSpec2(this, _updateUIState);
                  _classPrivateMethodInitSpec2(this, _updateUIResultsCount);
                  _classPrivateMethodInitSpec2(this, _requestMatchesCount);
                  _classPrivateMethodInitSpec2(this, _onFindBarClose);
                  _classPrivateMethodInitSpec2(this, _updateMatch);
                  _classPrivateMethodInitSpec2(this, _advanceOffsetPage);
                  _classPrivateMethodInitSpec2(this, _nextPageMatch);
                  _classPrivateMethodInitSpec2(this, _matchesReady);
                  _classPrivateMethodInitSpec2(this, _nextMatch);
                  _classPrivateMethodInitSpec2(this, _updateAllPages);
                  _classPrivateMethodInitSpec2(this, _updatePage);
                  _classPrivateMethodInitSpec2(this, _extractText);
                  _classPrivateMethodInitSpec2(this, _calculateMatch);
                  _classPrivateMethodInitSpec2(this, _convertToRegExpString);
                  _classPrivateMethodInitSpec2(this, _calculateRegExpMatch);
                  _classPrivateMethodInitSpec2(this, _isEntireWord);
                  _classPrivateMethodInitSpec2(this, _shouldDirtyMatch);
                  _classPrivateFieldInitSpec2(this, _query, {
                    get: _get_query,
                    set: void 0
                  });
                  _classPrivateMethodInitSpec2(this, _reset);
                  _classPrivateMethodInitSpec2(this, _onFind);
                  this._linkService = _linkService;
                  this._eventBus = eventBus;
                  _classPrivateMethodGet2(this, _reset, _reset2).call(this);
                  eventBus._on("find", _classPrivateMethodGet2(this, _onFind, _onFind2).bind(this));
                  eventBus._on("findbarclose", _classPrivateMethodGet2(this, _onFindBarClose, _onFindBarClose2).bind(this));
                }
                get highlightMatches() {
                  return this._highlightMatches;
                }
                get pageMatches() {
                  return this._pageMatches;
                }
                get pageMatchesLength() {
                  return this._pageMatchesLength;
                }
                get selected() {
                  return this._selected;
                }
                get state() {
                  return this._state;
                }
                setDocument(pdfDocument) {
                  if (this._pdfDocument) {
                    _classPrivateMethodGet2(this, _reset, _reset2).call(this);
                  }
                  if (!pdfDocument) {
                    return;
                  }
                  this._pdfDocument = pdfDocument;
                  this._firstPageCapability.resolve();
                }
                scrollMatchIntoView(_ref2) {
                  let {
                    element = null,
                    selectedLeft = 0,
                    pageIndex = -1,
                    matchIndex = -1
                  } = _ref2;
                  if (!this._scrollMatches || !element) {
                    return;
                  } else if (matchIndex === -1 || matchIndex !== this._selected.matchIdx) {
                    return;
                  } else if (pageIndex === -1 || pageIndex !== this._selected.pageIdx) {
                    return;
                  }
                  this._scrollMatches = false;
                  const spot = {
                    top: MATCH_SCROLL_OFFSET_TOP,
                    left: selectedLeft + MATCH_SCROLL_OFFSET_LEFT
                  };
                  (0, _ui_utils.scrollIntoView)(element, spot, true);
                }
              }
              exports3.PDFFindController = PDFFindController;
              function _onFind2(state) {
                if (!state) {
                  return;
                }
                const pdfDocument = this._pdfDocument;
                const {
                  type
                } = state;
                if (this._state === null || _classPrivateMethodGet2(this, _shouldDirtyMatch, _shouldDirtyMatch2).call(this, state)) {
                  this._dirtyMatch = true;
                }
                this._state = state;
                if (type !== "highlightallchange") {
                  _classPrivateMethodGet2(this, _updateUIState, _updateUIState2).call(this, FindState.PENDING);
                }
                this._firstPageCapability.promise.then(() => {
                  if (!this._pdfDocument || pdfDocument && this._pdfDocument !== pdfDocument) {
                    return;
                  }
                  _classPrivateMethodGet2(this, _extractText, _extractText2).call(this);
                  const findbarClosed = !this._highlightMatches;
                  const pendingTimeout = !!this._findTimeout;
                  if (this._findTimeout) {
                    clearTimeout(this._findTimeout);
                    this._findTimeout = null;
                  }
                  if (!type) {
                    this._findTimeout = setTimeout(() => {
                      _classPrivateMethodGet2(this, _nextMatch, _nextMatch2).call(this);
                      this._findTimeout = null;
                    }, FIND_TIMEOUT);
                  } else if (this._dirtyMatch) {
                    _classPrivateMethodGet2(this, _nextMatch, _nextMatch2).call(this);
                  } else if (type === "again") {
                    _classPrivateMethodGet2(this, _nextMatch, _nextMatch2).call(this);
                    if (findbarClosed && this._state.highlightAll) {
                      _classPrivateMethodGet2(this, _updateAllPages, _updateAllPages2).call(this);
                    }
                  } else if (type === "highlightallchange") {
                    if (pendingTimeout) {
                      _classPrivateMethodGet2(this, _nextMatch, _nextMatch2).call(this);
                    } else {
                      this._highlightMatches = true;
                    }
                    _classPrivateMethodGet2(this, _updateAllPages, _updateAllPages2).call(this);
                  } else {
                    _classPrivateMethodGet2(this, _nextMatch, _nextMatch2).call(this);
                  }
                });
              }
              function _reset2() {
                this._highlightMatches = false;
                this._scrollMatches = false;
                this._pdfDocument = null;
                this._pageMatches = [];
                this._pageMatchesLength = [];
                this._state = null;
                this._selected = {
                  pageIdx: -1,
                  matchIdx: -1
                };
                this._offset = {
                  pageIdx: null,
                  matchIdx: null,
                  wrapped: false
                };
                this._extractTextPromises = [];
                this._pageContents = [];
                this._pageDiffs = [];
                this._hasDiacritics = [];
                this._matchesCountTotal = 0;
                this._pagesToSearch = null;
                this._pendingFindMatches = /* @__PURE__ */ new Set();
                this._resumePageIdx = null;
                this._dirtyMatch = false;
                clearTimeout(this._findTimeout);
                this._findTimeout = null;
                this._firstPageCapability = (0, _pdfjsLib.createPromiseCapability)();
              }
              function _get_query() {
                if (this._state.query !== this._rawQuery) {
                  this._rawQuery = this._state.query;
                  [this._normalizedQuery] = normalize(this._state.query);
                }
                return this._normalizedQuery;
              }
              function _shouldDirtyMatch2(state) {
                if (state.query !== this._state.query) {
                  return true;
                }
                switch (state.type) {
                  case "again":
                    const pageNumber = this._selected.pageIdx + 1;
                    const linkService = this._linkService;
                    if (pageNumber >= 1 && pageNumber <= linkService.pagesCount && pageNumber !== linkService.page && !linkService.isPageVisible(pageNumber)) {
                      return true;
                    }
                    return false;
                  case "highlightallchange":
                    return false;
                }
                return true;
              }
              function _isEntireWord2(content, startIdx, length) {
                let match = content.slice(0, startIdx).match(NOT_DIACRITIC_FROM_END_REG_EXP);
                if (match) {
                  const first = content.charCodeAt(startIdx);
                  const limit = match[1].charCodeAt(0);
                  if ((0, _pdf_find_utils.getCharacterType)(first) === (0, _pdf_find_utils.getCharacterType)(limit)) {
                    return false;
                  }
                }
                match = content.slice(startIdx + length).match(NOT_DIACRITIC_FROM_START_REG_EXP);
                if (match) {
                  const last = content.charCodeAt(startIdx + length - 1);
                  const limit = match[1].charCodeAt(0);
                  if ((0, _pdf_find_utils.getCharacterType)(last) === (0, _pdf_find_utils.getCharacterType)(limit)) {
                    return false;
                  }
                }
                return true;
              }
              function _calculateRegExpMatch2(query, entireWord, pageIndex, pageContent) {
                const matches = [], matchesLength = [];
                const diffs = this._pageDiffs[pageIndex];
                let match;
                while ((match = query.exec(pageContent)) !== null) {
                  if (entireWord && !_classPrivateMethodGet2(this, _isEntireWord, _isEntireWord2).call(this, pageContent, match.index, match[0].length)) {
                    continue;
                  }
                  const [matchPos, matchLen] = getOriginalIndex(diffs, match.index, match[0].length);
                  if (matchLen) {
                    matches.push(matchPos);
                    matchesLength.push(matchLen);
                  }
                }
                this._pageMatches[pageIndex] = matches;
                this._pageMatchesLength[pageIndex] = matchesLength;
              }
              function _convertToRegExpString2(query, hasDiacritics) {
                const {
                  matchDiacritics
                } = this._state;
                let isUnicode = false;
                query = query.replace(SPECIAL_CHARS_REG_EXP, (match, p1, p2, p3, p4, p5) => {
                  if (p1) {
                    return `[ ]*\\${p1}[ ]*`;
                  }
                  if (p2) {
                    return `[ ]*${p2}[ ]*`;
                  }
                  if (p3) {
                    return "[ ]+";
                  }
                  if (matchDiacritics) {
                    return p4 || p5;
                  }
                  if (p4) {
                    return DIACRITICS_EXCEPTION.has(p4.charCodeAt(0)) ? p4 : "";
                  }
                  if (hasDiacritics) {
                    isUnicode = true;
                    return `${p5}\\p{M}*`;
                  }
                  return p5;
                });
                const trailingSpaces = "[ ]*";
                if (query.endsWith(trailingSpaces)) {
                  query = query.slice(0, query.length - trailingSpaces.length);
                }
                if (matchDiacritics) {
                  if (hasDiacritics) {
                    isUnicode = true;
                    query = `${query}(?=[${DIACRITICS_EXCEPTION_STR}]|[^\\p{M}]|$)`;
                  }
                }
                return [isUnicode, query];
              }
              function _calculateMatch2(pageIndex) {
                let query = _classPrivateFieldGet2(this, _query);
                if (query.length === 0) {
                  return;
                }
                const {
                  caseSensitive,
                  entireWord,
                  phraseSearch
                } = this._state;
                const pageContent = this._pageContents[pageIndex];
                const hasDiacritics = this._hasDiacritics[pageIndex];
                let isUnicode = false;
                if (phraseSearch) {
                  [isUnicode, query] = _classPrivateMethodGet2(this, _convertToRegExpString, _convertToRegExpString2).call(this, query, hasDiacritics);
                } else {
                  const match = query.match(/\S+/g);
                  if (match) {
                    query = match.sort().reverse().map((q) => {
                      const [isUnicodePart, queryPart] = _classPrivateMethodGet2(this, _convertToRegExpString, _convertToRegExpString2).call(this, q, hasDiacritics);
                      isUnicode || (isUnicode = isUnicodePart);
                      return `(${queryPart})`;
                    }).join("|");
                  }
                }
                const flags = `g${isUnicode ? "u" : ""}${caseSensitive ? "" : "i"}`;
                query = new RegExp(query, flags);
                _classPrivateMethodGet2(this, _calculateRegExpMatch, _calculateRegExpMatch2).call(this, query, entireWord, pageIndex, pageContent);
                if (this._state.highlightAll) {
                  _classPrivateMethodGet2(this, _updatePage, _updatePage2).call(this, pageIndex);
                }
                if (this._resumePageIdx === pageIndex) {
                  this._resumePageIdx = null;
                  _classPrivateMethodGet2(this, _nextPageMatch, _nextPageMatch2).call(this);
                }
                const pageMatchesCount = this._pageMatches[pageIndex].length;
                if (pageMatchesCount > 0) {
                  this._matchesCountTotal += pageMatchesCount;
                  _classPrivateMethodGet2(this, _updateUIResultsCount, _updateUIResultsCount2).call(this);
                }
              }
              function _extractText2() {
                if (this._extractTextPromises.length > 0) {
                  return;
                }
                let promise = Promise.resolve();
                for (let i = 0, ii = this._linkService.pagesCount; i < ii; i++) {
                  const extractTextCapability = (0, _pdfjsLib.createPromiseCapability)();
                  this._extractTextPromises[i] = extractTextCapability.promise;
                  promise = promise.then(() => {
                    return this._pdfDocument.getPage(i + 1).then((pdfPage) => {
                      return pdfPage.getTextContent();
                    }).then((textContent) => {
                      const strBuf = [];
                      for (const textItem of textContent.items) {
                        strBuf.push(textItem.str);
                        if (textItem.hasEOL) {
                          strBuf.push("\n");
                        }
                      }
                      [this._pageContents[i], this._pageDiffs[i], this._hasDiacritics[i]] = normalize(strBuf.join(""));
                      extractTextCapability.resolve();
                    }, (reason) => {
                      console.error(`Unable to get text content for page ${i + 1}`, reason);
                      this._pageContents[i] = "";
                      this._pageDiffs[i] = null;
                      this._hasDiacritics[i] = false;
                      extractTextCapability.resolve();
                    });
                  });
                }
              }
              function _updatePage2(index) {
                if (this._scrollMatches && this._selected.pageIdx === index) {
                  this._linkService.page = index + 1;
                }
                this._eventBus.dispatch("updatetextlayermatches", {
                  source: this,
                  pageIndex: index
                });
              }
              function _updateAllPages2() {
                this._eventBus.dispatch("updatetextlayermatches", {
                  source: this,
                  pageIndex: -1
                });
              }
              function _nextMatch2() {
                const previous = this._state.findPrevious;
                const currentPageIndex = this._linkService.page - 1;
                const numPages = this._linkService.pagesCount;
                this._highlightMatches = true;
                if (this._dirtyMatch) {
                  this._dirtyMatch = false;
                  this._selected.pageIdx = this._selected.matchIdx = -1;
                  this._offset.pageIdx = currentPageIndex;
                  this._offset.matchIdx = null;
                  this._offset.wrapped = false;
                  this._resumePageIdx = null;
                  this._pageMatches.length = 0;
                  this._pageMatchesLength.length = 0;
                  this._matchesCountTotal = 0;
                  _classPrivateMethodGet2(this, _updateAllPages, _updateAllPages2).call(this);
                  for (let i = 0; i < numPages; i++) {
                    if (this._pendingFindMatches.has(i)) {
                      continue;
                    }
                    this._pendingFindMatches.add(i);
                    this._extractTextPromises[i].then(() => {
                      this._pendingFindMatches.delete(i);
                      _classPrivateMethodGet2(this, _calculateMatch, _calculateMatch2).call(this, i);
                    });
                  }
                }
                if (_classPrivateFieldGet2(this, _query) === "") {
                  _classPrivateMethodGet2(this, _updateUIState, _updateUIState2).call(this, FindState.FOUND);
                  return;
                }
                if (this._resumePageIdx) {
                  return;
                }
                const offset = this._offset;
                this._pagesToSearch = numPages;
                if (offset.matchIdx !== null) {
                  const numPageMatches = this._pageMatches[offset.pageIdx].length;
                  if (!previous && offset.matchIdx + 1 < numPageMatches || previous && offset.matchIdx > 0) {
                    offset.matchIdx = previous ? offset.matchIdx - 1 : offset.matchIdx + 1;
                    _classPrivateMethodGet2(this, _updateMatch, _updateMatch2).call(this, true);
                    return;
                  }
                  _classPrivateMethodGet2(this, _advanceOffsetPage, _advanceOffsetPage2).call(this, previous);
                }
                _classPrivateMethodGet2(this, _nextPageMatch, _nextPageMatch2).call(this);
              }
              function _matchesReady2(matches) {
                const offset = this._offset;
                const numMatches = matches.length;
                const previous = this._state.findPrevious;
                if (numMatches) {
                  offset.matchIdx = previous ? numMatches - 1 : 0;
                  _classPrivateMethodGet2(this, _updateMatch, _updateMatch2).call(this, true);
                  return true;
                }
                _classPrivateMethodGet2(this, _advanceOffsetPage, _advanceOffsetPage2).call(this, previous);
                if (offset.wrapped) {
                  offset.matchIdx = null;
                  if (this._pagesToSearch < 0) {
                    _classPrivateMethodGet2(this, _updateMatch, _updateMatch2).call(this, false);
                    return true;
                  }
                }
                return false;
              }
              function _nextPageMatch2() {
                if (this._resumePageIdx !== null) {
                  console.error("There can only be one pending page.");
                }
                let matches = null;
                do {
                  const pageIdx = this._offset.pageIdx;
                  matches = this._pageMatches[pageIdx];
                  if (!matches) {
                    this._resumePageIdx = pageIdx;
                    break;
                  }
                } while (!_classPrivateMethodGet2(this, _matchesReady, _matchesReady2).call(this, matches));
              }
              function _advanceOffsetPage2(previous) {
                const offset = this._offset;
                const numPages = this._linkService.pagesCount;
                offset.pageIdx = previous ? offset.pageIdx - 1 : offset.pageIdx + 1;
                offset.matchIdx = null;
                this._pagesToSearch--;
                if (offset.pageIdx >= numPages || offset.pageIdx < 0) {
                  offset.pageIdx = previous ? numPages - 1 : 0;
                  offset.wrapped = true;
                }
              }
              function _updateMatch2() {
                let found = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
                let state = FindState.NOT_FOUND;
                const wrapped = this._offset.wrapped;
                this._offset.wrapped = false;
                if (found) {
                  const previousPage = this._selected.pageIdx;
                  this._selected.pageIdx = this._offset.pageIdx;
                  this._selected.matchIdx = this._offset.matchIdx;
                  state = wrapped ? FindState.WRAPPED : FindState.FOUND;
                  if (previousPage !== -1 && previousPage !== this._selected.pageIdx) {
                    _classPrivateMethodGet2(this, _updatePage, _updatePage2).call(this, previousPage);
                  }
                }
                _classPrivateMethodGet2(this, _updateUIState, _updateUIState2).call(this, state, this._state.findPrevious);
                if (this._selected.pageIdx !== -1) {
                  this._scrollMatches = true;
                  _classPrivateMethodGet2(this, _updatePage, _updatePage2).call(this, this._selected.pageIdx);
                }
              }
              function _onFindBarClose2(evt) {
                const pdfDocument = this._pdfDocument;
                this._firstPageCapability.promise.then(() => {
                  if (!this._pdfDocument || pdfDocument && this._pdfDocument !== pdfDocument) {
                    return;
                  }
                  if (this._findTimeout) {
                    clearTimeout(this._findTimeout);
                    this._findTimeout = null;
                  }
                  if (this._resumePageIdx) {
                    this._resumePageIdx = null;
                    this._dirtyMatch = true;
                  }
                  _classPrivateMethodGet2(this, _updateUIState, _updateUIState2).call(this, FindState.FOUND);
                  this._highlightMatches = false;
                  _classPrivateMethodGet2(this, _updateAllPages, _updateAllPages2).call(this);
                });
              }
              function _requestMatchesCount2() {
                const {
                  pageIdx,
                  matchIdx
                } = this._selected;
                let current = 0, total = this._matchesCountTotal;
                if (matchIdx !== -1) {
                  for (let i = 0; i < pageIdx; i++) {
                    var _this$_pageMatches$i;
                    current += ((_this$_pageMatches$i = this._pageMatches[i]) === null || _this$_pageMatches$i === void 0 ? void 0 : _this$_pageMatches$i.length) || 0;
                  }
                  current += matchIdx + 1;
                }
                if (current < 1 || current > total) {
                  current = total = 0;
                }
                return {
                  current,
                  total
                };
              }
              function _updateUIResultsCount2() {
                this._eventBus.dispatch("updatefindmatchescount", {
                  source: this,
                  matchesCount: _classPrivateMethodGet2(this, _requestMatchesCount, _requestMatchesCount2).call(this)
                });
              }
              function _updateUIState2(state) {
                var _this$_state$query, _this$_state;
                let previous = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                this._eventBus.dispatch("updatefindcontrolstate", {
                  source: this,
                  state,
                  previous,
                  matchesCount: _classPrivateMethodGet2(this, _requestMatchesCount, _requestMatchesCount2).call(this),
                  rawQuery: (_this$_state$query = (_this$_state = this._state) === null || _this$_state === void 0 ? void 0 : _this$_state.query) !== null && _this$_state$query !== void 0 ? _this$_state$query : null
                });
              }
            },
            /* 23 */
            /***/
            (__unused_webpack_module2, exports3) => {
              Object.defineProperty(exports3, "__esModule", {
                value: true
              });
              exports3.CharacterType = void 0;
              exports3.getCharacterType = getCharacterType;
              const CharacterType = {
                SPACE: 0,
                ALPHA_LETTER: 1,
                PUNCT: 2,
                HAN_LETTER: 3,
                KATAKANA_LETTER: 4,
                HIRAGANA_LETTER: 5,
                HALFWIDTH_KATAKANA_LETTER: 6,
                THAI_LETTER: 7
              };
              exports3.CharacterType = CharacterType;
              function isAlphabeticalScript(charCode) {
                return charCode < 11904;
              }
              function isAscii(charCode) {
                return (charCode & 65408) === 0;
              }
              function isAsciiAlpha(charCode) {
                return charCode >= 97 && charCode <= 122 || charCode >= 65 && charCode <= 90;
              }
              function isAsciiDigit(charCode) {
                return charCode >= 48 && charCode <= 57;
              }
              function isAsciiSpace(charCode) {
                return charCode === 32 || charCode === 9 || charCode === 13 || charCode === 10;
              }
              function isHan(charCode) {
                return charCode >= 13312 && charCode <= 40959 || charCode >= 63744 && charCode <= 64255;
              }
              function isKatakana(charCode) {
                return charCode >= 12448 && charCode <= 12543;
              }
              function isHiragana(charCode) {
                return charCode >= 12352 && charCode <= 12447;
              }
              function isHalfwidthKatakana(charCode) {
                return charCode >= 65376 && charCode <= 65439;
              }
              function isThai(charCode) {
                return (charCode & 65408) === 3584;
              }
              function getCharacterType(charCode) {
                if (isAlphabeticalScript(charCode)) {
                  if (isAscii(charCode)) {
                    if (isAsciiSpace(charCode)) {
                      return CharacterType.SPACE;
                    } else if (isAsciiAlpha(charCode) || isAsciiDigit(charCode) || charCode === 95) {
                      return CharacterType.ALPHA_LETTER;
                    }
                    return CharacterType.PUNCT;
                  } else if (isThai(charCode)) {
                    return CharacterType.THAI_LETTER;
                  } else if (charCode === 160) {
                    return CharacterType.SPACE;
                  }
                  return CharacterType.ALPHA_LETTER;
                }
                if (isHan(charCode)) {
                  return CharacterType.HAN_LETTER;
                } else if (isKatakana(charCode)) {
                  return CharacterType.KATAKANA_LETTER;
                } else if (isHiragana(charCode)) {
                  return CharacterType.HIRAGANA_LETTER;
                } else if (isHalfwidthKatakana(charCode)) {
                  return CharacterType.HALFWIDTH_KATAKANA_LETTER;
                }
                return CharacterType.ALPHA_LETTER;
              }
            },
            /* 24 */
            /***/
            (__unused_webpack_module2, exports3, __w_pdfjs_require__3) => {
              Object.defineProperty(exports3, "__esModule", {
                value: true
              });
              exports3.PDFHistory = void 0;
              exports3.isDestArraysEqual = isDestArraysEqual;
              exports3.isDestHashesEqual = isDestHashesEqual;
              var _ui_utils = __w_pdfjs_require__3(7);
              var _event_utils = __w_pdfjs_require__3(19);
              const HASH_CHANGE_TIMEOUT = 1e3;
              const POSITION_UPDATED_THRESHOLD = 50;
              const UPDATE_VIEWAREA_TIMEOUT = 1e3;
              function getCurrentHash() {
                return document.location.hash;
              }
              class PDFHistory {
                constructor(_ref) {
                  let {
                    linkService,
                    eventBus
                  } = _ref;
                  this.linkService = linkService;
                  this.eventBus = eventBus;
                  this._initialized = false;
                  this._fingerprint = "";
                  this.reset();
                  this._boundEvents = null;
                  this.eventBus._on("pagesinit", () => {
                    this._isPagesLoaded = false;
                    this.eventBus._on("pagesloaded", (evt) => {
                      this._isPagesLoaded = !!evt.pagesCount;
                    }, {
                      once: true
                    });
                  });
                }
                initialize(_ref2) {
                  let {
                    fingerprint,
                    resetHistory = false,
                    updateUrl = false
                  } = _ref2;
                  if (!fingerprint || typeof fingerprint !== "string") {
                    console.error('PDFHistory.initialize: The "fingerprint" must be a non-empty string.');
                    return;
                  }
                  if (this._initialized) {
                    this.reset();
                  }
                  const reInitialized = this._fingerprint !== "" && this._fingerprint !== fingerprint;
                  this._fingerprint = fingerprint;
                  this._updateUrl = updateUrl === true;
                  this._initialized = true;
                  this._bindEvents();
                  const state = window.history.state;
                  this._popStateInProgress = false;
                  this._blockHashChange = 0;
                  this._currentHash = getCurrentHash();
                  this._numPositionUpdates = 0;
                  this._uid = this._maxUid = 0;
                  this._destination = null;
                  this._position = null;
                  if (!this._isValidState(state, true) || resetHistory) {
                    const {
                      hash,
                      page,
                      rotation
                    } = this._parseCurrentHash(true);
                    if (!hash || reInitialized || resetHistory) {
                      this._pushOrReplaceState(null, true);
                      return;
                    }
                    this._pushOrReplaceState({
                      hash,
                      page,
                      rotation
                    }, true);
                    return;
                  }
                  const destination = state.destination;
                  this._updateInternalState(destination, state.uid, true);
                  if (destination.rotation !== void 0) {
                    this._initialRotation = destination.rotation;
                  }
                  if (destination.dest) {
                    this._initialBookmark = JSON.stringify(destination.dest);
                    this._destination.page = null;
                  } else if (destination.hash) {
                    this._initialBookmark = destination.hash;
                  } else if (destination.page) {
                    this._initialBookmark = `page=${destination.page}`;
                  }
                }
                reset() {
                  if (this._initialized) {
                    this._pageHide();
                    this._initialized = false;
                    this._unbindEvents();
                  }
                  if (this._updateViewareaTimeout) {
                    clearTimeout(this._updateViewareaTimeout);
                    this._updateViewareaTimeout = null;
                  }
                  this._initialBookmark = null;
                  this._initialRotation = null;
                }
                push(_ref3) {
                  let {
                    namedDest = null,
                    explicitDest,
                    pageNumber
                  } = _ref3;
                  if (!this._initialized) {
                    return;
                  }
                  if (namedDest && typeof namedDest !== "string") {
                    console.error(`PDFHistory.push: "${namedDest}" is not a valid namedDest parameter.`);
                    return;
                  } else if (!Array.isArray(explicitDest)) {
                    console.error(`PDFHistory.push: "${explicitDest}" is not a valid explicitDest parameter.`);
                    return;
                  } else if (!this._isValidPage(pageNumber)) {
                    if (pageNumber !== null || this._destination) {
                      console.error(`PDFHistory.push: "${pageNumber}" is not a valid pageNumber parameter.`);
                      return;
                    }
                  }
                  const hash = namedDest || JSON.stringify(explicitDest);
                  if (!hash) {
                    return;
                  }
                  let forceReplace = false;
                  if (this._destination && (isDestHashesEqual(this._destination.hash, hash) || isDestArraysEqual(this._destination.dest, explicitDest))) {
                    if (this._destination.page) {
                      return;
                    }
                    forceReplace = true;
                  }
                  if (this._popStateInProgress && !forceReplace) {
                    return;
                  }
                  this._pushOrReplaceState({
                    dest: explicitDest,
                    hash,
                    page: pageNumber,
                    rotation: this.linkService.rotation
                  }, forceReplace);
                  if (!this._popStateInProgress) {
                    this._popStateInProgress = true;
                    Promise.resolve().then(() => {
                      this._popStateInProgress = false;
                    });
                  }
                }
                pushPage(pageNumber) {
                  var _this$_destination;
                  if (!this._initialized) {
                    return;
                  }
                  if (!this._isValidPage(pageNumber)) {
                    console.error(`PDFHistory.pushPage: "${pageNumber}" is not a valid page number.`);
                    return;
                  }
                  if (((_this$_destination = this._destination) === null || _this$_destination === void 0 ? void 0 : _this$_destination.page) === pageNumber) {
                    return;
                  }
                  if (this._popStateInProgress) {
                    return;
                  }
                  this._pushOrReplaceState({
                    dest: null,
                    hash: `page=${pageNumber}`,
                    page: pageNumber,
                    rotation: this.linkService.rotation
                  });
                  if (!this._popStateInProgress) {
                    this._popStateInProgress = true;
                    Promise.resolve().then(() => {
                      this._popStateInProgress = false;
                    });
                  }
                }
                pushCurrentPosition() {
                  if (!this._initialized || this._popStateInProgress) {
                    return;
                  }
                  this._tryPushCurrentPosition();
                }
                back() {
                  if (!this._initialized || this._popStateInProgress) {
                    return;
                  }
                  const state = window.history.state;
                  if (this._isValidState(state) && state.uid > 0) {
                    window.history.back();
                  }
                }
                forward() {
                  if (!this._initialized || this._popStateInProgress) {
                    return;
                  }
                  const state = window.history.state;
                  if (this._isValidState(state) && state.uid < this._maxUid) {
                    window.history.forward();
                  }
                }
                get popStateInProgress() {
                  return this._initialized && (this._popStateInProgress || this._blockHashChange > 0);
                }
                get initialBookmark() {
                  return this._initialized ? this._initialBookmark : null;
                }
                get initialRotation() {
                  return this._initialized ? this._initialRotation : null;
                }
                _pushOrReplaceState(destination) {
                  let forceReplace = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                  const shouldReplace = forceReplace || !this._destination;
                  const newState = {
                    fingerprint: this._fingerprint,
                    uid: shouldReplace ? this._uid : this._uid + 1,
                    destination
                  };
                  this._updateInternalState(destination, newState.uid);
                  let newUrl;
                  if (this._updateUrl && destination !== null && destination !== void 0 && destination.hash) {
                    const baseUrl = document.location.href.split("#")[0];
                    if (!baseUrl.startsWith("file://")) {
                      newUrl = `${baseUrl}#${destination.hash}`;
                    }
                  }
                  if (shouldReplace) {
                    window.history.replaceState(newState, "", newUrl);
                  } else {
                    window.history.pushState(newState, "", newUrl);
                  }
                }
                _tryPushCurrentPosition() {
                  let temporary = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
                  if (!this._position) {
                    return;
                  }
                  let position = this._position;
                  if (temporary) {
                    position = Object.assign(/* @__PURE__ */ Object.create(null), this._position);
                    position.temporary = true;
                  }
                  if (!this._destination) {
                    this._pushOrReplaceState(position);
                    return;
                  }
                  if (this._destination.temporary) {
                    this._pushOrReplaceState(position, true);
                    return;
                  }
                  if (this._destination.hash === position.hash) {
                    return;
                  }
                  if (!this._destination.page && (POSITION_UPDATED_THRESHOLD <= 0 || this._numPositionUpdates <= POSITION_UPDATED_THRESHOLD)) {
                    return;
                  }
                  let forceReplace = false;
                  if (this._destination.page >= position.first && this._destination.page <= position.page) {
                    if (this._destination.dest !== void 0 || !this._destination.first) {
                      return;
                    }
                    forceReplace = true;
                  }
                  this._pushOrReplaceState(position, forceReplace);
                }
                _isValidPage(val) {
                  return Number.isInteger(val) && val > 0 && val <= this.linkService.pagesCount;
                }
                _isValidState(state) {
                  let checkReload = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                  if (!state) {
                    return false;
                  }
                  if (state.fingerprint !== this._fingerprint) {
                    if (checkReload) {
                      if (typeof state.fingerprint !== "string" || state.fingerprint.length !== this._fingerprint.length) {
                        return false;
                      }
                      const [perfEntry] = performance.getEntriesByType("navigation");
                      if ((perfEntry === null || perfEntry === void 0 ? void 0 : perfEntry.type) !== "reload") {
                        return false;
                      }
                    } else {
                      return false;
                    }
                  }
                  if (!Number.isInteger(state.uid) || state.uid < 0) {
                    return false;
                  }
                  if (state.destination === null || typeof state.destination !== "object") {
                    return false;
                  }
                  return true;
                }
                _updateInternalState(destination, uid) {
                  let removeTemporary = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                  if (this._updateViewareaTimeout) {
                    clearTimeout(this._updateViewareaTimeout);
                    this._updateViewareaTimeout = null;
                  }
                  if (removeTemporary && destination !== null && destination !== void 0 && destination.temporary) {
                    delete destination.temporary;
                  }
                  this._destination = destination;
                  this._uid = uid;
                  this._maxUid = Math.max(this._maxUid, uid);
                  this._numPositionUpdates = 0;
                }
                _parseCurrentHash() {
                  let checkNameddest = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
                  const hash = unescape(getCurrentHash()).substring(1);
                  const params = (0, _ui_utils.parseQueryString)(hash);
                  const nameddest = params.get("nameddest") || "";
                  let page = params.get("page") | 0;
                  if (!this._isValidPage(page) || checkNameddest && nameddest.length > 0) {
                    page = null;
                  }
                  return {
                    hash,
                    page,
                    rotation: this.linkService.rotation
                  };
                }
                _updateViewarea(_ref4) {
                  let {
                    location
                  } = _ref4;
                  if (this._updateViewareaTimeout) {
                    clearTimeout(this._updateViewareaTimeout);
                    this._updateViewareaTimeout = null;
                  }
                  this._position = {
                    hash: location.pdfOpenParams.substring(1),
                    page: this.linkService.page,
                    first: location.pageNumber,
                    rotation: location.rotation
                  };
                  if (this._popStateInProgress) {
                    return;
                  }
                  if (POSITION_UPDATED_THRESHOLD > 0 && this._isPagesLoaded && this._destination && !this._destination.page) {
                    this._numPositionUpdates++;
                  }
                  if (UPDATE_VIEWAREA_TIMEOUT > 0) {
                    this._updateViewareaTimeout = setTimeout(() => {
                      if (!this._popStateInProgress) {
                        this._tryPushCurrentPosition(true);
                      }
                      this._updateViewareaTimeout = null;
                    }, UPDATE_VIEWAREA_TIMEOUT);
                  }
                }
                _popState(_ref5) {
                  let {
                    state
                  } = _ref5;
                  const newHash = getCurrentHash(), hashChanged = this._currentHash !== newHash;
                  this._currentHash = newHash;
                  if (!state) {
                    this._uid++;
                    const {
                      hash,
                      page,
                      rotation
                    } = this._parseCurrentHash();
                    this._pushOrReplaceState({
                      hash,
                      page,
                      rotation
                    }, true);
                    return;
                  }
                  if (!this._isValidState(state)) {
                    return;
                  }
                  this._popStateInProgress = true;
                  if (hashChanged) {
                    this._blockHashChange++;
                    (0, _event_utils.waitOnEventOrTimeout)({
                      target: window,
                      name: "hashchange",
                      delay: HASH_CHANGE_TIMEOUT
                    }).then(() => {
                      this._blockHashChange--;
                    });
                  }
                  const destination = state.destination;
                  this._updateInternalState(destination, state.uid, true);
                  if ((0, _ui_utils.isValidRotation)(destination.rotation)) {
                    this.linkService.rotation = destination.rotation;
                  }
                  if (destination.dest) {
                    this.linkService.goToDestination(destination.dest);
                  } else if (destination.hash) {
                    this.linkService.setHash(destination.hash);
                  } else if (destination.page) {
                    this.linkService.page = destination.page;
                  }
                  Promise.resolve().then(() => {
                    this._popStateInProgress = false;
                  });
                }
                _pageHide() {
                  if (!this._destination || this._destination.temporary) {
                    this._tryPushCurrentPosition();
                  }
                }
                _bindEvents() {
                  if (this._boundEvents) {
                    return;
                  }
                  this._boundEvents = {
                    updateViewarea: this._updateViewarea.bind(this),
                    popState: this._popState.bind(this),
                    pageHide: this._pageHide.bind(this)
                  };
                  this.eventBus._on("updateviewarea", this._boundEvents.updateViewarea);
                  window.addEventListener("popstate", this._boundEvents.popState);
                  window.addEventListener("pagehide", this._boundEvents.pageHide);
                }
                _unbindEvents() {
                  if (!this._boundEvents) {
                    return;
                  }
                  this.eventBus._off("updateviewarea", this._boundEvents.updateViewarea);
                  window.removeEventListener("popstate", this._boundEvents.popState);
                  window.removeEventListener("pagehide", this._boundEvents.pageHide);
                  this._boundEvents = null;
                }
              }
              exports3.PDFHistory = PDFHistory;
              function isDestHashesEqual(destHash, pushHash) {
                if (typeof destHash !== "string" || typeof pushHash !== "string") {
                  return false;
                }
                if (destHash === pushHash) {
                  return true;
                }
                const nameddest = (0, _ui_utils.parseQueryString)(destHash).get("nameddest");
                if (nameddest === pushHash) {
                  return true;
                }
                return false;
              }
              function isDestArraysEqual(firstDest, secondDest) {
                function isEntryEqual(first, second) {
                  if (typeof first !== typeof second) {
                    return false;
                  }
                  if (Array.isArray(first) || Array.isArray(second)) {
                    return false;
                  }
                  if (first !== null && typeof first === "object" && second !== null) {
                    if (Object.keys(first).length !== Object.keys(second).length) {
                      return false;
                    }
                    for (const key in first) {
                      if (!isEntryEqual(first[key], second[key])) {
                        return false;
                      }
                    }
                    return true;
                  }
                  return first === second || Number.isNaN(first) && Number.isNaN(second);
                }
                if (!(Array.isArray(firstDest) && Array.isArray(secondDest))) {
                  return false;
                }
                if (firstDest.length !== secondDest.length) {
                  return false;
                }
                for (let i = 0, ii = firstDest.length; i < ii; i++) {
                  if (!isEntryEqual(firstDest[i], secondDest[i])) {
                    return false;
                  }
                }
                return true;
              }
            },
            /* 25 */
            /***/
            (__unused_webpack_module2, exports3, __w_pdfjs_require__3) => {
              Object.defineProperty(exports3, "__esModule", {
                value: true
              });
              exports3.PDFScriptingManager = void 0;
              var _ui_utils = __w_pdfjs_require__3(7);
              var _pdfjsLib = __w_pdfjs_require__3(3);
              class PDFScriptingManager {
                constructor(_ref) {
                  let {
                    eventBus,
                    sandboxBundleSrc = null,
                    scriptingFactory = null,
                    docPropertiesLookup = null
                  } = _ref;
                  this._pdfDocument = null;
                  this._pdfViewer = null;
                  this._closeCapability = null;
                  this._destroyCapability = null;
                  this._scripting = null;
                  this._mouseState = /* @__PURE__ */ Object.create(null);
                  this._ready = false;
                  this._eventBus = eventBus;
                  this._sandboxBundleSrc = sandboxBundleSrc;
                  this._scriptingFactory = scriptingFactory;
                  this._docPropertiesLookup = docPropertiesLookup;
                  if (!this._scriptingFactory) {
                    window.addEventListener("updatefromsandbox", (event) => {
                      this._eventBus.dispatch("updatefromsandbox", {
                        source: window,
                        detail: event.detail
                      });
                    });
                  }
                }
                setViewer(pdfViewer) {
                  this._pdfViewer = pdfViewer;
                }
                async setDocument(pdfDocument) {
                  var _this$_scripting3;
                  if (this._pdfDocument) {
                    await this._destroyScripting();
                  }
                  this._pdfDocument = pdfDocument;
                  if (!pdfDocument) {
                    return;
                  }
                  const [objects, calculationOrder, docActions] = await Promise.all([pdfDocument.getFieldObjects(), pdfDocument.getCalculationOrderIds(), pdfDocument.getJSActions()]);
                  if (!objects && !docActions) {
                    await this._destroyScripting();
                    return;
                  }
                  if (pdfDocument !== this._pdfDocument) {
                    return;
                  }
                  try {
                    this._scripting = this._createScripting();
                  } catch (error) {
                    console.error(`PDFScriptingManager.setDocument: "${error === null || error === void 0 ? void 0 : error.message}".`);
                    await this._destroyScripting();
                    return;
                  }
                  this._internalEvents.set("updatefromsandbox", (event) => {
                    if ((event === null || event === void 0 ? void 0 : event.source) !== window) {
                      return;
                    }
                    this._updateFromSandbox(event.detail);
                  });
                  this._internalEvents.set("dispatcheventinsandbox", (event) => {
                    var _this$_scripting;
                    (_this$_scripting = this._scripting) === null || _this$_scripting === void 0 ? void 0 : _this$_scripting.dispatchEventInSandbox(event.detail);
                  });
                  this._internalEvents.set("pagechanging", (_ref2) => {
                    let {
                      pageNumber,
                      previous
                    } = _ref2;
                    if (pageNumber === previous) {
                      return;
                    }
                    this._dispatchPageClose(previous);
                    this._dispatchPageOpen(pageNumber);
                  });
                  this._internalEvents.set("pagerendered", (_ref3) => {
                    let {
                      pageNumber
                    } = _ref3;
                    if (!this._pageOpenPending.has(pageNumber)) {
                      return;
                    }
                    if (pageNumber !== this._pdfViewer.currentPageNumber) {
                      return;
                    }
                    this._dispatchPageOpen(pageNumber);
                  });
                  this._internalEvents.set("pagesdestroy", async (event) => {
                    var _this$_scripting2, _this$_closeCapabilit;
                    await this._dispatchPageClose(this._pdfViewer.currentPageNumber);
                    await ((_this$_scripting2 = this._scripting) === null || _this$_scripting2 === void 0 ? void 0 : _this$_scripting2.dispatchEventInSandbox({
                      id: "doc",
                      name: "WillClose"
                    }));
                    (_this$_closeCapabilit = this._closeCapability) === null || _this$_closeCapabilit === void 0 ? void 0 : _this$_closeCapabilit.resolve();
                  });
                  this._domEvents.set("mousedown", (event) => {
                    this._mouseState.isDown = true;
                  });
                  this._domEvents.set("mouseup", (event) => {
                    this._mouseState.isDown = false;
                  });
                  for (const [name, listener] of this._internalEvents) {
                    this._eventBus._on(name, listener);
                  }
                  for (const [name, listener] of this._domEvents) {
                    window.addEventListener(name, listener, true);
                  }
                  try {
                    const docProperties = await this._getDocProperties();
                    if (pdfDocument !== this._pdfDocument) {
                      return;
                    }
                    await this._scripting.createSandbox({
                      objects,
                      calculationOrder,
                      appInfo: {
                        platform: navigator.platform,
                        language: navigator.language
                      },
                      docInfo: {
                        ...docProperties,
                        actions: docActions
                      }
                    });
                    this._eventBus.dispatch("sandboxcreated", {
                      source: this
                    });
                  } catch (error) {
                    console.error(`PDFScriptingManager.setDocument: "${error === null || error === void 0 ? void 0 : error.message}".`);
                    await this._destroyScripting();
                    return;
                  }
                  await ((_this$_scripting3 = this._scripting) === null || _this$_scripting3 === void 0 ? void 0 : _this$_scripting3.dispatchEventInSandbox({
                    id: "doc",
                    name: "Open"
                  }));
                  await this._dispatchPageOpen(this._pdfViewer.currentPageNumber, true);
                  Promise.resolve().then(() => {
                    if (pdfDocument === this._pdfDocument) {
                      this._ready = true;
                    }
                  });
                }
                async dispatchWillSave(detail) {
                  var _this$_scripting4;
                  return (_this$_scripting4 = this._scripting) === null || _this$_scripting4 === void 0 ? void 0 : _this$_scripting4.dispatchEventInSandbox({
                    id: "doc",
                    name: "WillSave"
                  });
                }
                async dispatchDidSave(detail) {
                  var _this$_scripting5;
                  return (_this$_scripting5 = this._scripting) === null || _this$_scripting5 === void 0 ? void 0 : _this$_scripting5.dispatchEventInSandbox({
                    id: "doc",
                    name: "DidSave"
                  });
                }
                async dispatchWillPrint(detail) {
                  var _this$_scripting6;
                  return (_this$_scripting6 = this._scripting) === null || _this$_scripting6 === void 0 ? void 0 : _this$_scripting6.dispatchEventInSandbox({
                    id: "doc",
                    name: "WillPrint"
                  });
                }
                async dispatchDidPrint(detail) {
                  var _this$_scripting7;
                  return (_this$_scripting7 = this._scripting) === null || _this$_scripting7 === void 0 ? void 0 : _this$_scripting7.dispatchEventInSandbox({
                    id: "doc",
                    name: "DidPrint"
                  });
                }
                get mouseState() {
                  return this._mouseState;
                }
                get destroyPromise() {
                  var _this$_destroyCapabil;
                  return ((_this$_destroyCapabil = this._destroyCapability) === null || _this$_destroyCapabil === void 0 ? void 0 : _this$_destroyCapabil.promise) || null;
                }
                get ready() {
                  return this._ready;
                }
                get _internalEvents() {
                  return (0, _pdfjsLib.shadow)(this, "_internalEvents", /* @__PURE__ */ new Map());
                }
                get _domEvents() {
                  return (0, _pdfjsLib.shadow)(this, "_domEvents", /* @__PURE__ */ new Map());
                }
                get _pageOpenPending() {
                  return (0, _pdfjsLib.shadow)(this, "_pageOpenPending", /* @__PURE__ */ new Set());
                }
                get _visitedPages() {
                  return (0, _pdfjsLib.shadow)(this, "_visitedPages", /* @__PURE__ */ new Map());
                }
                async _updateFromSandbox(detail) {
                  const isInPresentationMode = this._pdfViewer.isInPresentationMode || this._pdfViewer.isChangingPresentationMode;
                  const {
                    id,
                    siblings,
                    command,
                    value
                  } = detail;
                  if (!id) {
                    switch (command) {
                      case "clear":
                        console.clear();
                        break;
                      case "error":
                        console.error(value);
                        break;
                      case "layout":
                        if (isInPresentationMode) {
                          return;
                        }
                        const modes = (0, _ui_utils.apiPageLayoutToViewerModes)(value);
                        this._pdfViewer.spreadMode = modes.spreadMode;
                        break;
                      case "page-num":
                        this._pdfViewer.currentPageNumber = value + 1;
                        break;
                      case "print":
                        await this._pdfViewer.pagesPromise;
                        this._eventBus.dispatch("print", {
                          source: this
                        });
                        break;
                      case "println":
                        console.log(value);
                        break;
                      case "zoom":
                        if (isInPresentationMode) {
                          return;
                        }
                        this._pdfViewer.currentScaleValue = value;
                        break;
                      case "SaveAs":
                        this._eventBus.dispatch("download", {
                          source: this
                        });
                        break;
                      case "FirstPage":
                        this._pdfViewer.currentPageNumber = 1;
                        break;
                      case "LastPage":
                        this._pdfViewer.currentPageNumber = this._pdfViewer.pagesCount;
                        break;
                      case "NextPage":
                        this._pdfViewer.nextPage();
                        break;
                      case "PrevPage":
                        this._pdfViewer.previousPage();
                        break;
                      case "ZoomViewIn":
                        if (isInPresentationMode) {
                          return;
                        }
                        this._pdfViewer.increaseScale();
                        break;
                      case "ZoomViewOut":
                        if (isInPresentationMode) {
                          return;
                        }
                        this._pdfViewer.decreaseScale();
                        break;
                    }
                    return;
                  }
                  if (isInPresentationMode) {
                    if (detail.focus) {
                      return;
                    }
                  }
                  delete detail.id;
                  delete detail.siblings;
                  const ids = siblings ? [id, ...siblings] : [id];
                  for (const elementId of ids) {
                    const element = document.querySelector(`[data-element-id="${elementId}"]`);
                    if (element) {
                      element.dispatchEvent(new CustomEvent("updatefromsandbox", {
                        detail
                      }));
                    } else {
                      var _this$_pdfDocument;
                      (_this$_pdfDocument = this._pdfDocument) === null || _this$_pdfDocument === void 0 ? void 0 : _this$_pdfDocument.annotationStorage.setValue(elementId, detail);
                    }
                  }
                }
                async _dispatchPageOpen(pageNumber) {
                  let initialize = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                  const pdfDocument = this._pdfDocument, visitedPages = this._visitedPages;
                  if (initialize) {
                    this._closeCapability = (0, _pdfjsLib.createPromiseCapability)();
                  }
                  if (!this._closeCapability) {
                    return;
                  }
                  const pageView = this._pdfViewer.getPageView(pageNumber - 1);
                  if ((pageView === null || pageView === void 0 ? void 0 : pageView.renderingState) !== _ui_utils.RenderingStates.FINISHED) {
                    this._pageOpenPending.add(pageNumber);
                    return;
                  }
                  this._pageOpenPending.delete(pageNumber);
                  const actionsPromise = (async () => {
                    var _pageView$pdfPage, _this$_scripting8;
                    const actions = await (!visitedPages.has(pageNumber) ? (_pageView$pdfPage = pageView.pdfPage) === null || _pageView$pdfPage === void 0 ? void 0 : _pageView$pdfPage.getJSActions() : null);
                    if (pdfDocument !== this._pdfDocument) {
                      return;
                    }
                    await ((_this$_scripting8 = this._scripting) === null || _this$_scripting8 === void 0 ? void 0 : _this$_scripting8.dispatchEventInSandbox({
                      id: "page",
                      name: "PageOpen",
                      pageNumber,
                      actions
                    }));
                  })();
                  visitedPages.set(pageNumber, actionsPromise);
                }
                async _dispatchPageClose(pageNumber) {
                  var _this$_scripting9;
                  const pdfDocument = this._pdfDocument, visitedPages = this._visitedPages;
                  if (!this._closeCapability) {
                    return;
                  }
                  if (this._pageOpenPending.has(pageNumber)) {
                    return;
                  }
                  const actionsPromise = visitedPages.get(pageNumber);
                  if (!actionsPromise) {
                    return;
                  }
                  visitedPages.set(pageNumber, null);
                  await actionsPromise;
                  if (pdfDocument !== this._pdfDocument) {
                    return;
                  }
                  await ((_this$_scripting9 = this._scripting) === null || _this$_scripting9 === void 0 ? void 0 : _this$_scripting9.dispatchEventInSandbox({
                    id: "page",
                    name: "PageClose",
                    pageNumber
                  }));
                }
                async _getDocProperties() {
                  if (this._docPropertiesLookup) {
                    return this._docPropertiesLookup(this._pdfDocument);
                  }
                  const {
                    docPropertiesLookup
                  } = __w_pdfjs_require__3(26);
                  return docPropertiesLookup(this._pdfDocument);
                }
                _createScripting() {
                  this._destroyCapability = (0, _pdfjsLib.createPromiseCapability)();
                  if (this._scripting) {
                    throw new Error("_createScripting: Scripting already exists.");
                  }
                  if (this._scriptingFactory) {
                    return this._scriptingFactory.createScripting({
                      sandboxBundleSrc: this._sandboxBundleSrc
                    });
                  }
                  const {
                    GenericScripting
                  } = __w_pdfjs_require__3(26);
                  return new GenericScripting(this._sandboxBundleSrc);
                }
                async _destroyScripting() {
                  var _this$_destroyCapabil3;
                  if (!this._scripting) {
                    var _this$_destroyCapabil2;
                    this._pdfDocument = null;
                    (_this$_destroyCapabil2 = this._destroyCapability) === null || _this$_destroyCapabil2 === void 0 ? void 0 : _this$_destroyCapabil2.resolve();
                    return;
                  }
                  if (this._closeCapability) {
                    await Promise.race([this._closeCapability.promise, new Promise((resolve) => {
                      setTimeout(resolve, 1e3);
                    })]).catch((reason) => {
                    });
                    this._closeCapability = null;
                  }
                  this._pdfDocument = null;
                  try {
                    await this._scripting.destroySandbox();
                  } catch (ex) {
                  }
                  for (const [name, listener] of this._internalEvents) {
                    this._eventBus._off(name, listener);
                  }
                  this._internalEvents.clear();
                  for (const [name, listener] of this._domEvents) {
                    window.removeEventListener(name, listener, true);
                  }
                  this._domEvents.clear();
                  this._pageOpenPending.clear();
                  this._visitedPages.clear();
                  this._scripting = null;
                  delete this._mouseState.isDown;
                  this._ready = false;
                  (_this$_destroyCapabil3 = this._destroyCapability) === null || _this$_destroyCapabil3 === void 0 ? void 0 : _this$_destroyCapabil3.resolve();
                }
              }
              exports3.PDFScriptingManager = PDFScriptingManager;
            },
            /* 26 */
            /***/
            (__unused_webpack_module2, exports3, __w_pdfjs_require__3) => {
              Object.defineProperty(exports3, "__esModule", {
                value: true
              });
              exports3.GenericScripting = void 0;
              exports3.docPropertiesLookup = docPropertiesLookup;
              var _pdfjsLib = __w_pdfjs_require__3(3);
              async function docPropertiesLookup(pdfDocument) {
                const url = "", baseUrl = url.split("#")[0];
                let {
                  info,
                  metadata,
                  contentDispositionFilename,
                  contentLength
                } = await pdfDocument.getMetadata();
                if (!contentLength) {
                  const {
                    length
                  } = await pdfDocument.getDownloadInfo();
                  contentLength = length;
                }
                return {
                  ...info,
                  baseURL: baseUrl,
                  filesize: contentLength,
                  filename: contentDispositionFilename || (0, _pdfjsLib.getPdfFilenameFromUrl)(url),
                  metadata: metadata === null || metadata === void 0 ? void 0 : metadata.getRaw(),
                  authors: metadata === null || metadata === void 0 ? void 0 : metadata.get("dc:creator"),
                  numPages: pdfDocument.numPages,
                  URL: url
                };
              }
              class GenericScripting {
                constructor(sandboxBundleSrc) {
                  this._ready = (0, _pdfjsLib.loadScript)(sandboxBundleSrc, true).then(() => {
                    return window.pdfjsSandbox.QuickJSSandbox();
                  });
                }
                async createSandbox(data) {
                  const sandbox = await this._ready;
                  sandbox.create(data);
                }
                async dispatchEventInSandbox(event) {
                  const sandbox = await this._ready;
                  setTimeout(() => sandbox.dispatchEvent(event), 0);
                }
                async destroySandbox() {
                  const sandbox = await this._ready;
                  sandbox.nukeSandbox();
                }
              }
              exports3.GenericScripting = GenericScripting;
            }
            /******/
          ];
          var __webpack_module_cache__2 = {};
          function __w_pdfjs_require__2(moduleId) {
            var cachedModule = __webpack_module_cache__2[moduleId];
            if (cachedModule !== void 0) {
              return cachedModule.exports;
            }
            var module3 = __webpack_module_cache__2[moduleId] = {
              /******/
              // no module.id needed
              /******/
              // no module.loaded needed
              /******/
              exports: {}
              /******/
            };
            __webpack_modules__2[moduleId](module3, module3.exports, __w_pdfjs_require__2);
            return module3.exports;
          }
          var __webpack_exports__2 = {};
          (() => {
            var exports3 = __webpack_exports__2;
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            Object.defineProperty(exports3, "AnnotationLayerBuilder", {
              enumerable: true,
              get: function() {
                return _annotation_layer_builder.AnnotationLayerBuilder;
              }
            });
            Object.defineProperty(exports3, "DefaultAnnotationLayerFactory", {
              enumerable: true,
              get: function() {
                return _default_factory.DefaultAnnotationLayerFactory;
              }
            });
            Object.defineProperty(exports3, "DefaultStructTreeLayerFactory", {
              enumerable: true,
              get: function() {
                return _default_factory.DefaultStructTreeLayerFactory;
              }
            });
            Object.defineProperty(exports3, "DefaultTextLayerFactory", {
              enumerable: true,
              get: function() {
                return _default_factory.DefaultTextLayerFactory;
              }
            });
            Object.defineProperty(exports3, "DefaultXfaLayerFactory", {
              enumerable: true,
              get: function() {
                return _default_factory.DefaultXfaLayerFactory;
              }
            });
            Object.defineProperty(exports3, "DownloadManager", {
              enumerable: true,
              get: function() {
                return _download_manager.DownloadManager;
              }
            });
            Object.defineProperty(exports3, "EventBus", {
              enumerable: true,
              get: function() {
                return _event_utils.EventBus;
              }
            });
            Object.defineProperty(exports3, "GenericL10n", {
              enumerable: true,
              get: function() {
                return _genericl10n.GenericL10n;
              }
            });
            Object.defineProperty(exports3, "LinkTarget", {
              enumerable: true,
              get: function() {
                return _pdf_link_service.LinkTarget;
              }
            });
            Object.defineProperty(exports3, "NullL10n", {
              enumerable: true,
              get: function() {
                return _l10n_utils.NullL10n;
              }
            });
            Object.defineProperty(exports3, "PDFFindController", {
              enumerable: true,
              get: function() {
                return _pdf_find_controller.PDFFindController;
              }
            });
            Object.defineProperty(exports3, "PDFHistory", {
              enumerable: true,
              get: function() {
                return _pdf_history.PDFHistory;
              }
            });
            Object.defineProperty(exports3, "PDFLinkService", {
              enumerable: true,
              get: function() {
                return _pdf_link_service.PDFLinkService;
              }
            });
            Object.defineProperty(exports3, "PDFPageView", {
              enumerable: true,
              get: function() {
                return _pdf_page_view.PDFPageView;
              }
            });
            Object.defineProperty(exports3, "PDFScriptingManager", {
              enumerable: true,
              get: function() {
                return _pdf_scripting_manager.PDFScriptingManager;
              }
            });
            Object.defineProperty(exports3, "PDFSinglePageViewer", {
              enumerable: true,
              get: function() {
                return _pdf_viewer.PDFSinglePageViewer;
              }
            });
            Object.defineProperty(exports3, "PDFViewer", {
              enumerable: true,
              get: function() {
                return _pdf_viewer.PDFViewer;
              }
            });
            Object.defineProperty(exports3, "ProgressBar", {
              enumerable: true,
              get: function() {
                return _ui_utils.ProgressBar;
              }
            });
            Object.defineProperty(exports3, "RenderingStates", {
              enumerable: true,
              get: function() {
                return _ui_utils.RenderingStates;
              }
            });
            Object.defineProperty(exports3, "ScrollMode", {
              enumerable: true,
              get: function() {
                return _ui_utils.ScrollMode;
              }
            });
            Object.defineProperty(exports3, "SimpleLinkService", {
              enumerable: true,
              get: function() {
                return _pdf_link_service.SimpleLinkService;
              }
            });
            Object.defineProperty(exports3, "SpreadMode", {
              enumerable: true,
              get: function() {
                return _ui_utils.SpreadMode;
              }
            });
            Object.defineProperty(exports3, "StructTreeLayerBuilder", {
              enumerable: true,
              get: function() {
                return _struct_tree_layer_builder.StructTreeLayerBuilder;
              }
            });
            Object.defineProperty(exports3, "TextLayerBuilder", {
              enumerable: true,
              get: function() {
                return _text_layer_builder.TextLayerBuilder;
              }
            });
            Object.defineProperty(exports3, "XfaLayerBuilder", {
              enumerable: true,
              get: function() {
                return _xfa_layer_builder.XfaLayerBuilder;
              }
            });
            Object.defineProperty(exports3, "parseQueryString", {
              enumerable: true,
              get: function() {
                return _ui_utils.parseQueryString;
              }
            });
            var _default_factory = __w_pdfjs_require__2(1);
            var _pdf_link_service = __w_pdfjs_require__2(6);
            var _ui_utils = __w_pdfjs_require__2(7);
            var _pdf_viewer = __w_pdfjs_require__2(11);
            var _annotation_layer_builder = __w_pdfjs_require__2(5);
            var _download_manager = __w_pdfjs_require__2(18);
            var _event_utils = __w_pdfjs_require__2(19);
            var _genericl10n = __w_pdfjs_require__2(20);
            var _l10n_utils = __w_pdfjs_require__2(4);
            var _pdf_find_controller = __w_pdfjs_require__2(22);
            var _pdf_history = __w_pdfjs_require__2(24);
            var _pdf_page_view = __w_pdfjs_require__2(13);
            var _pdf_scripting_manager = __w_pdfjs_require__2(25);
            var _struct_tree_layer_builder = __w_pdfjs_require__2(8);
            var _text_layer_builder = __w_pdfjs_require__2(9);
            var _xfa_layer_builder = __w_pdfjs_require__2(10);
            const pdfjsVersion = "2.16.105";
            const pdfjsBuild = "172ccdbe5";
          })();
          return __webpack_exports__2;
        })()
      );
    });
  }
});

// node_modules/lodash.debounce/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.debounce/index.js"(exports2, module2) {
    var FUNC_ERROR_TEXT = "Expected a function";
    var NAN = 0 / 0;
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var nativeMax = Math.max;
    var nativeMin = Math.min;
    var now = function() {
      return root.Date.now();
    };
    function debounce2(func, wait, options) {
      var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = toNumber(wait) || 0;
      if (isObject(options)) {
        leading = !!options.leading;
        maxing = "maxWait" in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      function invokeFunc(time) {
        var args = lastArgs, thisArg = lastThis;
        lastArgs = lastThis = void 0;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
      }
      function leadingEdge(time) {
        lastInvokeTime = time;
        timerId = setTimeout(timerExpired, wait);
        return leading ? invokeFunc(time) : result;
      }
      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result2 = wait - timeSinceLastCall;
        return maxing ? nativeMin(result2, maxWait - timeSinceLastInvoke) : result2;
      }
      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
        return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
      }
      function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        timerId = setTimeout(timerExpired, remainingWait(time));
      }
      function trailingEdge(time) {
        timerId = void 0;
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = void 0;
        return result;
      }
      function cancel() {
        if (timerId !== void 0) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = void 0;
      }
      function flush() {
        return timerId === void 0 ? result : trailingEdge(now());
      }
      function debounced() {
        var time = now(), isInvoking = shouldInvoke(time);
        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;
        if (isInvoking) {
          if (timerId === void 0) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === void 0) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    module2.exports = debounce2;
  }
});

// node_modules/react-draggable/node_modules/clsx/dist/clsx.m.js
var clsx_m_exports = {};
__export(clsx_m_exports, {
  clsx: () => clsx,
  default: () => clsx_m_default
});
function r(e) {
  var t, f, n = "";
  if ("string" == typeof e || "number" == typeof e) n += e;
  else if ("object" == typeof e) if (Array.isArray(e)) for (t = 0; t < e.length; t++) e[t] && (f = r(e[t])) && (n && (n += " "), n += f);
  else for (t in e) e[t] && (n && (n += " "), n += t);
  return n;
}
function clsx() {
  for (var e, t, f = 0, n = ""; f < arguments.length; ) (e = arguments[f++]) && (t = r(e)) && (n && (n += " "), n += t);
  return n;
}
var clsx_m_default;
var init_clsx_m = __esm({
  "node_modules/react-draggable/node_modules/clsx/dist/clsx.m.js"() {
    clsx_m_default = clsx;
  }
});

// node_modules/react-draggable/build/cjs/utils/shims.js
var require_shims = __commonJS({
  "node_modules/react-draggable/build/cjs/utils/shims.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.dontSetMe = dontSetMe;
    exports2.findInArray = findInArray;
    exports2.int = int;
    exports2.isFunction = isFunction;
    exports2.isNum = isNum;
    function findInArray(array, callback) {
      for (let i = 0, length = array.length; i < length; i++) {
        if (callback.apply(callback, [array[i], i, array])) return array[i];
      }
    }
    function isFunction(func) {
      return typeof func === "function" || Object.prototype.toString.call(func) === "[object Function]";
    }
    function isNum(num) {
      return typeof num === "number" && !isNaN(num);
    }
    function int(a) {
      return parseInt(a, 10);
    }
    function dontSetMe(props, propName, componentName) {
      if (props[propName]) {
        return new Error("Invalid prop ".concat(propName, " passed to ").concat(componentName, " - do not set this, set it on the child."));
      }
    }
  }
});

// node_modules/react-draggable/build/cjs/utils/getPrefix.js
var require_getPrefix = __commonJS({
  "node_modules/react-draggable/build/cjs/utils/getPrefix.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.browserPrefixToKey = browserPrefixToKey;
    exports2.browserPrefixToStyle = browserPrefixToStyle;
    exports2.default = void 0;
    exports2.getPrefix = getPrefix;
    var prefixes = ["Moz", "Webkit", "O", "ms"];
    function getPrefix() {
      var _window$document;
      let prop = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "transform";
      if (typeof window === "undefined") return "";
      const style = (_window$document = window.document) === null || _window$document === void 0 || (_window$document = _window$document.documentElement) === null || _window$document === void 0 ? void 0 : _window$document.style;
      if (!style) return "";
      if (prop in style) return "";
      for (let i = 0; i < prefixes.length; i++) {
        if (browserPrefixToKey(prop, prefixes[i]) in style) return prefixes[i];
      }
      return "";
    }
    function browserPrefixToKey(prop, prefix) {
      return prefix ? "".concat(prefix).concat(kebabToTitleCase(prop)) : prop;
    }
    function browserPrefixToStyle(prop, prefix) {
      return prefix ? "-".concat(prefix.toLowerCase(), "-").concat(prop) : prop;
    }
    function kebabToTitleCase(str) {
      let out = "";
      let shouldCapitalize = true;
      for (let i = 0; i < str.length; i++) {
        if (shouldCapitalize) {
          out += str[i].toUpperCase();
          shouldCapitalize = false;
        } else if (str[i] === "-") {
          shouldCapitalize = true;
        } else {
          out += str[i];
        }
      }
      return out;
    }
    var _default = exports2.default = getPrefix();
  }
});

// node_modules/react-draggable/build/cjs/utils/domFns.js
var require_domFns = __commonJS({
  "node_modules/react-draggable/build/cjs/utils/domFns.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.addClassName = addClassName;
    exports2.addEvent = addEvent;
    exports2.addUserSelectStyles = addUserSelectStyles;
    exports2.createCSSTransform = createCSSTransform;
    exports2.createSVGTransform = createSVGTransform;
    exports2.getTouch = getTouch;
    exports2.getTouchIdentifier = getTouchIdentifier;
    exports2.getTranslation = getTranslation;
    exports2.innerHeight = innerHeight;
    exports2.innerWidth = innerWidth;
    exports2.matchesSelector = matchesSelector;
    exports2.matchesSelectorAndParentsTo = matchesSelectorAndParentsTo;
    exports2.offsetXYFromParent = offsetXYFromParent;
    exports2.outerHeight = outerHeight;
    exports2.outerWidth = outerWidth;
    exports2.removeClassName = removeClassName;
    exports2.removeEvent = removeEvent;
    exports2.removeUserSelectStyles = removeUserSelectStyles;
    var _shims = require_shims();
    var _getPrefix = _interopRequireWildcard(require_getPrefix());
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function") return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var matchesSelectorFunc = "";
    function matchesSelector(el, selector) {
      if (!matchesSelectorFunc) {
        matchesSelectorFunc = (0, _shims.findInArray)(["matches", "webkitMatchesSelector", "mozMatchesSelector", "msMatchesSelector", "oMatchesSelector"], function(method) {
          return (0, _shims.isFunction)(el[method]);
        });
      }
      if (!(0, _shims.isFunction)(el[matchesSelectorFunc])) return false;
      return el[matchesSelectorFunc](selector);
    }
    function matchesSelectorAndParentsTo(el, selector, baseNode) {
      let node = el;
      do {
        if (matchesSelector(node, selector)) return true;
        if (node === baseNode) return false;
        node = node.parentNode;
      } while (node);
      return false;
    }
    function addEvent(el, event, handler, inputOptions) {
      if (!el) return;
      const options = {
        capture: true,
        ...inputOptions
      };
      if (el.addEventListener) {
        el.addEventListener(event, handler, options);
      } else if (el.attachEvent) {
        el.attachEvent("on" + event, handler);
      } else {
        el["on" + event] = handler;
      }
    }
    function removeEvent(el, event, handler, inputOptions) {
      if (!el) return;
      const options = {
        capture: true,
        ...inputOptions
      };
      if (el.removeEventListener) {
        el.removeEventListener(event, handler, options);
      } else if (el.detachEvent) {
        el.detachEvent("on" + event, handler);
      } else {
        el["on" + event] = null;
      }
    }
    function outerHeight(node) {
      let height = node.clientHeight;
      const computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
      height += (0, _shims.int)(computedStyle.borderTopWidth);
      height += (0, _shims.int)(computedStyle.borderBottomWidth);
      return height;
    }
    function outerWidth(node) {
      let width = node.clientWidth;
      const computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
      width += (0, _shims.int)(computedStyle.borderLeftWidth);
      width += (0, _shims.int)(computedStyle.borderRightWidth);
      return width;
    }
    function innerHeight(node) {
      let height = node.clientHeight;
      const computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
      height -= (0, _shims.int)(computedStyle.paddingTop);
      height -= (0, _shims.int)(computedStyle.paddingBottom);
      return height;
    }
    function innerWidth(node) {
      let width = node.clientWidth;
      const computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
      width -= (0, _shims.int)(computedStyle.paddingLeft);
      width -= (0, _shims.int)(computedStyle.paddingRight);
      return width;
    }
    function offsetXYFromParent(evt, offsetParent, scale) {
      const isBody = offsetParent === offsetParent.ownerDocument.body;
      const offsetParentRect = isBody ? {
        left: 0,
        top: 0
      } : offsetParent.getBoundingClientRect();
      const x = (evt.clientX + offsetParent.scrollLeft - offsetParentRect.left) / scale;
      const y = (evt.clientY + offsetParent.scrollTop - offsetParentRect.top) / scale;
      return {
        x,
        y
      };
    }
    function createCSSTransform(controlPos, positionOffset) {
      const translation = getTranslation(controlPos, positionOffset, "px");
      return {
        [(0, _getPrefix.browserPrefixToKey)("transform", _getPrefix.default)]: translation
      };
    }
    function createSVGTransform(controlPos, positionOffset) {
      const translation = getTranslation(controlPos, positionOffset, "");
      return translation;
    }
    function getTranslation(_ref, positionOffset, unitSuffix) {
      let {
        x,
        y
      } = _ref;
      let translation = "translate(".concat(x).concat(unitSuffix, ",").concat(y).concat(unitSuffix, ")");
      if (positionOffset) {
        const defaultX = "".concat(typeof positionOffset.x === "string" ? positionOffset.x : positionOffset.x + unitSuffix);
        const defaultY = "".concat(typeof positionOffset.y === "string" ? positionOffset.y : positionOffset.y + unitSuffix);
        translation = "translate(".concat(defaultX, ", ").concat(defaultY, ")") + translation;
      }
      return translation;
    }
    function getTouch(e, identifier) {
      return e.targetTouches && (0, _shims.findInArray)(e.targetTouches, (t) => identifier === t.identifier) || e.changedTouches && (0, _shims.findInArray)(e.changedTouches, (t) => identifier === t.identifier);
    }
    function getTouchIdentifier(e) {
      if (e.targetTouches && e.targetTouches[0]) return e.targetTouches[0].identifier;
      if (e.changedTouches && e.changedTouches[0]) return e.changedTouches[0].identifier;
    }
    function addUserSelectStyles(doc) {
      if (!doc) return;
      let styleEl = doc.getElementById("react-draggable-style-el");
      if (!styleEl) {
        styleEl = doc.createElement("style");
        styleEl.type = "text/css";
        styleEl.id = "react-draggable-style-el";
        styleEl.innerHTML = ".react-draggable-transparent-selection *::-moz-selection {all: inherit;}\n";
        styleEl.innerHTML += ".react-draggable-transparent-selection *::selection {all: inherit;}\n";
        doc.getElementsByTagName("head")[0].appendChild(styleEl);
      }
      if (doc.body) addClassName(doc.body, "react-draggable-transparent-selection");
    }
    function removeUserSelectStyles(doc) {
      if (!doc) return;
      try {
        if (doc.body) removeClassName(doc.body, "react-draggable-transparent-selection");
        if (doc.selection) {
          doc.selection.empty();
        } else {
          const selection = (doc.defaultView || window).getSelection();
          if (selection && selection.type !== "Caret") {
            selection.removeAllRanges();
          }
        }
      } catch (e) {
      }
    }
    function addClassName(el, className) {
      if (el.classList) {
        el.classList.add(className);
      } else {
        if (!el.className.match(new RegExp("(?:^|\\s)".concat(className, "(?!\\S)")))) {
          el.className += " ".concat(className);
        }
      }
    }
    function removeClassName(el, className) {
      if (el.classList) {
        el.classList.remove(className);
      } else {
        el.className = el.className.replace(new RegExp("(?:^|\\s)".concat(className, "(?!\\S)"), "g"), "");
      }
    }
  }
});

// node_modules/react-draggable/build/cjs/utils/positionFns.js
var require_positionFns = __commonJS({
  "node_modules/react-draggable/build/cjs/utils/positionFns.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.canDragX = canDragX;
    exports2.canDragY = canDragY;
    exports2.createCoreData = createCoreData;
    exports2.createDraggableData = createDraggableData;
    exports2.getBoundPosition = getBoundPosition;
    exports2.getControlPosition = getControlPosition;
    exports2.snapToGrid = snapToGrid;
    var _shims = require_shims();
    var _domFns = require_domFns();
    function getBoundPosition(draggable, x, y) {
      if (!draggable.props.bounds) return [x, y];
      let {
        bounds
      } = draggable.props;
      bounds = typeof bounds === "string" ? bounds : cloneBounds(bounds);
      const node = findDOMNode(draggable);
      if (typeof bounds === "string") {
        const {
          ownerDocument
        } = node;
        const ownerWindow = ownerDocument.defaultView;
        let boundNode;
        if (bounds === "parent") {
          boundNode = node.parentNode;
        } else {
          boundNode = ownerDocument.querySelector(bounds);
        }
        if (!(boundNode instanceof ownerWindow.HTMLElement)) {
          throw new Error('Bounds selector "' + bounds + '" could not find an element.');
        }
        const boundNodeEl = boundNode;
        const nodeStyle = ownerWindow.getComputedStyle(node);
        const boundNodeStyle = ownerWindow.getComputedStyle(boundNodeEl);
        bounds = {
          left: -node.offsetLeft + (0, _shims.int)(boundNodeStyle.paddingLeft) + (0, _shims.int)(nodeStyle.marginLeft),
          top: -node.offsetTop + (0, _shims.int)(boundNodeStyle.paddingTop) + (0, _shims.int)(nodeStyle.marginTop),
          right: (0, _domFns.innerWidth)(boundNodeEl) - (0, _domFns.outerWidth)(node) - node.offsetLeft + (0, _shims.int)(boundNodeStyle.paddingRight) - (0, _shims.int)(nodeStyle.marginRight),
          bottom: (0, _domFns.innerHeight)(boundNodeEl) - (0, _domFns.outerHeight)(node) - node.offsetTop + (0, _shims.int)(boundNodeStyle.paddingBottom) - (0, _shims.int)(nodeStyle.marginBottom)
        };
      }
      if ((0, _shims.isNum)(bounds.right)) x = Math.min(x, bounds.right);
      if ((0, _shims.isNum)(bounds.bottom)) y = Math.min(y, bounds.bottom);
      if ((0, _shims.isNum)(bounds.left)) x = Math.max(x, bounds.left);
      if ((0, _shims.isNum)(bounds.top)) y = Math.max(y, bounds.top);
      return [x, y];
    }
    function snapToGrid(grid, pendingX, pendingY) {
      const x = Math.round(pendingX / grid[0]) * grid[0];
      const y = Math.round(pendingY / grid[1]) * grid[1];
      return [x, y];
    }
    function canDragX(draggable) {
      return draggable.props.axis === "both" || draggable.props.axis === "x";
    }
    function canDragY(draggable) {
      return draggable.props.axis === "both" || draggable.props.axis === "y";
    }
    function getControlPosition(e, touchIdentifier, draggableCore) {
      const touchObj = typeof touchIdentifier === "number" ? (0, _domFns.getTouch)(e, touchIdentifier) : null;
      if (typeof touchIdentifier === "number" && !touchObj) return null;
      const node = findDOMNode(draggableCore);
      const offsetParent = draggableCore.props.offsetParent || node.offsetParent || node.ownerDocument.body;
      return (0, _domFns.offsetXYFromParent)(touchObj || e, offsetParent, draggableCore.props.scale);
    }
    function createCoreData(draggable, x, y) {
      const isStart = !(0, _shims.isNum)(draggable.lastX);
      const node = findDOMNode(draggable);
      if (isStart) {
        return {
          node,
          deltaX: 0,
          deltaY: 0,
          lastX: x,
          lastY: y,
          x,
          y
        };
      } else {
        return {
          node,
          deltaX: x - draggable.lastX,
          deltaY: y - draggable.lastY,
          lastX: draggable.lastX,
          lastY: draggable.lastY,
          x,
          y
        };
      }
    }
    function createDraggableData(draggable, coreData) {
      const scale = draggable.props.scale;
      return {
        node: coreData.node,
        x: draggable.state.x + coreData.deltaX / scale,
        y: draggable.state.y + coreData.deltaY / scale,
        deltaX: coreData.deltaX / scale,
        deltaY: coreData.deltaY / scale,
        lastX: draggable.state.x,
        lastY: draggable.state.y
      };
    }
    function cloneBounds(bounds) {
      return {
        left: bounds.left,
        top: bounds.top,
        right: bounds.right,
        bottom: bounds.bottom
      };
    }
    function findDOMNode(draggable) {
      const node = draggable.findDOMNode();
      if (!node) {
        throw new Error("<DraggableCore>: Unmounted during event!");
      }
      return node;
    }
  }
});

// node_modules/react-draggable/build/cjs/utils/log.js
var require_log = __commonJS({
  "node_modules/react-draggable/build/cjs/utils/log.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = log;
    function log() {
      if (void 0) console.log(...arguments);
    }
  }
});

// node_modules/react-draggable/build/cjs/DraggableCore.js
var require_DraggableCore = __commonJS({
  "node_modules/react-draggable/build/cjs/DraggableCore.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var React13 = _interopRequireWildcard(require_react());
    var _propTypes = _interopRequireDefault(require_prop_types());
    var _reactDom = _interopRequireDefault(require_react_dom());
    var _domFns = require_domFns();
    var _positionFns = require_positionFns();
    var _shims = require_shims();
    var _log = _interopRequireDefault(require_log());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function") return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null) return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var eventsFor = {
      touch: {
        start: "touchstart",
        move: "touchmove",
        stop: "touchend"
      },
      mouse: {
        start: "mousedown",
        move: "mousemove",
        stop: "mouseup"
      }
    };
    var dragEventFor = eventsFor.mouse;
    var DraggableCore = class extends React13.Component {
      constructor() {
        super(...arguments);
        _defineProperty(this, "dragging", false);
        _defineProperty(this, "lastX", NaN);
        _defineProperty(this, "lastY", NaN);
        _defineProperty(this, "touchIdentifier", null);
        _defineProperty(this, "mounted", false);
        _defineProperty(this, "handleDragStart", (e) => {
          this.props.onMouseDown(e);
          if (!this.props.allowAnyClick && typeof e.button === "number" && e.button !== 0) return false;
          const thisNode = this.findDOMNode();
          if (!thisNode || !thisNode.ownerDocument || !thisNode.ownerDocument.body) {
            throw new Error("<DraggableCore> not mounted on DragStart!");
          }
          const {
            ownerDocument
          } = thisNode;
          if (this.props.disabled || !(e.target instanceof ownerDocument.defaultView.Node) || this.props.handle && !(0, _domFns.matchesSelectorAndParentsTo)(e.target, this.props.handle, thisNode) || this.props.cancel && (0, _domFns.matchesSelectorAndParentsTo)(e.target, this.props.cancel, thisNode)) {
            return;
          }
          if (e.type === "touchstart") e.preventDefault();
          const touchIdentifier = (0, _domFns.getTouchIdentifier)(e);
          this.touchIdentifier = touchIdentifier;
          const position = (0, _positionFns.getControlPosition)(e, touchIdentifier, this);
          if (position == null) return;
          const {
            x,
            y
          } = position;
          const coreEvent = (0, _positionFns.createCoreData)(this, x, y);
          (0, _log.default)("DraggableCore: handleDragStart: %j", coreEvent);
          (0, _log.default)("calling", this.props.onStart);
          const shouldUpdate = this.props.onStart(e, coreEvent);
          if (shouldUpdate === false || this.mounted === false) return;
          if (this.props.enableUserSelectHack) (0, _domFns.addUserSelectStyles)(ownerDocument);
          this.dragging = true;
          this.lastX = x;
          this.lastY = y;
          (0, _domFns.addEvent)(ownerDocument, dragEventFor.move, this.handleDrag);
          (0, _domFns.addEvent)(ownerDocument, dragEventFor.stop, this.handleDragStop);
        });
        _defineProperty(this, "handleDrag", (e) => {
          const position = (0, _positionFns.getControlPosition)(e, this.touchIdentifier, this);
          if (position == null) return;
          let {
            x,
            y
          } = position;
          if (Array.isArray(this.props.grid)) {
            let deltaX = x - this.lastX, deltaY = y - this.lastY;
            [deltaX, deltaY] = (0, _positionFns.snapToGrid)(this.props.grid, deltaX, deltaY);
            if (!deltaX && !deltaY) return;
            x = this.lastX + deltaX, y = this.lastY + deltaY;
          }
          const coreEvent = (0, _positionFns.createCoreData)(this, x, y);
          (0, _log.default)("DraggableCore: handleDrag: %j", coreEvent);
          const shouldUpdate = this.props.onDrag(e, coreEvent);
          if (shouldUpdate === false || this.mounted === false) {
            try {
              this.handleDragStop(new MouseEvent("mouseup"));
            } catch (err) {
              const event = document.createEvent("MouseEvents");
              event.initMouseEvent("mouseup", true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
              this.handleDragStop(event);
            }
            return;
          }
          this.lastX = x;
          this.lastY = y;
        });
        _defineProperty(this, "handleDragStop", (e) => {
          if (!this.dragging) return;
          const position = (0, _positionFns.getControlPosition)(e, this.touchIdentifier, this);
          if (position == null) return;
          let {
            x,
            y
          } = position;
          if (Array.isArray(this.props.grid)) {
            let deltaX = x - this.lastX || 0;
            let deltaY = y - this.lastY || 0;
            [deltaX, deltaY] = (0, _positionFns.snapToGrid)(this.props.grid, deltaX, deltaY);
            x = this.lastX + deltaX, y = this.lastY + deltaY;
          }
          const coreEvent = (0, _positionFns.createCoreData)(this, x, y);
          const shouldContinue = this.props.onStop(e, coreEvent);
          if (shouldContinue === false || this.mounted === false) return false;
          const thisNode = this.findDOMNode();
          if (thisNode) {
            if (this.props.enableUserSelectHack) (0, _domFns.removeUserSelectStyles)(thisNode.ownerDocument);
          }
          (0, _log.default)("DraggableCore: handleDragStop: %j", coreEvent);
          this.dragging = false;
          this.lastX = NaN;
          this.lastY = NaN;
          if (thisNode) {
            (0, _log.default)("DraggableCore: Removing handlers");
            (0, _domFns.removeEvent)(thisNode.ownerDocument, dragEventFor.move, this.handleDrag);
            (0, _domFns.removeEvent)(thisNode.ownerDocument, dragEventFor.stop, this.handleDragStop);
          }
        });
        _defineProperty(this, "onMouseDown", (e) => {
          dragEventFor = eventsFor.mouse;
          return this.handleDragStart(e);
        });
        _defineProperty(this, "onMouseUp", (e) => {
          dragEventFor = eventsFor.mouse;
          return this.handleDragStop(e);
        });
        _defineProperty(this, "onTouchStart", (e) => {
          dragEventFor = eventsFor.touch;
          return this.handleDragStart(e);
        });
        _defineProperty(this, "onTouchEnd", (e) => {
          dragEventFor = eventsFor.touch;
          return this.handleDragStop(e);
        });
      }
      componentDidMount() {
        this.mounted = true;
        const thisNode = this.findDOMNode();
        if (thisNode) {
          (0, _domFns.addEvent)(thisNode, eventsFor.touch.start, this.onTouchStart, {
            passive: false
          });
        }
      }
      componentWillUnmount() {
        this.mounted = false;
        const thisNode = this.findDOMNode();
        if (thisNode) {
          const {
            ownerDocument
          } = thisNode;
          (0, _domFns.removeEvent)(ownerDocument, eventsFor.mouse.move, this.handleDrag);
          (0, _domFns.removeEvent)(ownerDocument, eventsFor.touch.move, this.handleDrag);
          (0, _domFns.removeEvent)(ownerDocument, eventsFor.mouse.stop, this.handleDragStop);
          (0, _domFns.removeEvent)(ownerDocument, eventsFor.touch.stop, this.handleDragStop);
          (0, _domFns.removeEvent)(thisNode, eventsFor.touch.start, this.onTouchStart, {
            passive: false
          });
          if (this.props.enableUserSelectHack) (0, _domFns.removeUserSelectStyles)(ownerDocument);
        }
      }
      // React Strict Mode compatibility: if `nodeRef` is passed, we will use it instead of trying to find
      // the underlying DOM node ourselves. See the README for more information.
      findDOMNode() {
        var _this$props, _this$props2;
        return (_this$props = this.props) !== null && _this$props !== void 0 && _this$props.nodeRef ? (_this$props2 = this.props) === null || _this$props2 === void 0 || (_this$props2 = _this$props2.nodeRef) === null || _this$props2 === void 0 ? void 0 : _this$props2.current : _reactDom.default.findDOMNode(this);
      }
      render() {
        return React13.cloneElement(React13.Children.only(this.props.children), {
          // Note: mouseMove handler is attached to document so it will still function
          // when the user drags quickly and leaves the bounds of the element.
          onMouseDown: this.onMouseDown,
          onMouseUp: this.onMouseUp,
          // onTouchStart is added on `componentDidMount` so they can be added with
          // {passive: false}, which allows it to cancel. See
          // https://developers.google.com/web/updates/2017/01/scrolling-intervention
          onTouchEnd: this.onTouchEnd
        });
      }
    };
    exports2.default = DraggableCore;
    _defineProperty(DraggableCore, "displayName", "DraggableCore");
    _defineProperty(DraggableCore, "propTypes", {
      /**
       * `allowAnyClick` allows dragging using any mouse button.
       * By default, we only accept the left button.
       *
       * Defaults to `false`.
       */
      allowAnyClick: _propTypes.default.bool,
      children: _propTypes.default.node.isRequired,
      /**
       * `disabled`, if true, stops the <Draggable> from dragging. All handlers,
       * with the exception of `onMouseDown`, will not fire.
       */
      disabled: _propTypes.default.bool,
      /**
       * By default, we add 'user-select:none' attributes to the document body
       * to prevent ugly text selection during drag. If this is causing problems
       * for your app, set this to `false`.
       */
      enableUserSelectHack: _propTypes.default.bool,
      /**
       * `offsetParent`, if set, uses the passed DOM node to compute drag offsets
       * instead of using the parent node.
       */
      offsetParent: function(props, propName) {
        if (props[propName] && props[propName].nodeType !== 1) {
          throw new Error("Draggable's offsetParent must be a DOM Node.");
        }
      },
      /**
       * `grid` specifies the x and y that dragging should snap to.
       */
      grid: _propTypes.default.arrayOf(_propTypes.default.number),
      /**
       * `handle` specifies a selector to be used as the handle that initiates drag.
       *
       * Example:
       *
       * ```jsx
       *   let App = React.createClass({
       *       render: function () {
       *         return (
       *            <Draggable handle=".handle">
       *              <div>
       *                  <div className="handle">Click me to drag</div>
       *                  <div>This is some other content</div>
       *              </div>
       *           </Draggable>
       *         );
       *       }
       *   });
       * ```
       */
      handle: _propTypes.default.string,
      /**
       * `cancel` specifies a selector to be used to prevent drag initialization.
       *
       * Example:
       *
       * ```jsx
       *   let App = React.createClass({
       *       render: function () {
       *           return(
       *               <Draggable cancel=".cancel">
       *                   <div>
       *                     <div className="cancel">You can't drag from here</div>
       *                     <div>Dragging here works fine</div>
       *                   </div>
       *               </Draggable>
       *           );
       *       }
       *   });
       * ```
       */
      cancel: _propTypes.default.string,
      /* If running in React Strict mode, ReactDOM.findDOMNode() is deprecated.
       * Unfortunately, in order for <Draggable> to work properly, we need raw access
       * to the underlying DOM node. If you want to avoid the warning, pass a `nodeRef`
       * as in this example:
       *
       * function MyComponent() {
       *   const nodeRef = React.useRef(null);
       *   return (
       *     <Draggable nodeRef={nodeRef}>
       *       <div ref={nodeRef}>Example Target</div>
       *     </Draggable>
       *   );
       * }
       *
       * This can be used for arbitrarily nested components, so long as the ref ends up
       * pointing to the actual child DOM node and not a custom component.
       */
      nodeRef: _propTypes.default.object,
      /**
       * Called when dragging starts.
       * If this function returns the boolean false, dragging will be canceled.
       */
      onStart: _propTypes.default.func,
      /**
       * Called while dragging.
       * If this function returns the boolean false, dragging will be canceled.
       */
      onDrag: _propTypes.default.func,
      /**
       * Called when dragging stops.
       * If this function returns the boolean false, the drag will remain active.
       */
      onStop: _propTypes.default.func,
      /**
       * A workaround option which can be passed if onMouseDown needs to be accessed,
       * since it'll always be blocked (as there is internal use of onMouseDown)
       */
      onMouseDown: _propTypes.default.func,
      /**
       * `scale`, if set, applies scaling while dragging an element
       */
      scale: _propTypes.default.number,
      /**
       * These properties should be defined on the child, not here.
       */
      className: _shims.dontSetMe,
      style: _shims.dontSetMe,
      transform: _shims.dontSetMe
    });
    _defineProperty(DraggableCore, "defaultProps", {
      allowAnyClick: false,
      // by default only accept left click
      disabled: false,
      enableUserSelectHack: true,
      onStart: function() {
      },
      onDrag: function() {
      },
      onStop: function() {
      },
      onMouseDown: function() {
      },
      scale: 1
    });
  }
});

// node_modules/react-draggable/build/cjs/Draggable.js
var require_Draggable = __commonJS({
  "node_modules/react-draggable/build/cjs/Draggable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "DraggableCore", {
      enumerable: true,
      get: function() {
        return _DraggableCore.default;
      }
    });
    exports2.default = void 0;
    var React13 = _interopRequireWildcard(require_react());
    var _propTypes = _interopRequireDefault(require_prop_types());
    var _reactDom = _interopRequireDefault(require_react_dom());
    var _clsx = _interopRequireDefault((init_clsx_m(), __toCommonJS(clsx_m_exports)));
    var _domFns = require_domFns();
    var _positionFns = require_positionFns();
    var _shims = require_shims();
    var _DraggableCore = _interopRequireDefault(require_DraggableCore());
    var _log = _interopRequireDefault(require_log());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function") return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _extends() {
      _extends = Object.assign ? Object.assign.bind() : function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends.apply(this, arguments);
    }
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null) return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var Draggable2 = class extends React13.Component {
      // React 16.3+
      // Arity (props, state)
      static getDerivedStateFromProps(_ref, _ref2) {
        let {
          position
        } = _ref;
        let {
          prevPropsPosition
        } = _ref2;
        if (position && (!prevPropsPosition || position.x !== prevPropsPosition.x || position.y !== prevPropsPosition.y)) {
          (0, _log.default)("Draggable: getDerivedStateFromProps %j", {
            position,
            prevPropsPosition
          });
          return {
            x: position.x,
            y: position.y,
            prevPropsPosition: {
              ...position
            }
          };
        }
        return null;
      }
      constructor(props) {
        super(props);
        _defineProperty(this, "onDragStart", (e, coreData) => {
          (0, _log.default)("Draggable: onDragStart: %j", coreData);
          const shouldStart = this.props.onStart(e, (0, _positionFns.createDraggableData)(this, coreData));
          if (shouldStart === false) return false;
          this.setState({
            dragging: true,
            dragged: true
          });
        });
        _defineProperty(this, "onDrag", (e, coreData) => {
          if (!this.state.dragging) return false;
          (0, _log.default)("Draggable: onDrag: %j", coreData);
          const uiData = (0, _positionFns.createDraggableData)(this, coreData);
          const newState = {
            x: uiData.x,
            y: uiData.y,
            slackX: 0,
            slackY: 0
          };
          if (this.props.bounds) {
            const {
              x,
              y
            } = newState;
            newState.x += this.state.slackX;
            newState.y += this.state.slackY;
            const [newStateX, newStateY] = (0, _positionFns.getBoundPosition)(this, newState.x, newState.y);
            newState.x = newStateX;
            newState.y = newStateY;
            newState.slackX = this.state.slackX + (x - newState.x);
            newState.slackY = this.state.slackY + (y - newState.y);
            uiData.x = newState.x;
            uiData.y = newState.y;
            uiData.deltaX = newState.x - this.state.x;
            uiData.deltaY = newState.y - this.state.y;
          }
          const shouldUpdate = this.props.onDrag(e, uiData);
          if (shouldUpdate === false) return false;
          this.setState(newState);
        });
        _defineProperty(this, "onDragStop", (e, coreData) => {
          if (!this.state.dragging) return false;
          const shouldContinue = this.props.onStop(e, (0, _positionFns.createDraggableData)(this, coreData));
          if (shouldContinue === false) return false;
          (0, _log.default)("Draggable: onDragStop: %j", coreData);
          const newState = {
            dragging: false,
            slackX: 0,
            slackY: 0
          };
          const controlled = Boolean(this.props.position);
          if (controlled) {
            const {
              x,
              y
            } = this.props.position;
            newState.x = x;
            newState.y = y;
          }
          this.setState(newState);
        });
        this.state = {
          // Whether or not we are currently dragging.
          dragging: false,
          // Whether or not we have been dragged before.
          dragged: false,
          // Current transform x and y.
          x: props.position ? props.position.x : props.defaultPosition.x,
          y: props.position ? props.position.y : props.defaultPosition.y,
          prevPropsPosition: {
            ...props.position
          },
          // Used for compensating for out-of-bounds drags
          slackX: 0,
          slackY: 0,
          // Can only determine if SVG after mounting
          isElementSVG: false
        };
        if (props.position && !(props.onDrag || props.onStop)) {
          console.warn("A `position` was applied to this <Draggable>, without drag handlers. This will make this component effectively undraggable. Please attach `onDrag` or `onStop` handlers so you can adjust the `position` of this element.");
        }
      }
      componentDidMount() {
        if (typeof window.SVGElement !== "undefined" && this.findDOMNode() instanceof window.SVGElement) {
          this.setState({
            isElementSVG: true
          });
        }
      }
      componentWillUnmount() {
        this.setState({
          dragging: false
        });
      }
      // React Strict Mode compatibility: if `nodeRef` is passed, we will use it instead of trying to find
      // the underlying DOM node ourselves. See the README for more information.
      findDOMNode() {
        var _this$props$nodeRef$c, _this$props;
        return (_this$props$nodeRef$c = (_this$props = this.props) === null || _this$props === void 0 || (_this$props = _this$props.nodeRef) === null || _this$props === void 0 ? void 0 : _this$props.current) !== null && _this$props$nodeRef$c !== void 0 ? _this$props$nodeRef$c : _reactDom.default.findDOMNode(this);
      }
      render() {
        const {
          axis,
          bounds,
          children,
          defaultPosition,
          defaultClassName,
          defaultClassNameDragging,
          defaultClassNameDragged,
          position,
          positionOffset,
          scale,
          ...draggableCoreProps
        } = this.props;
        let style = {};
        let svgTransform = null;
        const controlled = Boolean(position);
        const draggable = !controlled || this.state.dragging;
        const validPosition = position || defaultPosition;
        const transformOpts = {
          // Set left if horizontal drag is enabled
          x: (0, _positionFns.canDragX)(this) && draggable ? this.state.x : validPosition.x,
          // Set top if vertical drag is enabled
          y: (0, _positionFns.canDragY)(this) && draggable ? this.state.y : validPosition.y
        };
        if (this.state.isElementSVG) {
          svgTransform = (0, _domFns.createSVGTransform)(transformOpts, positionOffset);
        } else {
          style = (0, _domFns.createCSSTransform)(transformOpts, positionOffset);
        }
        const className = (0, _clsx.default)(children.props.className || "", defaultClassName, {
          [defaultClassNameDragging]: this.state.dragging,
          [defaultClassNameDragged]: this.state.dragged
        });
        return React13.createElement(_DraggableCore.default, _extends({}, draggableCoreProps, {
          onStart: this.onDragStart,
          onDrag: this.onDrag,
          onStop: this.onDragStop
        }), React13.cloneElement(React13.Children.only(children), {
          className,
          style: {
            ...children.props.style,
            ...style
          },
          transform: svgTransform
        }));
      }
    };
    exports2.default = Draggable2;
    _defineProperty(Draggable2, "displayName", "Draggable");
    _defineProperty(Draggable2, "propTypes", {
      // Accepts all props <DraggableCore> accepts.
      ..._DraggableCore.default.propTypes,
      /**
       * `axis` determines which axis the draggable can move.
       *
       *  Note that all callbacks will still return data as normal. This only
       *  controls flushing to the DOM.
       *
       * 'both' allows movement horizontally and vertically.
       * 'x' limits movement to horizontal axis.
       * 'y' limits movement to vertical axis.
       * 'none' limits all movement.
       *
       * Defaults to 'both'.
       */
      axis: _propTypes.default.oneOf(["both", "x", "y", "none"]),
      /**
       * `bounds` determines the range of movement available to the element.
       * Available values are:
       *
       * 'parent' restricts movement within the Draggable's parent node.
       *
       * Alternatively, pass an object with the following properties, all of which are optional:
       *
       * {left: LEFT_BOUND, right: RIGHT_BOUND, bottom: BOTTOM_BOUND, top: TOP_BOUND}
       *
       * All values are in px.
       *
       * Example:
       *
       * ```jsx
       *   let App = React.createClass({
       *       render: function () {
       *         return (
       *            <Draggable bounds={{right: 300, bottom: 300}}>
       *              <div>Content</div>
       *           </Draggable>
       *         );
       *       }
       *   });
       * ```
       */
      bounds: _propTypes.default.oneOfType([_propTypes.default.shape({
        left: _propTypes.default.number,
        right: _propTypes.default.number,
        top: _propTypes.default.number,
        bottom: _propTypes.default.number
      }), _propTypes.default.string, _propTypes.default.oneOf([false])]),
      defaultClassName: _propTypes.default.string,
      defaultClassNameDragging: _propTypes.default.string,
      defaultClassNameDragged: _propTypes.default.string,
      /**
       * `defaultPosition` specifies the x and y that the dragged item should start at
       *
       * Example:
       *
       * ```jsx
       *      let App = React.createClass({
       *          render: function () {
       *              return (
       *                  <Draggable defaultPosition={{x: 25, y: 25}}>
       *                      <div>I start with transformX: 25px and transformY: 25px;</div>
       *                  </Draggable>
       *              );
       *          }
       *      });
       * ```
       */
      defaultPosition: _propTypes.default.shape({
        x: _propTypes.default.number,
        y: _propTypes.default.number
      }),
      positionOffset: _propTypes.default.shape({
        x: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.string]),
        y: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.string])
      }),
      /**
       * `position`, if present, defines the current position of the element.
       *
       *  This is similar to how form elements in React work - if no `position` is supplied, the component
       *  is uncontrolled.
       *
       * Example:
       *
       * ```jsx
       *      let App = React.createClass({
       *          render: function () {
       *              return (
       *                  <Draggable position={{x: 25, y: 25}}>
       *                      <div>I start with transformX: 25px and transformY: 25px;</div>
       *                  </Draggable>
       *              );
       *          }
       *      });
       * ```
       */
      position: _propTypes.default.shape({
        x: _propTypes.default.number,
        y: _propTypes.default.number
      }),
      /**
       * These properties should be defined on the child, not here.
       */
      className: _shims.dontSetMe,
      style: _shims.dontSetMe,
      transform: _shims.dontSetMe
    });
    _defineProperty(Draggable2, "defaultProps", {
      ..._DraggableCore.default.defaultProps,
      axis: "both",
      bounds: false,
      defaultClassName: "react-draggable",
      defaultClassNameDragging: "react-draggable-dragging",
      defaultClassNameDragged: "react-draggable-dragged",
      defaultPosition: {
        x: 0,
        y: 0
      },
      scale: 1
    });
  }
});

// node_modules/react-draggable/build/cjs/cjs.js
var require_cjs = __commonJS({
  "node_modules/react-draggable/build/cjs/cjs.js"(exports2, module2) {
    "use strict";
    var {
      default: Draggable2,
      DraggableCore
    } = require_Draggable();
    module2.exports = Draggable2;
    module2.exports.default = Draggable2;
    module2.exports.DraggableCore = DraggableCore;
  }
});

// node_modules/react-pdf-highlighter/dist/esm/components/PdfHighlighter.js
var import_pdf_viewer3 = __toESM(require_pdf_viewer());
var import_react4 = __toESM(require_react());
import "C:/projects/pipeshub-v2/pipeshub-ai/standalone-frontend/node_modules/react-pdf-highlighter/node_modules/pdfjs-dist/web/pdf_viewer.css";
import "C:/projects/pipeshub-v2/pipeshub-ai/standalone-frontend/node_modules/react-pdf-highlighter/dist/esm/style/pdf_viewer.css";
import "C:/projects/pipeshub-v2/pipeshub-ai/standalone-frontend/node_modules/react-pdf-highlighter/dist/esm/style/PdfHighlighter.css";

// node_modules/react-pdf-highlighter/dist/esm/lib/pdfjs-dom.js
var getDocument2 = (elm) => (elm || {}).ownerDocument || document;
var getWindow = (elm) => (getDocument2(elm) || {}).defaultView || window;
var isHTMLElement = (elm) => elm instanceof HTMLElement || elm instanceof getWindow(elm).HTMLElement;
var isHTMLCanvasElement = (elm) => elm instanceof HTMLCanvasElement || elm instanceof getWindow(elm).HTMLCanvasElement;
var asElement = (x) => x;
var getPageFromElement = (target) => {
  const node = asElement(target.closest(".page"));
  if (!node || !isHTMLElement(node)) {
    return null;
  }
  const number = Number(asElement(node).dataset.pageNumber);
  return { node, number };
};
var getPagesFromRange = (range) => {
  const startParentElement = range.startContainer.parentElement;
  const endParentElement = range.endContainer.parentElement;
  if (!isHTMLElement(startParentElement) || !isHTMLElement(endParentElement)) {
    return [];
  }
  const startPage = getPageFromElement(asElement(startParentElement));
  const endPage = getPageFromElement(asElement(endParentElement));
  if (!(startPage === null || startPage === void 0 ? void 0 : startPage.number) || !(endPage === null || endPage === void 0 ? void 0 : endPage.number)) {
    return [];
  }
  if (startPage.number === endPage.number) {
    return [startPage];
  }
  if (startPage.number === endPage.number - 1) {
    return [startPage, endPage];
  }
  const pages = [];
  let currentPageNumber = startPage.number;
  const document2 = startPage.node.ownerDocument;
  while (currentPageNumber <= endPage.number) {
    const currentPage = getPageFromElement(document2.querySelector(`[data-page-number='${currentPageNumber}'`));
    if (currentPage) {
      pages.push(currentPage);
    }
    currentPageNumber++;
  }
  return pages;
};
var findOrCreateContainerLayer = (container, className) => {
  const doc = getDocument2(container);
  let layer = container.querySelector(`.${className}`);
  if (!layer) {
    layer = doc.createElement("div");
    layer.className = className;
    container.appendChild(layer);
  }
  return layer;
};

// node_modules/react-pdf-highlighter/dist/esm/lib/coordinates.js
var viewportToScaled = (rect, { width, height }) => {
  return {
    x1: rect.left,
    y1: rect.top,
    x2: rect.left + rect.width,
    y2: rect.top + rect.height,
    width,
    height,
    pageNumber: rect.pageNumber
  };
};
var pdfToViewport = (pdf, viewport) => {
  const [x1, y1, x2, y2] = viewport.convertToViewportRectangle([
    pdf.x1,
    pdf.y1,
    pdf.x2,
    pdf.y2
  ]);
  return {
    left: Math.min(x1, x2),
    top: Math.min(y1, y2),
    width: Math.abs(x2 - x1),
    height: Math.abs(y1 - y2),
    pageNumber: pdf.pageNumber
  };
};
var scaledToViewport = (scaled, viewport, usePdfCoordinates = false) => {
  const { width, height } = viewport;
  if (usePdfCoordinates) {
    return pdfToViewport(scaled, viewport);
  }
  if (scaled.x1 === void 0) {
    throw new Error("You are using old position format, please update");
  }
  const x1 = width * scaled.x1 / scaled.width;
  const y1 = height * scaled.y1 / scaled.height;
  const x2 = width * scaled.x2 / scaled.width;
  const y2 = height * scaled.y2 / scaled.height;
  return {
    left: x1,
    top: y1,
    width: x2 - x1,
    height: y2 - y1,
    pageNumber: scaled.pageNumber
  };
};

// node_modules/react-pdf-highlighter/dist/esm/components/MouseSelection.js
var import_react = __toESM(require_react());
import "C:/projects/pipeshub-v2/pipeshub-ai/standalone-frontend/node_modules/react-pdf-highlighter/dist/esm/style/MouseSelection.css";
var MouseSelection = class extends import_react.Component {
  constructor() {
    super(...arguments);
    this.state = {
      locked: false,
      start: null,
      end: null
    };
    this.reset = () => {
      const { onDragEnd } = this.props;
      onDragEnd();
      this.setState({ start: null, end: null, locked: false });
    };
  }
  getBoundingRect(start, end) {
    return {
      left: Math.min(end.x, start.x),
      top: Math.min(end.y, start.y),
      width: Math.abs(end.x - start.x),
      height: Math.abs(end.y - start.y)
    };
  }
  componentDidUpdate() {
    const { onChange } = this.props;
    const { start, end } = this.state;
    const isVisible = Boolean(start && end);
    onChange(isVisible);
  }
  componentDidMount() {
    if (!this.root) {
      return;
    }
    const that = this;
    const { onSelection, onDragStart, onDragEnd, shouldStart } = this.props;
    const container = asElement(this.root.parentElement);
    if (!isHTMLElement(container)) {
      return;
    }
    let containerBoundingRect = null;
    const containerCoords = (pageX, pageY) => {
      if (!containerBoundingRect) {
        containerBoundingRect = container.getBoundingClientRect();
      }
      return {
        x: pageX - containerBoundingRect.left + container.scrollLeft,
        y: pageY - containerBoundingRect.top + container.scrollTop - window.scrollY
      };
    };
    container.addEventListener("mousemove", (event) => {
      const { start, locked } = this.state;
      if (!start || locked) {
        return;
      }
      that.setState(Object.assign(Object.assign({}, this.state), { end: containerCoords(event.pageX, event.pageY) }));
    });
    container.addEventListener("mousedown", (event) => {
      if (!shouldStart(event)) {
        this.reset();
        return;
      }
      const startTarget = asElement(event.target);
      if (!isHTMLElement(startTarget)) {
        return;
      }
      onDragStart();
      this.setState({
        start: containerCoords(event.pageX, event.pageY),
        end: null,
        locked: false
      });
      const onMouseUp = (event2) => {
        var _a;
        (_a = event2.currentTarget) === null || _a === void 0 ? void 0 : _a.removeEventListener("mouseup", onMouseUp);
        const { start } = this.state;
        if (!start) {
          return;
        }
        const end = containerCoords(event2.pageX, event2.pageY);
        const boundingRect = that.getBoundingRect(start, end);
        if (!isHTMLElement(event2.target) || !container.contains(asElement(event2.target)) || !that.shouldRender(boundingRect)) {
          that.reset();
          return;
        }
        that.setState({
          end,
          locked: true
        }, () => {
          const { start: start2, end: end2 } = that.state;
          if (!start2 || !end2) {
            return;
          }
          if (isHTMLElement(event2.target)) {
            onSelection(startTarget, boundingRect, that.reset);
            onDragEnd();
          }
        });
      };
      const { ownerDocument: doc } = container;
      if (doc.body) {
        doc.body.addEventListener("mouseup", onMouseUp);
      }
    });
  }
  shouldRender(boundingRect) {
    return boundingRect.width >= 1 && boundingRect.height >= 1;
  }
  render() {
    const { start, end } = this.state;
    return import_react.default.createElement("div", { className: "MouseSelection-container", ref: (node) => {
      if (!node) {
        return;
      }
      this.root = node;
    } }, start && end ? import_react.default.createElement("div", { className: "MouseSelection", style: this.getBoundingRect(start, end) }) : null);
  }
};
var MouseSelection_default = MouseSelection;

// node_modules/react-pdf-highlighter/dist/esm/components/TipContainer.js
var import_react2 = __toESM(require_react());
var clamp = (value, left, right) => Math.min(Math.max(value, left), right);
var TipContainer = class extends import_react2.Component {
  constructor() {
    super(...arguments);
    this.state = {
      height: 0,
      width: 0
    };
    this.node = null;
    this.updatePosition = () => {
      if (!this.node) {
        return;
      }
      const { offsetHeight, offsetWidth } = this.node;
      this.setState({
        height: offsetHeight,
        width: offsetWidth
      });
    };
  }
  componentDidUpdate(nextProps) {
    if (this.props.children !== nextProps.children) {
      this.updatePosition();
    }
  }
  componentDidMount() {
    setTimeout(this.updatePosition, 0);
  }
  render() {
    const { children, style, scrollTop, pageBoundingRect } = this.props;
    const { height, width } = this.state;
    const isStyleCalculationInProgress = width === 0 && height === 0;
    const shouldMove = style.top - height - 5 < scrollTop;
    const top = shouldMove ? style.bottom + 5 : style.top - height - 5;
    const left = clamp(style.left - width / 2, 0, pageBoundingRect.width - width);
    const childrenWithProps = import_react2.default.Children.map(children, (child) => (
      // @ts-ignore
      import_react2.default.cloneElement(child, {
        onUpdate: () => {
          this.setState({
            width: 0,
            height: 0
          }, () => {
            setTimeout(this.updatePosition, 0);
          });
        },
        popup: {
          position: shouldMove ? "below" : "above"
        }
      })
    ));
    return import_react2.default.createElement("div", { className: "PdfHighlighter__tip-container", style: {
      visibility: isStyleCalculationInProgress ? "hidden" : "visible",
      top,
      left
    }, ref: (node) => {
      this.node = node;
    } }, childrenWithProps);
  }
};
var TipContainer_default = TipContainer;

// node_modules/react-pdf-highlighter/dist/esm/components/PdfHighlighter.js
var import_client = __toESM(require_client());
var import_lodash = __toESM(require_lodash());

// node_modules/react-pdf-highlighter/dist/esm/lib/get-area-as-png.js
var getAreaAsPNG = (canvas, position) => {
  const { left, top, width, height } = position;
  const doc = canvas ? canvas.ownerDocument : null;
  const newCanvas = doc && doc.createElement("canvas");
  if (!newCanvas || !isHTMLCanvasElement(newCanvas)) {
    return "";
  }
  newCanvas.width = width;
  newCanvas.height = height;
  const newCanvasContext = newCanvas.getContext("2d");
  if (!newCanvasContext || !canvas) {
    return "";
  }
  const dpr = window.devicePixelRatio;
  newCanvasContext.drawImage(canvas, left * dpr, top * dpr, width * dpr, height * dpr, 0, 0, width, height);
  return newCanvas.toDataURL("image/png");
};
var get_area_as_png_default = getAreaAsPNG;

// node_modules/react-pdf-highlighter/dist/esm/lib/get-bounding-rect.js
var getBoundingRect = (clientRects) => {
  const rects = Array.from(clientRects).map((rect) => {
    const { left, top, width, height, pageNumber: pageNumber2 } = rect;
    const X02 = left;
    const X12 = left + width;
    const Y02 = top;
    const Y12 = top + height;
    return { X0: X02, X1: X12, Y0: Y02, Y1: Y12, pageNumber: pageNumber2 };
  });
  let firstPageNumber = Number.MAX_SAFE_INTEGER;
  rects.forEach((rect) => {
    var _a;
    firstPageNumber = Math.min(firstPageNumber, (_a = rect.pageNumber) !== null && _a !== void 0 ? _a : firstPageNumber);
  });
  const rectsWithSizeOnFirstPage = rects.filter((rect) => (rect.X0 > 0 || rect.X1 > 0 || rect.Y0 > 0 || rect.Y1 > 0) && rect.pageNumber === firstPageNumber);
  const optimal = rectsWithSizeOnFirstPage.reduce((res, rect) => {
    return {
      X0: Math.min(res.X0, rect.X0),
      X1: Math.max(res.X1, rect.X1),
      Y0: Math.min(res.Y0, rect.Y0),
      Y1: Math.max(res.Y1, rect.Y1),
      pageNumber: firstPageNumber
    };
  }, rectsWithSizeOnFirstPage[0]);
  const { X0, X1, Y0, Y1, pageNumber } = optimal;
  return {
    left: X0,
    top: Y0,
    width: X1 - X0,
    height: Y1 - Y0,
    pageNumber
  };
};
var get_bounding_rect_default = getBoundingRect;

// node_modules/react-pdf-highlighter/dist/esm/lib/optimize-client-rects.js
var sort = (rects) => rects.sort((A, B) => {
  const top = (A.pageNumber || 0) * A.top - (B.pageNumber || 0) * B.top;
  if (top === 0) {
    return A.left - B.left;
  }
  return top;
});
var overlaps = (A, B) => A.pageNumber === B.pageNumber && A.left <= B.left && B.left <= A.left + A.width;
var sameLine = (A, B, yMargin = 5) => A.pageNumber === B.pageNumber && Math.abs(A.top - B.top) < yMargin && Math.abs(A.height - B.height) < yMargin;
var inside = (A, B) => A.pageNumber === B.pageNumber && A.top > B.top && A.left > B.left && A.top + A.height < B.top + B.height && A.left + A.width < B.left + B.width;
var nextTo = (A, B, xMargin = 10) => {
  const Aright = A.left + A.width;
  const Bright = B.left + B.width;
  return A.pageNumber === B.pageNumber && A.left <= B.left && Aright <= Bright && B.left - Aright <= xMargin;
};
var extendWidth = (A, B) => {
  A.width = Math.max(B.width - A.left + B.left, A.width);
};
var optimizeClientRects = (clientRects) => {
  const rects = sort(clientRects);
  const toRemove = /* @__PURE__ */ new Set();
  const firstPass = rects.filter((rect) => {
    return rects.every((otherRect) => {
      return !inside(rect, otherRect);
    });
  });
  let passCount = 0;
  while (passCount <= 2) {
    firstPass.forEach((A) => {
      firstPass.forEach((B) => {
        if (A === B || toRemove.has(A) || toRemove.has(B)) {
          return;
        }
        if (!sameLine(A, B)) {
          return;
        }
        if (overlaps(A, B)) {
          extendWidth(A, B);
          A.height = Math.max(A.height, B.height);
          toRemove.add(B);
        }
        if (nextTo(A, B)) {
          extendWidth(A, B);
          toRemove.add(B);
        }
      });
    });
    passCount += 1;
  }
  return firstPass.filter((rect) => !toRemove.has(rect));
};
var optimize_client_rects_default = optimizeClientRects;

// node_modules/react-pdf-highlighter/dist/esm/lib/get-client-rects.js
var isClientRectInsidePageRect = (clientRect, pageRect) => {
  if (clientRect.top < pageRect.top) {
    return false;
  }
  if (clientRect.bottom > pageRect.bottom) {
    return false;
  }
  if (clientRect.right > pageRect.right) {
    return false;
  }
  if (clientRect.left < pageRect.left) {
    return false;
  }
  return true;
};
var getClientRects = (range, pages, shouldOptimize = true) => {
  const clientRects = Array.from(range.getClientRects());
  const rects = [];
  for (const clientRect of clientRects) {
    for (const page of pages) {
      const pageRect = page.node.getBoundingClientRect();
      if (isClientRectInsidePageRect(clientRect, pageRect) && clientRect.width > 0 && clientRect.height > 0 && clientRect.width < pageRect.width && clientRect.height < pageRect.height) {
        const highlightedRect = {
          top: clientRect.top + page.node.scrollTop - pageRect.top,
          left: clientRect.left + page.node.scrollLeft - pageRect.left,
          width: clientRect.width,
          height: clientRect.height,
          pageNumber: page.number
        };
        rects.push(highlightedRect);
      }
    }
  }
  return shouldOptimize ? optimize_client_rects_default(rects) : rects;
};
var get_client_rects_default = getClientRects;

// node_modules/react-pdf-highlighter/dist/esm/components/HighlightLayer.js
var import_react3 = __toESM(require_react());
var __rest = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
function HighlightLayer({ highlightsByPage, scaledPositionToViewport, pageNumber, scrolledToHighlightId, highlightTransform, tip, hideTipAndSelection, viewer, screenshot, showTip, setState }) {
  const currentHighlights = highlightsByPage[String(pageNumber)] || [];
  return import_react3.default.createElement("div", null, currentHighlights.map((_a, index) => {
    var { position, id } = _a, highlight = __rest(_a, ["position", "id"]);
    const viewportHighlight = Object.assign({ id, position: scaledPositionToViewport(position) }, highlight);
    if (tip && tip.highlight.id === String(id)) {
      showTip(tip.highlight, tip.callback(viewportHighlight));
    }
    const isScrolledTo = Boolean(scrolledToHighlightId === id);
    return highlightTransform(viewportHighlight, index, (highlight2, callback) => {
      setState({
        tip: { highlight: highlight2, callback }
      });
      showTip(highlight2, callback(highlight2));
    }, hideTipAndSelection, (rect) => {
      const viewport = viewer.getPageView((rect.pageNumber || parseInt(pageNumber)) - 1).viewport;
      return viewportToScaled(rect, viewport);
    }, (boundingRect) => screenshot(boundingRect, parseInt(pageNumber)), isScrolledTo);
  }));
}

// node_modules/react-pdf-highlighter/dist/esm/components/PdfHighlighter.js
var EMPTY_ID = "empty-id";
var PdfHighlighter = class extends import_react4.PureComponent {
  constructor(props) {
    super(props);
    this.state = {
      ghostHighlight: null,
      isCollapsed: true,
      range: null,
      scrolledToHighlightId: EMPTY_ID,
      isAreaSelectionInProgress: false,
      tip: null,
      tipPosition: null,
      tipChildren: null
    };
    this.eventBus = new import_pdf_viewer3.EventBus();
    this.linkService = new import_pdf_viewer3.PDFLinkService({
      eventBus: this.eventBus,
      externalLinkTarget: 2
    });
    this.resizeObserver = null;
    this.containerNode = null;
    this.highlightRoots = {};
    this.unsubscribe = () => {
    };
    this.attachRef = () => {
      var _a;
      const { eventBus, resizeObserver: observer } = this;
      const ref = this.containerNode = this.containerNodeRef.current;
      this.unsubscribe();
      if (ref) {
        const { ownerDocument: doc } = ref;
        eventBus.on("textlayerrendered", this.onTextLayerRendered);
        eventBus.on("pagesinit", this.onDocumentReady);
        doc.addEventListener("selectionchange", this.onSelectionChange);
        doc.addEventListener("keydown", this.handleKeyDown);
        (_a = doc.defaultView) === null || _a === void 0 ? void 0 : _a.addEventListener("resize", this.debouncedScaleValue);
        if (observer)
          observer.observe(ref);
        this.unsubscribe = () => {
          var _a2;
          eventBus.off("pagesinit", this.onDocumentReady);
          eventBus.off("textlayerrendered", this.onTextLayerRendered);
          doc.removeEventListener("selectionchange", this.onSelectionChange);
          doc.removeEventListener("keydown", this.handleKeyDown);
          (_a2 = doc.defaultView) === null || _a2 === void 0 ? void 0 : _a2.removeEventListener("resize", this.debouncedScaleValue);
          if (observer)
            observer.disconnect();
        };
      }
    };
    this.hideTipAndSelection = () => {
      this.setState({
        tipPosition: null,
        tipChildren: null
      });
      this.setState({ ghostHighlight: null, tip: null }, () => this.renderHighlightLayers());
    };
    this.renderTip = () => {
      const { tipPosition, tipChildren } = this.state;
      if (!tipPosition)
        return null;
      const { boundingRect, pageNumber } = tipPosition;
      const page = {
        node: this.viewer.getPageView((boundingRect.pageNumber || pageNumber) - 1).div,
        pageNumber: boundingRect.pageNumber || pageNumber
      };
      const pageBoundingClientRect = page.node.getBoundingClientRect();
      const pageBoundingRect = {
        bottom: pageBoundingClientRect.bottom,
        height: pageBoundingClientRect.height,
        left: pageBoundingClientRect.left,
        right: pageBoundingClientRect.right,
        top: pageBoundingClientRect.top,
        width: pageBoundingClientRect.width,
        x: pageBoundingClientRect.x,
        y: pageBoundingClientRect.y,
        pageNumber: page.pageNumber
      };
      return import_react4.default.createElement(TipContainer_default, { scrollTop: this.viewer.container.scrollTop, pageBoundingRect, style: {
        left: page.node.offsetLeft + boundingRect.left + boundingRect.width / 2,
        top: boundingRect.top + page.node.offsetTop,
        bottom: boundingRect.top + page.node.offsetTop + boundingRect.height
      } }, tipChildren);
    };
    this.onTextLayerRendered = () => {
      this.renderHighlightLayers();
    };
    this.scrollTo = (highlight) => {
      const { pageNumber, boundingRect, usePdfCoordinates } = highlight.position;
      this.viewer.container.removeEventListener("scroll", this.onScroll);
      const pageViewport = this.viewer.getPageView(pageNumber - 1).viewport;
      const scrollMargin = 10;
      this.viewer.scrollPageIntoView({
        pageNumber,
        destArray: [
          null,
          { name: "XYZ" },
          ...pageViewport.convertToPdfPoint(0, scaledToViewport(boundingRect, pageViewport, usePdfCoordinates).top - scrollMargin),
          0
        ]
      });
      this.setState({
        scrolledToHighlightId: highlight.id
      }, () => this.renderHighlightLayers());
      setTimeout(() => {
        this.viewer.container.addEventListener("scroll", this.onScroll);
      }, 100);
    };
    this.onDocumentReady = () => {
      const { scrollRef } = this.props;
      this.handleScaleValue();
      scrollRef(this.scrollTo);
    };
    this.onSelectionChange = () => {
      const container = this.containerNode;
      const selection = getWindow(container).getSelection();
      if (!selection) {
        return;
      }
      const range = selection.rangeCount > 0 ? selection.getRangeAt(0) : null;
      if (selection.isCollapsed) {
        this.setState({ isCollapsed: true });
        return;
      }
      if (!range || !container || !container.contains(range.commonAncestorContainer)) {
        return;
      }
      this.setState({
        isCollapsed: false,
        range
      });
      this.debouncedAfterSelection();
    };
    this.onScroll = () => {
      const { onScrollChange } = this.props;
      onScrollChange();
      this.setState({
        scrolledToHighlightId: EMPTY_ID
      }, () => this.renderHighlightLayers());
      this.viewer.container.removeEventListener("scroll", this.onScroll);
    };
    this.onMouseDown = (event) => {
      if (!isHTMLElement(event.target)) {
        return;
      }
      if (asElement(event.target).closest(".PdfHighlighter__tip-container")) {
        return;
      }
      this.hideTipAndSelection();
    };
    this.handleKeyDown = (event) => {
      if (event.code === "Escape") {
        this.hideTipAndSelection();
      }
    };
    this.afterSelection = () => {
      const { onSelectionFinished } = this.props;
      const { isCollapsed, range } = this.state;
      if (!range || isCollapsed) {
        return;
      }
      const pages = getPagesFromRange(range);
      if (!pages || pages.length === 0) {
        return;
      }
      const rects = get_client_rects_default(range, pages);
      if (rects.length === 0) {
        return;
      }
      const boundingRect = get_bounding_rect_default(rects);
      const viewportPosition = {
        boundingRect,
        rects,
        pageNumber: pages[0].number
      };
      const content = {
        text: range.toString()
      };
      const scaledPosition = this.viewportPositionToScaled(viewportPosition);
      this.setTip(viewportPosition, onSelectionFinished(scaledPosition, content, () => this.hideTipAndSelection(), () => this.setState({
        ghostHighlight: { position: scaledPosition }
      }, () => this.renderHighlightLayers())));
    };
    this.debouncedAfterSelection = (0, import_lodash.default)(this.afterSelection, 500);
    this.handleScaleValue = () => {
      if (this.viewer) {
        this.viewer.currentScaleValue = this.props.pdfScaleValue;
      }
    };
    this.debouncedScaleValue = (0, import_lodash.default)(this.handleScaleValue, 500);
    if (typeof ResizeObserver !== "undefined") {
      this.resizeObserver = new ResizeObserver(this.debouncedScaleValue);
    }
    this.containerNodeRef = import_react4.default.createRef();
  }
  componentDidMount() {
    this.init();
  }
  componentDidUpdate(prevProps) {
    if (prevProps.pdfDocument !== this.props.pdfDocument) {
      this.init();
      return;
    }
    if (prevProps.highlights !== this.props.highlights) {
      this.renderHighlightLayers();
    }
  }
  init() {
    const { pdfDocument } = this.props;
    this.attachRef();
    this.viewer = this.viewer || new import_pdf_viewer3.PDFViewer({
      container: this.containerNodeRef.current,
      eventBus: this.eventBus,
      // enhanceTextSelection: true, // deprecated. https://github.com/mozilla/pdf.js/issues/9943#issuecomment-409369485
      textLayerMode: 2,
      removePageBorders: true,
      linkService: this.linkService,
      l10n: import_pdf_viewer3.NullL10n
    });
    this.linkService.setDocument(pdfDocument);
    this.linkService.setViewer(this.viewer);
    this.viewer.setDocument(pdfDocument);
    window.PdfViewer = this;
  }
  componentWillUnmount() {
    this.unsubscribe();
  }
  findOrCreateHighlightLayer(page) {
    const { textLayer } = this.viewer.getPageView(page - 1) || {};
    if (!textLayer) {
      return null;
    }
    return findOrCreateContainerLayer(textLayer.textLayerDiv, "PdfHighlighter__highlight-layer");
  }
  groupHighlightsByPage(highlights) {
    const { ghostHighlight } = this.state;
    const allHighlights = [...highlights, ghostHighlight].filter(Boolean);
    const pageNumbers = /* @__PURE__ */ new Set();
    for (const highlight of allHighlights) {
      pageNumbers.add(highlight.position.pageNumber);
      for (const rect of highlight.position.rects) {
        if (rect.pageNumber) {
          pageNumbers.add(rect.pageNumber);
        }
      }
    }
    const groupedHighlights = {};
    for (const pageNumber of pageNumbers) {
      groupedHighlights[pageNumber] = groupedHighlights[pageNumber] || [];
      for (const highlight of allHighlights) {
        const pageSpecificHighlight = Object.assign(Object.assign({}, highlight), { position: {
          pageNumber,
          boundingRect: highlight.position.boundingRect,
          rects: [],
          usePdfCoordinates: highlight.position.usePdfCoordinates
        } });
        let anyRectsOnPage = false;
        for (const rect of highlight.position.rects) {
          if (pageNumber === (rect.pageNumber || highlight.position.pageNumber)) {
            pageSpecificHighlight.position.rects.push(rect);
            anyRectsOnPage = true;
          }
        }
        if (anyRectsOnPage || pageNumber === highlight.position.pageNumber) {
          groupedHighlights[pageNumber].push(pageSpecificHighlight);
        }
      }
    }
    return groupedHighlights;
  }
  showTip(highlight, content) {
    const { isCollapsed, ghostHighlight, isAreaSelectionInProgress } = this.state;
    const highlightInProgress = !isCollapsed || ghostHighlight;
    if (highlightInProgress || isAreaSelectionInProgress) {
      return;
    }
    this.setTip(highlight.position, content);
  }
  scaledPositionToViewport({ pageNumber, boundingRect, rects, usePdfCoordinates }) {
    const viewport = this.viewer.getPageView(pageNumber - 1).viewport;
    return {
      boundingRect: scaledToViewport(boundingRect, viewport, usePdfCoordinates),
      rects: (rects || []).map((rect) => scaledToViewport(rect, viewport, usePdfCoordinates)),
      pageNumber
    };
  }
  viewportPositionToScaled({ pageNumber, boundingRect, rects }) {
    const viewport = this.viewer.getPageView(pageNumber - 1).viewport;
    return {
      boundingRect: viewportToScaled(boundingRect, viewport),
      rects: (rects || []).map((rect) => viewportToScaled(rect, viewport)),
      pageNumber
    };
  }
  screenshot(position, pageNumber) {
    const canvas = this.viewer.getPageView(pageNumber - 1).canvas;
    return get_area_as_png_default(canvas, position);
  }
  setTip(position, inner) {
    this.setState({
      tipPosition: position,
      tipChildren: inner
    });
  }
  toggleTextSelection(flag) {
    this.viewer.viewer.classList.toggle("PdfHighlighter--disable-selection", flag);
  }
  render() {
    const { onSelectionFinished, enableAreaSelection } = this.props;
    return import_react4.default.createElement(
      "div",
      { onPointerDown: this.onMouseDown },
      import_react4.default.createElement(
        "div",
        { ref: this.containerNodeRef, className: "PdfHighlighter", onContextMenu: (e) => e.preventDefault() },
        import_react4.default.createElement("div", { className: "pdfViewer" }),
        this.renderTip(),
        typeof enableAreaSelection === "function" ? import_react4.default.createElement(MouseSelection_default, { onDragStart: () => this.toggleTextSelection(true), onDragEnd: () => this.toggleTextSelection(false), onChange: (isVisible) => this.setState({ isAreaSelectionInProgress: isVisible }), shouldStart: (event) => enableAreaSelection(event) && isHTMLElement(event.target) && Boolean(asElement(event.target).closest(".page")), onSelection: (startTarget, boundingRect, resetSelection) => {
          const page = getPageFromElement(startTarget);
          if (!page) {
            return;
          }
          const pageBoundingRect = Object.assign(Object.assign({}, boundingRect), { top: boundingRect.top - page.node.offsetTop, left: boundingRect.left - page.node.offsetLeft, pageNumber: page.number });
          const viewportPosition = {
            boundingRect: pageBoundingRect,
            rects: [],
            pageNumber: page.number
          };
          const scaledPosition = this.viewportPositionToScaled(viewportPosition);
          const image = this.screenshot(pageBoundingRect, pageBoundingRect.pageNumber);
          this.setTip(viewportPosition, onSelectionFinished(scaledPosition, { image }, () => this.hideTipAndSelection(), () => {
            console.log("setting ghost highlight", scaledPosition);
            this.setState({
              ghostHighlight: {
                position: scaledPosition,
                content: { image }
              }
            }, () => {
              resetSelection();
              this.renderHighlightLayers();
            });
          }));
        } }) : null
      )
    );
  }
  renderHighlightLayers() {
    const { pdfDocument } = this.props;
    for (let pageNumber = 1; pageNumber <= pdfDocument.numPages; pageNumber++) {
      const highlightRoot = this.highlightRoots[pageNumber];
      if (highlightRoot && highlightRoot.container.isConnected) {
        this.renderHighlightLayer(highlightRoot.reactRoot, pageNumber);
      } else {
        const highlightLayer = this.findOrCreateHighlightLayer(pageNumber);
        if (highlightLayer) {
          const reactRoot = (0, import_client.createRoot)(highlightLayer);
          this.highlightRoots[pageNumber] = {
            reactRoot,
            container: highlightLayer
          };
          this.renderHighlightLayer(reactRoot, pageNumber);
        }
      }
    }
  }
  renderHighlightLayer(root, pageNumber) {
    const { highlightTransform, highlights } = this.props;
    const { tip, scrolledToHighlightId } = this.state;
    root.render(import_react4.default.createElement(HighlightLayer, { highlightsByPage: this.groupHighlightsByPage(highlights), pageNumber: pageNumber.toString(), scrolledToHighlightId, highlightTransform, tip, scaledPositionToViewport: this.scaledPositionToViewport.bind(this), hideTipAndSelection: this.hideTipAndSelection.bind(this), viewer: this.viewer, screenshot: this.screenshot.bind(this), showTip: this.showTip.bind(this), setState: this.setState.bind(this) }));
  }
};
PdfHighlighter.defaultProps = {
  pdfScaleValue: "auto"
};

// node_modules/react-pdf-highlighter/dist/esm/components/Tip.js
var import_react5 = __toESM(require_react());
import "C:/projects/pipeshub-v2/pipeshub-ai/standalone-frontend/node_modules/react-pdf-highlighter/dist/esm/style/Tip.css";
var Tip = class extends import_react5.Component {
  constructor() {
    super(...arguments);
    this.state = {
      compact: true,
      text: "",
      emoji: ""
    };
  }
  // for TipContainer
  componentDidUpdate(nextProps, nextState) {
    const { onUpdate } = this.props;
    if (onUpdate && this.state.compact !== nextState.compact) {
      onUpdate();
    }
  }
  render() {
    const { onConfirm, onOpen } = this.props;
    const { compact, text, emoji } = this.state;
    return import_react5.default.createElement("div", { className: "Tip" }, compact ? import_react5.default.createElement("div", { className: "Tip__compact", onClick: () => {
      onOpen();
      this.setState({ compact: false });
    } }, "Add highlight") : import_react5.default.createElement(
      "form",
      { className: "Tip__card", onSubmit: (event) => {
        event.preventDefault();
        onConfirm({ text, emoji });
      } },
      import_react5.default.createElement(
        "div",
        null,
        import_react5.default.createElement("textarea", { placeholder: "Your comment", autoFocus: true, value: text, onChange: (event) => this.setState({ text: event.target.value }), ref: (node) => {
          if (node) {
            node.focus();
          }
        } }),
        import_react5.default.createElement("div", null, ["💩", "😱", "😍", "🔥", "😳", "⚠️"].map((_emoji) => import_react5.default.createElement(
          "label",
          { key: _emoji },
          import_react5.default.createElement("input", { checked: emoji === _emoji, type: "radio", name: "emoji", value: _emoji, onChange: (event) => this.setState({ emoji: event.target.value }) }),
          _emoji
        )))
      ),
      import_react5.default.createElement(
        "div",
        null,
        import_react5.default.createElement("input", { type: "submit", value: "Save" })
      )
    ));
  }
};

// node_modules/react-pdf-highlighter/dist/esm/components/Highlight.js
var import_react6 = __toESM(require_react());
import "C:/projects/pipeshub-v2/pipeshub-ai/standalone-frontend/node_modules/react-pdf-highlighter/dist/esm/style/Highlight.css";
var Highlight = class extends import_react6.Component {
  render() {
    const { position, onClick, onMouseOver, onMouseOut, comment, isScrolledTo } = this.props;
    const { rects, boundingRect } = position;
    return import_react6.default.createElement(
      "div",
      { className: `Highlight ${isScrolledTo ? "Highlight--scrolledTo" : ""}` },
      comment ? import_react6.default.createElement("div", { className: "Highlight__emoji", style: {
        left: 20,
        top: boundingRect.top
      } }, comment.emoji) : null,
      import_react6.default.createElement("div", { className: "Highlight__parts" }, rects.map((rect, index) => import_react6.default.createElement("div", { onMouseOver, onMouseOut, onClick, key: index, style: rect, className: `Highlight__part` })))
    );
  }
};

// node_modules/react-pdf-highlighter/dist/esm/components/Popup.js
var import_react8 = __toESM(require_react());

// node_modules/react-pdf-highlighter/dist/esm/components/MouseMonitor.js
var import_react7 = __toESM(require_react());
var __rest2 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var MouseMonitor = class extends import_react7.Component {
  constructor() {
    super(...arguments);
    this.container = null;
    this.unsubscribe = () => {
    };
    this.onMouseMove = (event) => {
      if (!this.container) {
        return;
      }
      const { onMoveAway, paddingX, paddingY } = this.props;
      const { clientX, clientY } = event;
      const { left, top, width, height } = this.container.getBoundingClientRect();
      const inBoundsX = clientX > left - paddingX && clientX < left + width + paddingX;
      const inBoundsY = clientY > top - paddingY && clientY < top + height + paddingY;
      const isNear = inBoundsX && inBoundsY;
      if (!isNear) {
        onMoveAway();
      }
    };
    this.attachRef = (ref) => {
      this.container = ref;
      this.unsubscribe();
      if (ref) {
        const { ownerDocument: doc } = ref;
        doc.addEventListener("mousemove", this.onMouseMove);
        this.unsubscribe = () => {
          doc.removeEventListener("mousemove", this.onMouseMove);
        };
      }
    };
  }
  render() {
    const _a = this.props, { onMoveAway, paddingX, paddingY, children } = _a, restProps = __rest2(_a, ["onMoveAway", "paddingX", "paddingY", "children"]);
    return import_react7.default.createElement("div", { ref: this.attachRef }, import_react7.default.cloneElement(children, restProps));
  }
};
var MouseMonitor_default = MouseMonitor;

// node_modules/react-pdf-highlighter/dist/esm/components/Popup.js
var Popup = class extends import_react8.Component {
  constructor() {
    super(...arguments);
    this.state = {
      mouseIn: false
    };
  }
  render() {
    const { onMouseOver, popupContent, onMouseOut } = this.props;
    return import_react8.default.createElement("div", { onMouseOver: () => {
      this.setState({ mouseIn: true });
      onMouseOver(import_react8.default.createElement(MouseMonitor_default, { onMoveAway: () => {
        if (this.state.mouseIn) {
          return;
        }
        onMouseOut();
      }, paddingX: 60, paddingY: 30, children: popupContent }));
    }, onMouseOut: () => {
      this.setState({ mouseIn: false });
    } }, this.props.children);
  }
};

// node_modules/react-pdf-highlighter/dist/esm/components/AreaHighlight.js
var import_react10 = __toESM(require_react());

// node_modules/react-rnd/lib/index.js
var import_react9 = __toESM(require_react());
var import_react_draggable = __toESM(require_cjs());

// node_modules/re-resizable/lib/index.js
var React10 = __toESM(require_react());
var import_react_dom = __toESM(require_react_dom());

// node_modules/re-resizable/lib/resizer.js
var React9 = __toESM(require_react());
var __extends = /* @__PURE__ */ function() {
  var extendStatics2 = function(d, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
    };
    return extendStatics2(d, b);
  };
  return function(d, b) {
    extendStatics2(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __assign = function() {
  __assign = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var rowSizeBase = {
  width: "100%",
  height: "10px",
  top: "0px",
  left: "0px",
  cursor: "row-resize"
};
var colSizeBase = {
  width: "10px",
  height: "100%",
  top: "0px",
  left: "0px",
  cursor: "col-resize"
};
var edgeBase = {
  width: "20px",
  height: "20px",
  position: "absolute"
};
var styles = {
  top: __assign(__assign({}, rowSizeBase), { top: "-5px" }),
  right: __assign(__assign({}, colSizeBase), { left: void 0, right: "-5px" }),
  bottom: __assign(__assign({}, rowSizeBase), { top: void 0, bottom: "-5px" }),
  left: __assign(__assign({}, colSizeBase), { left: "-5px" }),
  topRight: __assign(__assign({}, edgeBase), { right: "-10px", top: "-10px", cursor: "ne-resize" }),
  bottomRight: __assign(__assign({}, edgeBase), { right: "-10px", bottom: "-10px", cursor: "se-resize" }),
  bottomLeft: __assign(__assign({}, edgeBase), { left: "-10px", bottom: "-10px", cursor: "sw-resize" }),
  topLeft: __assign(__assign({}, edgeBase), { left: "-10px", top: "-10px", cursor: "nw-resize" })
};
var Resizer = (
  /** @class */
  function(_super) {
    __extends(Resizer2, _super);
    function Resizer2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.onMouseDown = function(e) {
        _this.props.onResizeStart(e, _this.props.direction);
      };
      _this.onTouchStart = function(e) {
        _this.props.onResizeStart(e, _this.props.direction);
      };
      return _this;
    }
    Resizer2.prototype.render = function() {
      return React9.createElement("div", { className: this.props.className || "", style: __assign(__assign({ position: "absolute", userSelect: "none" }, styles[this.props.direction]), this.props.replaceStyles || {}), onMouseDown: this.onMouseDown, onTouchStart: this.onTouchStart }, this.props.children);
    };
    return Resizer2;
  }(React9.PureComponent)
);

// node_modules/re-resizable/lib/index.js
var __extends2 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
    };
    return extendStatics2(d, b);
  };
  return function(d, b) {
    extendStatics2(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __assign2 = function() {
  __assign2 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign2.apply(this, arguments);
};
var DEFAULT_SIZE = {
  width: "auto",
  height: "auto"
};
var clamp2 = function(n, min, max) {
  return Math.max(Math.min(n, max), min);
};
var snap = function(n, size, gridGap) {
  var v = Math.round(n / size);
  return v * size + gridGap * (v - 1);
};
var hasDirection = function(dir, target) {
  return new RegExp(dir, "i").test(target);
};
var isTouchEvent = function(event) {
  return Boolean(event.touches && event.touches.length);
};
var isMouseEvent = function(event) {
  return Boolean((event.clientX || event.clientX === 0) && (event.clientY || event.clientY === 0));
};
var findClosestSnap = function(n, snapArray, snapGap) {
  if (snapGap === void 0) {
    snapGap = 0;
  }
  var closestGapIndex = snapArray.reduce(function(prev, curr, index) {
    return Math.abs(curr - n) < Math.abs(snapArray[prev] - n) ? index : prev;
  }, 0);
  var gap = Math.abs(snapArray[closestGapIndex] - n);
  return snapGap === 0 || gap < snapGap ? snapArray[closestGapIndex] : n;
};
var getStringSize = function(n) {
  n = n.toString();
  if (n === "auto") {
    return n;
  }
  if (n.endsWith("px")) {
    return n;
  }
  if (n.endsWith("%")) {
    return n;
  }
  if (n.endsWith("vh")) {
    return n;
  }
  if (n.endsWith("vw")) {
    return n;
  }
  if (n.endsWith("vmax")) {
    return n;
  }
  if (n.endsWith("vmin")) {
    return n;
  }
  return n + "px";
};
var getPixelSize = function(size, parentSize, innerWidth, innerHeight) {
  if (size && typeof size === "string") {
    if (size.endsWith("px")) {
      return Number(size.replace("px", ""));
    }
    if (size.endsWith("%")) {
      var ratio = Number(size.replace("%", "")) / 100;
      return parentSize * ratio;
    }
    if (size.endsWith("vw")) {
      var ratio = Number(size.replace("vw", "")) / 100;
      return innerWidth * ratio;
    }
    if (size.endsWith("vh")) {
      var ratio = Number(size.replace("vh", "")) / 100;
      return innerHeight * ratio;
    }
  }
  return size;
};
var calculateNewMax = function(parentSize, innerWidth, innerHeight, maxWidth, maxHeight, minWidth, minHeight) {
  maxWidth = getPixelSize(maxWidth, parentSize.width, innerWidth, innerHeight);
  maxHeight = getPixelSize(maxHeight, parentSize.height, innerWidth, innerHeight);
  minWidth = getPixelSize(minWidth, parentSize.width, innerWidth, innerHeight);
  minHeight = getPixelSize(minHeight, parentSize.height, innerWidth, innerHeight);
  return {
    maxWidth: typeof maxWidth === "undefined" ? void 0 : Number(maxWidth),
    maxHeight: typeof maxHeight === "undefined" ? void 0 : Number(maxHeight),
    minWidth: typeof minWidth === "undefined" ? void 0 : Number(minWidth),
    minHeight: typeof minHeight === "undefined" ? void 0 : Number(minHeight)
  };
};
var normalizeToPair = function(val) {
  return Array.isArray(val) ? val : [val, val];
};
var definedProps = [
  "as",
  "ref",
  "style",
  "className",
  "grid",
  "gridGap",
  "snap",
  "bounds",
  "boundsByDirection",
  "size",
  "defaultSize",
  "minWidth",
  "minHeight",
  "maxWidth",
  "maxHeight",
  "lockAspectRatio",
  "lockAspectRatioExtraWidth",
  "lockAspectRatioExtraHeight",
  "enable",
  "handleStyles",
  "handleClasses",
  "handleWrapperStyle",
  "handleWrapperClass",
  "children",
  "onResizeStart",
  "onResize",
  "onResizeStop",
  "handleComponent",
  "scale",
  "resizeRatio",
  "snapGap"
];
var baseClassName = "__resizable_base__";
var Resizable = (
  /** @class */
  function(_super) {
    __extends2(Resizable2, _super);
    function Resizable2(props) {
      var _a, _b, _c, _d;
      var _this = _super.call(this, props) || this;
      _this.ratio = 1;
      _this.resizable = null;
      _this.parentLeft = 0;
      _this.parentTop = 0;
      _this.resizableLeft = 0;
      _this.resizableRight = 0;
      _this.resizableTop = 0;
      _this.resizableBottom = 0;
      _this.targetLeft = 0;
      _this.targetTop = 0;
      _this.appendBase = function() {
        if (!_this.resizable || !_this.window) {
          return null;
        }
        var parent = _this.parentNode;
        if (!parent) {
          return null;
        }
        var element = _this.window.document.createElement("div");
        element.style.width = "100%";
        element.style.height = "100%";
        element.style.position = "absolute";
        element.style.transform = "scale(0, 0)";
        element.style.left = "0";
        element.style.flex = "0 0 100%";
        if (element.classList) {
          element.classList.add(baseClassName);
        } else {
          element.className += baseClassName;
        }
        parent.appendChild(element);
        return element;
      };
      _this.removeBase = function(base) {
        var parent = _this.parentNode;
        if (!parent) {
          return;
        }
        parent.removeChild(base);
      };
      _this.state = {
        isResizing: false,
        width: (_b = (_a = _this.propsSize) === null || _a === void 0 ? void 0 : _a.width) !== null && _b !== void 0 ? _b : "auto",
        height: (_d = (_c = _this.propsSize) === null || _c === void 0 ? void 0 : _c.height) !== null && _d !== void 0 ? _d : "auto",
        direction: "right",
        original: {
          x: 0,
          y: 0,
          width: 0,
          height: 0
        },
        backgroundStyle: {
          height: "100%",
          width: "100%",
          backgroundColor: "rgba(0,0,0,0)",
          cursor: "auto",
          opacity: 0,
          position: "fixed",
          zIndex: 9999,
          top: "0",
          left: "0",
          bottom: "0",
          right: "0"
        },
        flexBasis: void 0
      };
      _this.onResizeStart = _this.onResizeStart.bind(_this);
      _this.onMouseMove = _this.onMouseMove.bind(_this);
      _this.onMouseUp = _this.onMouseUp.bind(_this);
      return _this;
    }
    Object.defineProperty(Resizable2.prototype, "parentNode", {
      get: function() {
        if (!this.resizable) {
          return null;
        }
        return this.resizable.parentNode;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Resizable2.prototype, "window", {
      get: function() {
        if (!this.resizable) {
          return null;
        }
        if (!this.resizable.ownerDocument) {
          return null;
        }
        return this.resizable.ownerDocument.defaultView;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Resizable2.prototype, "propsSize", {
      get: function() {
        return this.props.size || this.props.defaultSize || DEFAULT_SIZE;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Resizable2.prototype, "size", {
      get: function() {
        var width = 0;
        var height = 0;
        if (this.resizable && this.window) {
          var orgWidth = this.resizable.offsetWidth;
          var orgHeight = this.resizable.offsetHeight;
          var orgPosition = this.resizable.style.position;
          if (orgPosition !== "relative") {
            this.resizable.style.position = "relative";
          }
          width = this.resizable.style.width !== "auto" ? this.resizable.offsetWidth : orgWidth;
          height = this.resizable.style.height !== "auto" ? this.resizable.offsetHeight : orgHeight;
          this.resizable.style.position = orgPosition;
        }
        return { width, height };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Resizable2.prototype, "sizeStyle", {
      get: function() {
        var _this = this;
        var size = this.props.size;
        var getSize = function(key) {
          var _a;
          if (typeof _this.state[key] === "undefined" || _this.state[key] === "auto") {
            return "auto";
          }
          if (_this.propsSize && _this.propsSize[key] && ((_a = _this.propsSize[key]) === null || _a === void 0 ? void 0 : _a.toString().endsWith("%"))) {
            if (_this.state[key].toString().endsWith("%")) {
              return _this.state[key].toString();
            }
            var parentSize = _this.getParentSize();
            var value = Number(_this.state[key].toString().replace("px", ""));
            var percent = value / parentSize[key] * 100;
            return percent + "%";
          }
          return getStringSize(_this.state[key]);
        };
        var width = size && typeof size.width !== "undefined" && !this.state.isResizing ? getStringSize(size.width) : getSize("width");
        var height = size && typeof size.height !== "undefined" && !this.state.isResizing ? getStringSize(size.height) : getSize("height");
        return { width, height };
      },
      enumerable: false,
      configurable: true
    });
    Resizable2.prototype.getParentSize = function() {
      if (!this.parentNode) {
        if (!this.window) {
          return { width: 0, height: 0 };
        }
        return { width: this.window.innerWidth, height: this.window.innerHeight };
      }
      var base = this.appendBase();
      if (!base) {
        return { width: 0, height: 0 };
      }
      var wrapChanged = false;
      var wrap = this.parentNode.style.flexWrap;
      if (wrap !== "wrap") {
        wrapChanged = true;
        this.parentNode.style.flexWrap = "wrap";
      }
      base.style.position = "relative";
      base.style.minWidth = "100%";
      base.style.minHeight = "100%";
      var size = {
        width: base.offsetWidth,
        height: base.offsetHeight
      };
      if (wrapChanged) {
        this.parentNode.style.flexWrap = wrap;
      }
      this.removeBase(base);
      return size;
    };
    Resizable2.prototype.bindEvents = function() {
      if (this.window) {
        this.window.addEventListener("mouseup", this.onMouseUp);
        this.window.addEventListener("mousemove", this.onMouseMove);
        this.window.addEventListener("mouseleave", this.onMouseUp);
        this.window.addEventListener("touchmove", this.onMouseMove, {
          capture: true,
          passive: false
        });
        this.window.addEventListener("touchend", this.onMouseUp);
      }
    };
    Resizable2.prototype.unbindEvents = function() {
      if (this.window) {
        this.window.removeEventListener("mouseup", this.onMouseUp);
        this.window.removeEventListener("mousemove", this.onMouseMove);
        this.window.removeEventListener("mouseleave", this.onMouseUp);
        this.window.removeEventListener("touchmove", this.onMouseMove, true);
        this.window.removeEventListener("touchend", this.onMouseUp);
      }
    };
    Resizable2.prototype.componentDidMount = function() {
      if (!this.resizable || !this.window) {
        return;
      }
      var computedStyle = this.window.getComputedStyle(this.resizable);
      this.setState({
        width: this.state.width || this.size.width,
        height: this.state.height || this.size.height,
        flexBasis: computedStyle.flexBasis !== "auto" ? computedStyle.flexBasis : void 0
      });
    };
    Resizable2.prototype.componentWillUnmount = function() {
      if (this.window) {
        this.unbindEvents();
      }
    };
    Resizable2.prototype.createSizeForCssProperty = function(newSize, kind) {
      var propsSize = this.propsSize && this.propsSize[kind];
      return this.state[kind] === "auto" && this.state.original[kind] === newSize && (typeof propsSize === "undefined" || propsSize === "auto") ? "auto" : newSize;
    };
    Resizable2.prototype.calculateNewMaxFromBoundary = function(maxWidth, maxHeight) {
      var boundsByDirection = this.props.boundsByDirection;
      var direction = this.state.direction;
      var widthByDirection = boundsByDirection && hasDirection("left", direction);
      var heightByDirection = boundsByDirection && hasDirection("top", direction);
      var boundWidth;
      var boundHeight;
      if (this.props.bounds === "parent") {
        var parent_1 = this.parentNode;
        if (parent_1) {
          boundWidth = widthByDirection ? this.resizableRight - this.parentLeft : parent_1.offsetWidth + (this.parentLeft - this.resizableLeft);
          boundHeight = heightByDirection ? this.resizableBottom - this.parentTop : parent_1.offsetHeight + (this.parentTop - this.resizableTop);
        }
      } else if (this.props.bounds === "window") {
        if (this.window) {
          boundWidth = widthByDirection ? this.resizableRight : this.window.innerWidth - this.resizableLeft;
          boundHeight = heightByDirection ? this.resizableBottom : this.window.innerHeight - this.resizableTop;
        }
      } else if (this.props.bounds) {
        boundWidth = widthByDirection ? this.resizableRight - this.targetLeft : this.props.bounds.offsetWidth + (this.targetLeft - this.resizableLeft);
        boundHeight = heightByDirection ? this.resizableBottom - this.targetTop : this.props.bounds.offsetHeight + (this.targetTop - this.resizableTop);
      }
      if (boundWidth && Number.isFinite(boundWidth)) {
        maxWidth = maxWidth && maxWidth < boundWidth ? maxWidth : boundWidth;
      }
      if (boundHeight && Number.isFinite(boundHeight)) {
        maxHeight = maxHeight && maxHeight < boundHeight ? maxHeight : boundHeight;
      }
      return { maxWidth, maxHeight };
    };
    Resizable2.prototype.calculateNewSizeFromDirection = function(clientX, clientY) {
      var scale = this.props.scale || 1;
      var _a = normalizeToPair(this.props.resizeRatio || 1), resizeRatioX = _a[0], resizeRatioY = _a[1];
      var _b = this.state, direction = _b.direction, original = _b.original;
      var _c = this.props, lockAspectRatio = _c.lockAspectRatio, lockAspectRatioExtraHeight = _c.lockAspectRatioExtraHeight, lockAspectRatioExtraWidth = _c.lockAspectRatioExtraWidth;
      var newWidth = original.width;
      var newHeight = original.height;
      var extraHeight = lockAspectRatioExtraHeight || 0;
      var extraWidth = lockAspectRatioExtraWidth || 0;
      if (hasDirection("right", direction)) {
        newWidth = original.width + (clientX - original.x) * resizeRatioX / scale;
        if (lockAspectRatio) {
          newHeight = (newWidth - extraWidth) / this.ratio + extraHeight;
        }
      }
      if (hasDirection("left", direction)) {
        newWidth = original.width - (clientX - original.x) * resizeRatioX / scale;
        if (lockAspectRatio) {
          newHeight = (newWidth - extraWidth) / this.ratio + extraHeight;
        }
      }
      if (hasDirection("bottom", direction)) {
        newHeight = original.height + (clientY - original.y) * resizeRatioY / scale;
        if (lockAspectRatio) {
          newWidth = (newHeight - extraHeight) * this.ratio + extraWidth;
        }
      }
      if (hasDirection("top", direction)) {
        newHeight = original.height - (clientY - original.y) * resizeRatioY / scale;
        if (lockAspectRatio) {
          newWidth = (newHeight - extraHeight) * this.ratio + extraWidth;
        }
      }
      return { newWidth, newHeight };
    };
    Resizable2.prototype.calculateNewSizeFromAspectRatio = function(newWidth, newHeight, max, min) {
      var _a = this.props, lockAspectRatio = _a.lockAspectRatio, lockAspectRatioExtraHeight = _a.lockAspectRatioExtraHeight, lockAspectRatioExtraWidth = _a.lockAspectRatioExtraWidth;
      var computedMinWidth = typeof min.width === "undefined" ? 10 : min.width;
      var computedMaxWidth = typeof max.width === "undefined" || max.width < 0 ? newWidth : max.width;
      var computedMinHeight = typeof min.height === "undefined" ? 10 : min.height;
      var computedMaxHeight = typeof max.height === "undefined" || max.height < 0 ? newHeight : max.height;
      var extraHeight = lockAspectRatioExtraHeight || 0;
      var extraWidth = lockAspectRatioExtraWidth || 0;
      if (lockAspectRatio) {
        var extraMinWidth = (computedMinHeight - extraHeight) * this.ratio + extraWidth;
        var extraMaxWidth = (computedMaxHeight - extraHeight) * this.ratio + extraWidth;
        var extraMinHeight = (computedMinWidth - extraWidth) / this.ratio + extraHeight;
        var extraMaxHeight = (computedMaxWidth - extraWidth) / this.ratio + extraHeight;
        var lockedMinWidth = Math.max(computedMinWidth, extraMinWidth);
        var lockedMaxWidth = Math.min(computedMaxWidth, extraMaxWidth);
        var lockedMinHeight = Math.max(computedMinHeight, extraMinHeight);
        var lockedMaxHeight = Math.min(computedMaxHeight, extraMaxHeight);
        newWidth = clamp2(newWidth, lockedMinWidth, lockedMaxWidth);
        newHeight = clamp2(newHeight, lockedMinHeight, lockedMaxHeight);
      } else {
        newWidth = clamp2(newWidth, computedMinWidth, computedMaxWidth);
        newHeight = clamp2(newHeight, computedMinHeight, computedMaxHeight);
      }
      return { newWidth, newHeight };
    };
    Resizable2.prototype.setBoundingClientRect = function() {
      var adjustedScale = 1 / (this.props.scale || 1);
      if (this.props.bounds === "parent") {
        var parent_2 = this.parentNode;
        if (parent_2) {
          var parentRect = parent_2.getBoundingClientRect();
          this.parentLeft = parentRect.left * adjustedScale;
          this.parentTop = parentRect.top * adjustedScale;
        }
      }
      if (this.props.bounds && typeof this.props.bounds !== "string") {
        var targetRect = this.props.bounds.getBoundingClientRect();
        this.targetLeft = targetRect.left * adjustedScale;
        this.targetTop = targetRect.top * adjustedScale;
      }
      if (this.resizable) {
        var _a = this.resizable.getBoundingClientRect(), left = _a.left, top_1 = _a.top, right = _a.right, bottom = _a.bottom;
        this.resizableLeft = left * adjustedScale;
        this.resizableRight = right * adjustedScale;
        this.resizableTop = top_1 * adjustedScale;
        this.resizableBottom = bottom * adjustedScale;
      }
    };
    Resizable2.prototype.onResizeStart = function(event, direction) {
      if (!this.resizable || !this.window) {
        return;
      }
      var clientX = 0;
      var clientY = 0;
      if (event.nativeEvent && isMouseEvent(event.nativeEvent)) {
        clientX = event.nativeEvent.clientX;
        clientY = event.nativeEvent.clientY;
      } else if (event.nativeEvent && isTouchEvent(event.nativeEvent)) {
        clientX = event.nativeEvent.touches[0].clientX;
        clientY = event.nativeEvent.touches[0].clientY;
      }
      if (this.props.onResizeStart) {
        if (this.resizable) {
          var startResize = this.props.onResizeStart(event, direction, this.resizable);
          if (startResize === false) {
            return;
          }
        }
      }
      if (this.props.size) {
        if (typeof this.props.size.height !== "undefined" && this.props.size.height !== this.state.height) {
          this.setState({ height: this.props.size.height });
        }
        if (typeof this.props.size.width !== "undefined" && this.props.size.width !== this.state.width) {
          this.setState({ width: this.props.size.width });
        }
      }
      this.ratio = typeof this.props.lockAspectRatio === "number" ? this.props.lockAspectRatio : this.size.width / this.size.height;
      var flexBasis;
      var computedStyle = this.window.getComputedStyle(this.resizable);
      if (computedStyle.flexBasis !== "auto") {
        var parent_3 = this.parentNode;
        if (parent_3) {
          var dir = this.window.getComputedStyle(parent_3).flexDirection;
          this.flexDir = dir.startsWith("row") ? "row" : "column";
          flexBasis = computedStyle.flexBasis;
        }
      }
      this.setBoundingClientRect();
      this.bindEvents();
      var state = {
        original: {
          x: clientX,
          y: clientY,
          width: this.size.width,
          height: this.size.height
        },
        isResizing: true,
        backgroundStyle: __assign2(__assign2({}, this.state.backgroundStyle), { cursor: this.window.getComputedStyle(event.target).cursor || "auto" }),
        direction,
        flexBasis
      };
      this.setState(state);
    };
    Resizable2.prototype.onMouseMove = function(event) {
      var _this = this;
      if (!this.state.isResizing || !this.resizable || !this.window) {
        return;
      }
      if (this.window.TouchEvent && isTouchEvent(event)) {
        try {
          event.preventDefault();
          event.stopPropagation();
        } catch (e) {
        }
      }
      var _a = this.props, maxWidth = _a.maxWidth, maxHeight = _a.maxHeight, minWidth = _a.minWidth, minHeight = _a.minHeight;
      var clientX = isTouchEvent(event) ? event.touches[0].clientX : event.clientX;
      var clientY = isTouchEvent(event) ? event.touches[0].clientY : event.clientY;
      var _b = this.state, direction = _b.direction, original = _b.original, width = _b.width, height = _b.height;
      var parentSize = this.getParentSize();
      var max = calculateNewMax(parentSize, this.window.innerWidth, this.window.innerHeight, maxWidth, maxHeight, minWidth, minHeight);
      maxWidth = max.maxWidth;
      maxHeight = max.maxHeight;
      minWidth = max.minWidth;
      minHeight = max.minHeight;
      var _c = this.calculateNewSizeFromDirection(clientX, clientY), newHeight = _c.newHeight, newWidth = _c.newWidth;
      var boundaryMax = this.calculateNewMaxFromBoundary(maxWidth, maxHeight);
      if (this.props.snap && this.props.snap.x) {
        newWidth = findClosestSnap(newWidth, this.props.snap.x, this.props.snapGap);
      }
      if (this.props.snap && this.props.snap.y) {
        newHeight = findClosestSnap(newHeight, this.props.snap.y, this.props.snapGap);
      }
      var newSize = this.calculateNewSizeFromAspectRatio(newWidth, newHeight, { width: boundaryMax.maxWidth, height: boundaryMax.maxHeight }, { width: minWidth, height: minHeight });
      newWidth = newSize.newWidth;
      newHeight = newSize.newHeight;
      if (this.props.grid) {
        var newGridWidth = snap(newWidth, this.props.grid[0], this.props.gridGap ? this.props.gridGap[0] : 0);
        var newGridHeight = snap(newHeight, this.props.grid[1], this.props.gridGap ? this.props.gridGap[1] : 0);
        var gap = this.props.snapGap || 0;
        var w = gap === 0 || Math.abs(newGridWidth - newWidth) <= gap ? newGridWidth : newWidth;
        var h = gap === 0 || Math.abs(newGridHeight - newHeight) <= gap ? newGridHeight : newHeight;
        newWidth = w;
        newHeight = h;
      }
      var delta = {
        width: newWidth - original.width,
        height: newHeight - original.height
      };
      if (width && typeof width === "string") {
        if (width.endsWith("%")) {
          var percent = newWidth / parentSize.width * 100;
          newWidth = percent + "%";
        } else if (width.endsWith("vw")) {
          var vw = newWidth / this.window.innerWidth * 100;
          newWidth = vw + "vw";
        } else if (width.endsWith("vh")) {
          var vh = newWidth / this.window.innerHeight * 100;
          newWidth = vh + "vh";
        }
      }
      if (height && typeof height === "string") {
        if (height.endsWith("%")) {
          var percent = newHeight / parentSize.height * 100;
          newHeight = percent + "%";
        } else if (height.endsWith("vw")) {
          var vw = newHeight / this.window.innerWidth * 100;
          newHeight = vw + "vw";
        } else if (height.endsWith("vh")) {
          var vh = newHeight / this.window.innerHeight * 100;
          newHeight = vh + "vh";
        }
      }
      var newState = {
        width: this.createSizeForCssProperty(newWidth, "width"),
        height: this.createSizeForCssProperty(newHeight, "height")
      };
      if (this.flexDir === "row") {
        newState.flexBasis = newState.width;
      } else if (this.flexDir === "column") {
        newState.flexBasis = newState.height;
      }
      var widthChanged = this.state.width !== newState.width;
      var heightChanged = this.state.height !== newState.height;
      var flexBaseChanged = this.state.flexBasis !== newState.flexBasis;
      var changed = widthChanged || heightChanged || flexBaseChanged;
      if (changed) {
        (0, import_react_dom.flushSync)(function() {
          _this.setState(newState);
        });
      }
      if (this.props.onResize) {
        if (changed) {
          this.props.onResize(event, direction, this.resizable, delta);
        }
      }
    };
    Resizable2.prototype.onMouseUp = function(event) {
      var _a, _b;
      var _c = this.state, isResizing = _c.isResizing, direction = _c.direction, original = _c.original;
      if (!isResizing || !this.resizable) {
        return;
      }
      var delta = {
        width: this.size.width - original.width,
        height: this.size.height - original.height
      };
      if (this.props.onResizeStop) {
        this.props.onResizeStop(event, direction, this.resizable, delta);
      }
      if (this.props.size) {
        this.setState({ width: (_a = this.props.size.width) !== null && _a !== void 0 ? _a : "auto", height: (_b = this.props.size.height) !== null && _b !== void 0 ? _b : "auto" });
      }
      this.unbindEvents();
      this.setState({
        isResizing: false,
        backgroundStyle: __assign2(__assign2({}, this.state.backgroundStyle), { cursor: "auto" })
      });
    };
    Resizable2.prototype.updateSize = function(size) {
      var _a, _b;
      this.setState({ width: (_a = size.width) !== null && _a !== void 0 ? _a : "auto", height: (_b = size.height) !== null && _b !== void 0 ? _b : "auto" });
    };
    Resizable2.prototype.renderResizer = function() {
      var _this = this;
      var _a = this.props, enable = _a.enable, handleStyles = _a.handleStyles, handleClasses = _a.handleClasses, handleWrapperStyle = _a.handleWrapperStyle, handleWrapperClass = _a.handleWrapperClass, handleComponent = _a.handleComponent;
      if (!enable) {
        return null;
      }
      var resizers = Object.keys(enable).map(function(dir) {
        if (enable[dir] !== false) {
          return React10.createElement(Resizer, { key: dir, direction: dir, onResizeStart: _this.onResizeStart, replaceStyles: handleStyles && handleStyles[dir], className: handleClasses && handleClasses[dir] }, handleComponent && handleComponent[dir] ? handleComponent[dir] : null);
        }
        return null;
      });
      return React10.createElement("div", { className: handleWrapperClass, style: handleWrapperStyle }, resizers);
    };
    Resizable2.prototype.render = function() {
      var _this = this;
      var extendsProps = Object.keys(this.props).reduce(function(acc, key) {
        if (definedProps.indexOf(key) !== -1) {
          return acc;
        }
        acc[key] = _this.props[key];
        return acc;
      }, {});
      var style = __assign2(__assign2(__assign2({ position: "relative", userSelect: this.state.isResizing ? "none" : "auto" }, this.props.style), this.sizeStyle), { maxWidth: this.props.maxWidth, maxHeight: this.props.maxHeight, minWidth: this.props.minWidth, minHeight: this.props.minHeight, boxSizing: "border-box", flexShrink: 0 });
      if (this.state.flexBasis) {
        style.flexBasis = this.state.flexBasis;
      }
      var Wrapper = this.props.as || "div";
      return React10.createElement(
        Wrapper,
        __assign2({ style, className: this.props.className }, extendsProps, {
          // `ref` is after `extendsProps` to ensure this one wins over a version
          // passed in
          ref: function(c) {
            if (c) {
              _this.resizable = c;
            }
          }
        }),
        this.state.isResizing && React10.createElement("div", { style: this.state.backgroundStyle }),
        this.props.children,
        this.renderResizer()
      );
    };
    Resizable2.defaultProps = {
      as: "div",
      onResizeStart: function() {
      },
      onResize: function() {
      },
      onResizeStop: function() {
      },
      enable: {
        top: true,
        right: true,
        bottom: true,
        left: true,
        topRight: true,
        bottomRight: true,
        bottomLeft: true,
        topLeft: true
      },
      style: {},
      grid: [1, 1],
      gridGap: [0, 0],
      lockAspectRatio: false,
      lockAspectRatioExtraWidth: 0,
      lockAspectRatioExtraHeight: 0,
      scale: 1,
      resizeRatio: 1,
      snapGap: 0
    };
    return Resizable2;
  }(React10.PureComponent)
);

// node_modules/react-rnd/lib/index.js
var import_react_dom2 = __toESM(require_react_dom());
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
  };
  return extendStatics(d, b);
};
function __extends3(d, b) {
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign3 = function() {
  __assign3 = Object.assign || function __assign4(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign3.apply(this, arguments);
};
function __rest3(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
var resizableStyle = {
  width: "auto",
  height: "auto",
  display: "inline-block",
  position: "absolute",
  top: 0,
  left: 0
};
var getEnableResizingByFlag = function(flag) {
  return {
    bottom: flag,
    bottomLeft: flag,
    bottomRight: flag,
    left: flag,
    right: flag,
    top: flag,
    topLeft: flag,
    topRight: flag
  };
};
var Rnd = (
  /** @class */
  function(_super) {
    __extends3(Rnd2, _super);
    function Rnd2(props) {
      var _this = _super.call(this, props) || this;
      _this.resizingPosition = { x: 0, y: 0 };
      _this.offsetFromParent = { left: 0, top: 0 };
      _this.resizableElement = { current: null };
      _this.originalPosition = { x: 0, y: 0 };
      _this.state = {
        resizing: false,
        bounds: {
          top: 0,
          right: 0,
          bottom: 0,
          left: 0
        },
        maxWidth: props.maxWidth,
        maxHeight: props.maxHeight
      };
      _this.onResizeStart = _this.onResizeStart.bind(_this);
      _this.onResize = _this.onResize.bind(_this);
      _this.onResizeStop = _this.onResizeStop.bind(_this);
      _this.onDragStart = _this.onDragStart.bind(_this);
      _this.onDrag = _this.onDrag.bind(_this);
      _this.onDragStop = _this.onDragStop.bind(_this);
      _this.getMaxSizesFromProps = _this.getMaxSizesFromProps.bind(_this);
      return _this;
    }
    Rnd2.prototype.componentDidMount = function() {
      this.updateOffsetFromParent();
      var _a = this.offsetFromParent, left = _a.left, top = _a.top;
      var _b = this.getDraggablePosition(), x = _b.x, y = _b.y;
      this.draggable.setState({
        x: x - left,
        y: y - top
      });
      this.forceUpdate();
    };
    Rnd2.prototype.getDraggablePosition = function() {
      var _a = this.draggable.state, x = _a.x, y = _a.y;
      return { x, y };
    };
    Rnd2.prototype.getParent = function() {
      return this.resizable && this.resizable.parentNode;
    };
    Rnd2.prototype.getParentSize = function() {
      return this.resizable.getParentSize();
    };
    Rnd2.prototype.getMaxSizesFromProps = function() {
      var maxWidth = typeof this.props.maxWidth === "undefined" ? Number.MAX_SAFE_INTEGER : this.props.maxWidth;
      var maxHeight = typeof this.props.maxHeight === "undefined" ? Number.MAX_SAFE_INTEGER : this.props.maxHeight;
      return { maxWidth, maxHeight };
    };
    Rnd2.prototype.getSelfElement = function() {
      return this.resizable && this.resizable.resizable;
    };
    Rnd2.prototype.getOffsetHeight = function(boundary) {
      var scale = this.props.scale;
      switch (this.props.bounds) {
        case "window":
          return window.innerHeight / scale;
        case "body":
          return document.body.offsetHeight / scale;
        default:
          return boundary.offsetHeight;
      }
    };
    Rnd2.prototype.getOffsetWidth = function(boundary) {
      var scale = this.props.scale;
      switch (this.props.bounds) {
        case "window":
          return window.innerWidth / scale;
        case "body":
          return document.body.offsetWidth / scale;
        default:
          return boundary.offsetWidth;
      }
    };
    Rnd2.prototype.onDragStart = function(e, data) {
      if (this.props.onDragStart) {
        this.props.onDragStart(e, data);
      }
      var pos = this.getDraggablePosition();
      this.originalPosition = pos;
      if (!this.props.bounds)
        return;
      var parent = this.getParent();
      var scale = this.props.scale;
      var boundary;
      if (this.props.bounds === "parent") {
        boundary = parent;
      } else if (this.props.bounds === "body") {
        var parentRect_1 = parent.getBoundingClientRect();
        var parentLeft_1 = parentRect_1.left;
        var parentTop_1 = parentRect_1.top;
        var bodyRect = document.body.getBoundingClientRect();
        var left_1 = -(parentLeft_1 - parent.offsetLeft * scale - bodyRect.left) / scale;
        var top_1 = -(parentTop_1 - parent.offsetTop * scale - bodyRect.top) / scale;
        var right = (document.body.offsetWidth - this.resizable.size.width * scale) / scale + left_1;
        var bottom = (document.body.offsetHeight - this.resizable.size.height * scale) / scale + top_1;
        return this.setState({ bounds: { top: top_1, right, bottom, left: left_1 } });
      } else if (this.props.bounds === "window") {
        if (!this.resizable)
          return;
        var parentRect_2 = parent.getBoundingClientRect();
        var parentLeft_2 = parentRect_2.left;
        var parentTop_2 = parentRect_2.top;
        var left_2 = -(parentLeft_2 - parent.offsetLeft * scale) / scale;
        var top_2 = -(parentTop_2 - parent.offsetTop * scale) / scale;
        var right = (window.innerWidth - this.resizable.size.width * scale) / scale + left_2;
        var bottom = (window.innerHeight - this.resizable.size.height * scale) / scale + top_2;
        return this.setState({ bounds: { top: top_2, right, bottom, left: left_2 } });
      } else if (typeof this.props.bounds === "string") {
        boundary = document.querySelector(this.props.bounds);
      } else if (this.props.bounds instanceof HTMLElement) {
        boundary = this.props.bounds;
      }
      if (!(boundary instanceof HTMLElement) || !(parent instanceof HTMLElement)) {
        return;
      }
      var boundaryRect = boundary.getBoundingClientRect();
      var boundaryLeft = boundaryRect.left;
      var boundaryTop = boundaryRect.top;
      var parentRect = parent.getBoundingClientRect();
      var parentLeft = parentRect.left;
      var parentTop = parentRect.top;
      var left = (boundaryLeft - parentLeft) / scale;
      var top = boundaryTop - parentTop;
      if (!this.resizable)
        return;
      this.updateOffsetFromParent();
      var offset = this.offsetFromParent;
      this.setState({
        bounds: {
          top: top - offset.top,
          right: left + (boundary.offsetWidth - this.resizable.size.width) - offset.left / scale,
          bottom: top + (boundary.offsetHeight - this.resizable.size.height) - offset.top,
          left: left - offset.left / scale
        }
      });
    };
    Rnd2.prototype.onDrag = function(e, data) {
      if (!this.props.onDrag)
        return;
      var _a = this.offsetFromParent, left = _a.left, top = _a.top;
      if (!this.props.dragAxis || this.props.dragAxis === "both") {
        return this.props.onDrag(e, __assign3(__assign3({}, data), { x: data.x + left, y: data.y + top }));
      } else if (this.props.dragAxis === "x") {
        return this.props.onDrag(e, __assign3(__assign3({}, data), { x: data.x + left, y: this.originalPosition.y + top, deltaY: 0 }));
      } else if (this.props.dragAxis === "y") {
        return this.props.onDrag(e, __assign3(__assign3({}, data), { x: this.originalPosition.x + left, y: data.y + top, deltaX: 0 }));
      }
    };
    Rnd2.prototype.onDragStop = function(e, data) {
      if (!this.props.onDragStop)
        return;
      var _a = this.offsetFromParent, left = _a.left, top = _a.top;
      if (!this.props.dragAxis || this.props.dragAxis === "both") {
        return this.props.onDragStop(e, __assign3(__assign3({}, data), { x: data.x + left, y: data.y + top }));
      } else if (this.props.dragAxis === "x") {
        return this.props.onDragStop(e, __assign3(__assign3({}, data), { x: data.x + left, y: this.originalPosition.y + top, deltaY: 0 }));
      } else if (this.props.dragAxis === "y") {
        return this.props.onDragStop(e, __assign3(__assign3({}, data), { x: this.originalPosition.x + left, y: data.y + top, deltaX: 0 }));
      }
    };
    Rnd2.prototype.onResizeStart = function(e, dir, elementRef) {
      e.stopPropagation();
      this.setState({
        resizing: true
      });
      var scale = this.props.scale;
      var offset = this.offsetFromParent;
      var pos = this.getDraggablePosition();
      this.resizingPosition = { x: pos.x + offset.left, y: pos.y + offset.top };
      this.originalPosition = pos;
      if (this.props.bounds) {
        var parent_1 = this.getParent();
        var boundary = void 0;
        if (this.props.bounds === "parent") {
          boundary = parent_1;
        } else if (this.props.bounds === "body") {
          boundary = document.body;
        } else if (this.props.bounds === "window") {
          boundary = window;
        } else if (typeof this.props.bounds === "string") {
          boundary = document.querySelector(this.props.bounds);
        } else if (this.props.bounds instanceof HTMLElement) {
          boundary = this.props.bounds;
        }
        var self_1 = this.getSelfElement();
        if (self_1 instanceof Element && (boundary instanceof HTMLElement || boundary === window) && parent_1 instanceof HTMLElement) {
          var _a = this.getMaxSizesFromProps(), maxWidth = _a.maxWidth, maxHeight = _a.maxHeight;
          var parentSize = this.getParentSize();
          if (maxWidth && typeof maxWidth === "string") {
            if (maxWidth.endsWith("%")) {
              var ratio = Number(maxWidth.replace("%", "")) / 100;
              maxWidth = parentSize.width * ratio;
            } else if (maxWidth.endsWith("px")) {
              maxWidth = Number(maxWidth.replace("px", ""));
            }
          }
          if (maxHeight && typeof maxHeight === "string") {
            if (maxHeight.endsWith("%")) {
              var ratio = Number(maxHeight.replace("%", "")) / 100;
              maxHeight = parentSize.height * ratio;
            } else if (maxHeight.endsWith("px")) {
              maxHeight = Number(maxHeight.replace("px", ""));
            }
          }
          var selfRect = self_1.getBoundingClientRect();
          var selfLeft = selfRect.left;
          var selfTop = selfRect.top;
          var boundaryRect = this.props.bounds === "window" ? { left: 0, top: 0 } : boundary.getBoundingClientRect();
          var boundaryLeft = boundaryRect.left;
          var boundaryTop = boundaryRect.top;
          var offsetWidth = this.getOffsetWidth(boundary);
          var offsetHeight = this.getOffsetHeight(boundary);
          var hasLeft = dir.toLowerCase().endsWith("left");
          var hasRight = dir.toLowerCase().endsWith("right");
          var hasTop = dir.startsWith("top");
          var hasBottom = dir.startsWith("bottom");
          if ((hasLeft || hasTop) && this.resizable) {
            var max = (selfLeft - boundaryLeft) / scale + this.resizable.size.width;
            this.setState({ maxWidth: max > Number(maxWidth) ? maxWidth : max });
          }
          if (hasRight || this.props.lockAspectRatio && !hasLeft && !hasTop) {
            var max = offsetWidth + (boundaryLeft - selfLeft) / scale;
            this.setState({ maxWidth: max > Number(maxWidth) ? maxWidth : max });
          }
          if ((hasTop || hasLeft) && this.resizable) {
            var max = (selfTop - boundaryTop) / scale + this.resizable.size.height;
            this.setState({
              maxHeight: max > Number(maxHeight) ? maxHeight : max
            });
          }
          if (hasBottom || this.props.lockAspectRatio && !hasTop && !hasLeft) {
            var max = offsetHeight + (boundaryTop - selfTop) / scale;
            this.setState({
              maxHeight: max > Number(maxHeight) ? maxHeight : max
            });
          }
        }
      } else {
        this.setState({
          maxWidth: this.props.maxWidth,
          maxHeight: this.props.maxHeight
        });
      }
      if (this.props.onResizeStart) {
        this.props.onResizeStart(e, dir, elementRef);
      }
    };
    Rnd2.prototype.onResize = function(e, direction, elementRef, delta) {
      var _this = this;
      var newPos = { x: this.originalPosition.x, y: this.originalPosition.y };
      var left = -delta.width;
      var top = -delta.height;
      var directions = ["top", "left", "topLeft", "bottomLeft", "topRight"];
      if (directions.includes(direction)) {
        if (direction === "bottomLeft") {
          newPos.x += left;
        } else if (direction === "topRight") {
          newPos.y += top;
        } else {
          newPos.x += left;
          newPos.y += top;
        }
      }
      var draggableState = this.draggable.state;
      if (newPos.x !== draggableState.x || newPos.y !== draggableState.y) {
        (0, import_react_dom2.flushSync)(function() {
          _this.draggable.setState(newPos);
        });
      }
      this.updateOffsetFromParent();
      var offset = this.offsetFromParent;
      var x = this.getDraggablePosition().x + offset.left;
      var y = this.getDraggablePosition().y + offset.top;
      this.resizingPosition = { x, y };
      if (!this.props.onResize)
        return;
      this.props.onResize(e, direction, elementRef, delta, {
        x,
        y
      });
    };
    Rnd2.prototype.onResizeStop = function(e, direction, elementRef, delta) {
      this.setState({
        resizing: false
      });
      var _a = this.getMaxSizesFromProps(), maxWidth = _a.maxWidth, maxHeight = _a.maxHeight;
      this.setState({ maxWidth, maxHeight });
      if (this.props.onResizeStop) {
        this.props.onResizeStop(e, direction, elementRef, delta, this.resizingPosition);
      }
    };
    Rnd2.prototype.updateSize = function(size) {
      if (!this.resizable)
        return;
      this.resizable.updateSize({ width: size.width, height: size.height });
    };
    Rnd2.prototype.updatePosition = function(position) {
      this.draggable.setState(position);
    };
    Rnd2.prototype.updateOffsetFromParent = function() {
      var scale = this.props.scale;
      var parent = this.getParent();
      var self2 = this.getSelfElement();
      if (!parent || self2 === null) {
        return {
          top: 0,
          left: 0
        };
      }
      var parentRect = parent.getBoundingClientRect();
      var parentLeft = parentRect.left;
      var parentTop = parentRect.top;
      var selfRect = self2.getBoundingClientRect();
      var position = this.getDraggablePosition();
      var scrollLeft = parent.scrollLeft;
      var scrollTop = parent.scrollTop;
      this.offsetFromParent = {
        left: selfRect.left - parentLeft + scrollLeft - position.x * scale,
        top: selfRect.top - parentTop + scrollTop - position.y * scale
      };
    };
    Rnd2.prototype.render = function() {
      var _this = this;
      var _a = this.props, disableDragging = _a.disableDragging, style = _a.style, dragHandleClassName = _a.dragHandleClassName, position = _a.position, onMouseDown = _a.onMouseDown, onMouseUp = _a.onMouseUp, dragAxis = _a.dragAxis, dragGrid = _a.dragGrid, bounds = _a.bounds, enableUserSelectHack = _a.enableUserSelectHack, cancel = _a.cancel, children = _a.children, onResizeStart = _a.onResizeStart, onResize = _a.onResize, onResizeStop = _a.onResizeStop, onDragStart = _a.onDragStart, onDrag = _a.onDrag, onDragStop = _a.onDragStop, resizeHandleStyles = _a.resizeHandleStyles, resizeHandleClasses = _a.resizeHandleClasses, resizeHandleComponent = _a.resizeHandleComponent, enableResizing = _a.enableResizing, resizeGrid = _a.resizeGrid, resizeHandleWrapperClass = _a.resizeHandleWrapperClass, resizeHandleWrapperStyle = _a.resizeHandleWrapperStyle, scale = _a.scale, allowAnyClick = _a.allowAnyClick, resizableProps = __rest3(_a, ["disableDragging", "style", "dragHandleClassName", "position", "onMouseDown", "onMouseUp", "dragAxis", "dragGrid", "bounds", "enableUserSelectHack", "cancel", "children", "onResizeStart", "onResize", "onResizeStop", "onDragStart", "onDrag", "onDragStop", "resizeHandleStyles", "resizeHandleClasses", "resizeHandleComponent", "enableResizing", "resizeGrid", "resizeHandleWrapperClass", "resizeHandleWrapperStyle", "scale", "allowAnyClick"]);
      var defaultValue = this.props.default ? __assign3({}, this.props.default) : void 0;
      delete resizableProps.default;
      var cursorStyle = disableDragging || dragHandleClassName ? { cursor: "auto" } : { cursor: "move" };
      var innerStyle = __assign3(__assign3(__assign3({}, resizableStyle), cursorStyle), style);
      var _b = this.offsetFromParent, left = _b.left, top = _b.top;
      var draggablePosition;
      if (position) {
        draggablePosition = {
          x: position.x - left,
          y: position.y - top
        };
      }
      var pos = this.state.resizing ? void 0 : draggablePosition;
      var dragAxisOrUndefined = this.state.resizing ? "both" : dragAxis;
      return (0, import_react9.createElement)(
        import_react_draggable.default,
        {
          ref: function(c) {
            if (!c)
              return;
            _this.draggable = c;
          },
          handle: dragHandleClassName ? ".".concat(dragHandleClassName) : void 0,
          defaultPosition: defaultValue,
          onMouseDown,
          // @ts-expect-error
          onMouseUp,
          onStart: this.onDragStart,
          onDrag: this.onDrag,
          onStop: this.onDragStop,
          axis: dragAxisOrUndefined,
          disabled: disableDragging,
          grid: dragGrid,
          bounds: bounds ? this.state.bounds : void 0,
          position: pos,
          enableUserSelectHack,
          cancel,
          scale,
          allowAnyClick,
          nodeRef: this.resizableElement
        },
        (0, import_react9.createElement)(Resizable, __assign3({}, resizableProps, { ref: function(c) {
          if (!c)
            return;
          _this.resizable = c;
          _this.resizableElement.current = c.resizable;
        }, defaultSize: defaultValue, size: this.props.size, enable: typeof enableResizing === "boolean" ? getEnableResizingByFlag(enableResizing) : enableResizing, onResizeStart: this.onResizeStart, onResize: this.onResize, onResizeStop: this.onResizeStop, style: innerStyle, minWidth: this.props.minWidth, minHeight: this.props.minHeight, maxWidth: this.state.resizing ? this.state.maxWidth : this.props.maxWidth, maxHeight: this.state.resizing ? this.state.maxHeight : this.props.maxHeight, grid: resizeGrid, handleWrapperClass: resizeHandleWrapperClass, handleWrapperStyle: resizeHandleWrapperStyle, lockAspectRatio: this.props.lockAspectRatio, lockAspectRatioExtraWidth: this.props.lockAspectRatioExtraWidth, lockAspectRatioExtraHeight: this.props.lockAspectRatioExtraHeight, handleStyles: resizeHandleStyles, handleClasses: resizeHandleClasses, handleComponent: resizeHandleComponent, scale: this.props.scale }), children)
      );
    };
    Rnd2.defaultProps = {
      maxWidth: Number.MAX_SAFE_INTEGER,
      maxHeight: Number.MAX_SAFE_INTEGER,
      scale: 1,
      onResizeStart: function() {
      },
      onResize: function() {
      },
      onResizeStop: function() {
      },
      onDragStart: function() {
      },
      onDrag: function() {
      },
      onDragStop: function() {
      }
    };
    return Rnd2;
  }(import_react9.PureComponent)
);

// node_modules/react-pdf-highlighter/dist/esm/components/AreaHighlight.js
import "C:/projects/pipeshub-v2/pipeshub-ai/standalone-frontend/node_modules/react-pdf-highlighter/dist/esm/style/AreaHighlight.css";
var __rest4 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var AreaHighlight = class extends import_react10.Component {
  render() {
    const _a = this.props, { highlight, onChange, isScrolledTo } = _a, otherProps = __rest4(_a, ["highlight", "onChange", "isScrolledTo"]);
    return import_react10.default.createElement(
      "div",
      { className: `AreaHighlight ${isScrolledTo ? "AreaHighlight--scrolledTo" : ""}` },
      import_react10.default.createElement(Rnd, Object.assign({ className: "AreaHighlight__part", onDragStop: (_, data) => {
        const boundingRect = Object.assign(Object.assign({}, highlight.position.boundingRect), { top: data.y, left: data.x });
        onChange(boundingRect);
      }, onResizeStop: (_mouseEvent, _direction, ref, _delta, position) => {
        var _a2;
        const boundingRect = {
          top: position.y,
          left: position.x,
          width: ref.offsetWidth,
          height: ref.offsetHeight,
          pageNumber: ((_a2 = getPageFromElement(ref)) === null || _a2 === void 0 ? void 0 : _a2.number) || -1
        };
        onChange(boundingRect);
      }, position: {
        x: highlight.position.boundingRect.left,
        y: highlight.position.boundingRect.top
      }, size: {
        width: highlight.position.boundingRect.width,
        height: highlight.position.boundingRect.height
      }, onClick: (event) => {
        event.stopPropagation();
        event.preventDefault();
      } }, otherProps))
    );
  }
};

// node_modules/react-pdf-highlighter/dist/esm/components/PdfLoader.js
var import_react11 = __toESM(require_react());
var import_pdf = __toESM(require_pdf());
var PdfLoader = class extends import_react11.Component {
  constructor() {
    super(...arguments);
    this.state = {
      pdfDocument: null,
      error: null
    };
    this.documentRef = import_react11.default.createRef();
  }
  componentDidMount() {
    this.load();
  }
  componentWillUnmount() {
    const { pdfDocument: discardedDocument } = this.state;
    if (discardedDocument) {
      discardedDocument.destroy();
    }
  }
  componentDidUpdate({ url }) {
    if (this.props.url !== url) {
      this.load();
    }
  }
  componentDidCatch(error, info) {
    const { onError } = this.props;
    if (onError) {
      onError(error);
    }
    this.setState({ pdfDocument: null, error });
  }
  load() {
    const { ownerDocument = document } = this.documentRef.current || {};
    const { url, cMapUrl, cMapPacked, workerSrc } = this.props;
    const { pdfDocument: discardedDocument } = this.state;
    this.setState({ pdfDocument: null, error: null });
    if (typeof workerSrc === "string") {
      import_pdf.GlobalWorkerOptions.workerSrc = workerSrc;
    }
    Promise.resolve().then(() => discardedDocument && discardedDocument.destroy()).then(() => {
      if (!url) {
        return;
      }
      return (0, import_pdf.getDocument)(Object.assign(Object.assign({}, this.props), {
        ownerDocument,
        cMapUrl,
        cMapPacked
      })).promise.then((pdfDocument) => {
        this.setState({ pdfDocument });
      });
    }).catch((e) => this.componentDidCatch(e));
  }
  render() {
    const { children, beforeLoad } = this.props;
    const { pdfDocument, error } = this.state;
    return import_react11.default.createElement(
      import_react11.default.Fragment,
      null,
      import_react11.default.createElement("span", { ref: this.documentRef }),
      error ? this.renderError() : !pdfDocument || !children ? beforeLoad : children(pdfDocument)
    );
  }
  renderError() {
    const { errorMessage } = this.props;
    if (errorMessage) {
      return import_react11.default.cloneElement(errorMessage, { error: this.state.error });
    }
    return null;
  }
};
PdfLoader.defaultProps = {
  workerSrc: "https://unpkg.com/pdfjs-dist@2.16.105/build/pdf.worker.min.js"
};
export {
  AreaHighlight,
  Highlight,
  PdfHighlighter,
  PdfLoader,
  Popup,
  Tip
};
/*! Bundled license information:

dommatrix/dist/dommatrix.js:
  (*!
  * DOMMatrix v1.0.3 (https://thednp.github.io/dommatrix/)
  * Copyright 2022 © thednp
  * Licensed under MIT (https://github.com/thednp/DOMMatrix/blob/master/LICENSE)
  *)

web-streams-polyfill/dist/ponyfill.js:
  (**
   * @license
   * web-streams-polyfill v3.3.3
   * Copyright 2024 Mattias Buelens, Diwank Singh Tomer and other contributors.
   * This code is released under the MIT license.
   * SPDX-License-Identifier: MIT
   *)

react-rnd/lib/index.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0
  
  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.
  
  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** *)
*/
//# sourceMappingURL=react-pdf-highlighter.js.map
